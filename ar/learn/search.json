[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "الأولمبياد الوطني للعلوم والرياضيات (نسمو)",
    "section": "",
    "text": "الأولمبياد الوطني للعلوم والرياضيات (نسمو)\nالأولمبياد الوطني للعلوم والرياضيات (نسمو) هو منافسة وطنية سنوية تُنظَّم بالتعاون مع وزارة التعليم. تشمل المنافسة عدة مراحل خلال العام الدراسي، وتستهدف الطلاب السعوديين في التعليم العام في مجالات الرياضيات، العلوم، المعلوماتية، الكيمياء، الفيزياء، والأحياء.\nمراحل المنافسة:\n\nالمرحلة 1: على مستوى المدن والمحافظات.\nالمرحلة 2: إدارات التعليم العام.\nالمرحلة 3: اختيار الطلاب لتمثيل إدارات التعليم.\nالمرحلة 4: المنافسة الوطنية الكبرى على مستوى المملكة.\n\n\n\nالمعلوماتية (البرمجة التنافسية)\nالمعلوماتية هي أحد المواد المشمولة ضمن نسمو. هذا الموقع سيُعِدّك لهذه المنافسة، مرحلةً بعد مرحلة. سيعرّفك على عالم البرمجة التنافسية، ولا يتطلب أي خبرة مسبقة.\nالبرمجة التنافسية هي رياضة ذهنية يقوم فيها المشاركون بحل مشكلات خوارزمية باستخدام البرمجة. تُطرح هذه المشكلات في مسابقات تمتد عادةً لعدة ساعات. لحلها، يجب أن تصمّم خوارزمية فعّالة وتطبّقها بلغة برمجة.\nسنبدأ بتعلم لغة ++C، وهي اللغة الأكثر استخدامًا في البرمجة التنافسية. بعد ذلك، سننتقل إلى حل المشكلات واستكشاف الخوارزميات والتقنيات الأساسية.\nامتلاك مهارات قوية في الرياضيات يساعد كثيرًا في البرمجة التنافسية. ومع تقدمك، ستجد أن التفكير التحليلي هو أهم مهارة على الإطلاق."
  },
  {
    "objectID": "b3/trees/dp-on-trees.html",
    "href": "b3/trees/dp-on-trees.html",
    "title": "البرمجة الديناميكية على الأشجار",
    "section": "",
    "text": "الـ Tree DP هي ببساطة برمجة ديناميكية يكون فيها جواب كل عقدة معتمداً على أجوبة أبنائها (بعد اختيار جذر).\nبأبسط شكل:\n\nجذّر الشجرة (اختر عقدة لتكون الجذر)\nنفّذ DFS\nأثناء الرجوع من DFS (من الأسفل للأعلى)، احسب قيم DP لكل عقدة باستخدام قيم أبنائها\n\nلماذا هذا يعمل: بعد تجذير الشجرة، كل عقدة “تتحكم” في شجرتها الفرعية، والأشجار الفرعية لا تتداخل. لذلك يمكنك حل كل شجرة فرعية مرة واحدة ثم دمج النتائج.\n\n\nاختر أكبر عدد ممكن من العقد بحيث:\n\nلا تختار عقدتين متجاورتين (لا يوجد حرف طرفاه مختاران)\n\n\n\nإذا اخترت العقدة v، فأنت مُجبر على عدم اختيار جميع جيران v.\nفي شجرة مُجذّرة، الجيران المهمون هم:\n\nالأب\nالأبناء\n\nفتصبح المسألة خياراً بسيطاً عند كل عقدة:\n\nاختَر هذه العقدة → يجب أن تتجاوز جميع الأبناء\nاترك هذه العقدة → كل ابن يمكن اختياره أو تركه، أيهما أفضل\n\n\n\n\n\nلكل عقدة v:\n\ndp1[v]: أفضل نتيجة في الشجرة الفرعية لـ v إذا كانت v مختارة\ndp0[v]: أفضل نتيجة في الشجرة الفرعية لـ v إذا كانت v غير مختارة\n\n“الشجرة الفرعية لـ v” تعني v وكل أحفادها تحتها (بعد التجذير).\n\n\n\nنفترض أننا عند العقدة v وقد حسبنا DP لجميع الأبناء.\n\n\nعندها لا يمكن اختيار أي ابن.\nلذلك لكل ابن c يجب استخدام dp0[c].\ndp1[v] = 1 + sum(dp0[c] for all children c)\n\n1 لأننا نعدّ العقدة v نفسها\nالأبناء يجب أن يكونوا في حالة “غير مختار”\n\n\n\n\nعندها كل ابن c حر:\n\nإما نختار c (نأخذ dp1[c])\nأو نترك c (نأخذ dp0[c])\n\nنأخذ الأفضل لكل ابن بشكل مستقل:\ndp0[v] = sum( max(dp0[c], dp1[c]) for all children c )\n\n\n\n\nللشجرة كاملة، عند الجذر يمكننا إما اختياره أو لا:\nanswer = max(dp0[root], dp1[root])\n\n\n\n\nint n;\nvector&lt;vector&lt;int&gt;&gt; g;\n\nvector&lt;int&gt; dp0, dp1;\n\nvoid dfs(int v, int p) {\n    dp1[v] = 1;  // choose v\n    dp0[v] = 0;  // don't choose v\n\n    for (int to : g[v]) {\n        if (to == p) continue;\n        dfs(to, v);\n\n        // if we choose v, we must NOT choose child\n        dp1[v] += dp0[to];\n\n        // if we don't choose v, child can be either\n        dp0[v] += max(dp0[to], dp1[to]);\n    }\n}\n\nالاستخدام:\n\nint root = 0;\ndp0.assign(n, 0);\ndp1.assign(n, 0);\n\ndfs(root, -1);\n\nint ans = max(dp0[root], dp1[root]);\n\n\n\n\nلنقل إن v لديه ابنان: a و b.\nوقد حسبت مسبقاً:\n\ndp0[a] = 3، dp1[a] = 4\ndp0[b] = 2، dp1[b] = 2\n\nحينها:\nإذا اخترت v:\n\nيجب أن تترك a و b\n\ndp1[v] = 1 + dp0[a] + dp0[b] = 1 + 3 + 2 = 6\nإذا تركت v:\n\nتختار الأفضل لكل ابن\n\ndp0[v] = max(3,4) + max(2,2) = 4 + 2 = 6\nإذن الطريقتان تعطيان 6 هنا.\n\n\n\nأغلب مسائل Tree DP تكون بهذا الشكل:\n\nاختر جذراً\nعرّف حالات DP لكل عقدة\nنفّذ DFS لحساب الأبناء أولاً\nادمج نتائج الأبناء بصيغ بسيطة\n\nلكن كلما تعقدت المسائل، قد تحتاج تصاميم أكثر تعقيداً.\nتصميم شائع جداً هو بالضبط ما رأيته:\n\nالحالة = “خذ العقدة” مقابل “اترك العقدة”",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "البرمجة الديناميكية على الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/dp-on-trees.html#مهمة-بسيطة-أكبر-مجموعة-مستقلة",
    "href": "b3/trees/dp-on-trees.html#مهمة-بسيطة-أكبر-مجموعة-مستقلة",
    "title": "البرمجة الديناميكية على الأشجار",
    "section": "",
    "text": "اختر أكبر عدد ممكن من العقد بحيث:\n\nلا تختار عقدتين متجاورتين (لا يوجد حرف طرفاه مختاران)\n\n\n\nإذا اخترت العقدة v، فأنت مُجبر على عدم اختيار جميع جيران v.\nفي شجرة مُجذّرة، الجيران المهمون هم:\n\nالأب\nالأبناء\n\nفتصبح المسألة خياراً بسيطاً عند كل عقدة:\n\nاختَر هذه العقدة → يجب أن تتجاوز جميع الأبناء\nاترك هذه العقدة → كل ابن يمكن اختياره أو تركه، أيهما أفضل",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "البرمجة الديناميكية على الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/dp-on-trees.html#حالات-dp-رقمان-لكل-عقدة",
    "href": "b3/trees/dp-on-trees.html#حالات-dp-رقمان-لكل-عقدة",
    "title": "البرمجة الديناميكية على الأشجار",
    "section": "",
    "text": "لكل عقدة v:\n\ndp1[v]: أفضل نتيجة في الشجرة الفرعية لـ v إذا كانت v مختارة\ndp0[v]: أفضل نتيجة في الشجرة الفرعية لـ v إذا كانت v غير مختارة\n\n“الشجرة الفرعية لـ v” تعني v وكل أحفادها تحتها (بعد التجذير).",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "البرمجة الديناميكية على الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/dp-on-trees.html#الانتقالات-كيف-نحسبها",
    "href": "b3/trees/dp-on-trees.html#الانتقالات-كيف-نحسبها",
    "title": "البرمجة الديناميكية على الأشجار",
    "section": "",
    "text": "نفترض أننا عند العقدة v وقد حسبنا DP لجميع الأبناء.\n\n\nعندها لا يمكن اختيار أي ابن.\nلذلك لكل ابن c يجب استخدام dp0[c].\ndp1[v] = 1 + sum(dp0[c] for all children c)\n\n1 لأننا نعدّ العقدة v نفسها\nالأبناء يجب أن يكونوا في حالة “غير مختار”\n\n\n\n\nعندها كل ابن c حر:\n\nإما نختار c (نأخذ dp1[c])\nأو نترك c (نأخذ dp0[c])\n\nنأخذ الأفضل لكل ابن بشكل مستقل:\ndp0[v] = sum( max(dp0[c], dp1[c]) for all children c )",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "البرمجة الديناميكية على الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/dp-on-trees.html#الجواب-النهائي",
    "href": "b3/trees/dp-on-trees.html#الجواب-النهائي",
    "title": "البرمجة الديناميكية على الأشجار",
    "section": "",
    "text": "للشجرة كاملة، عند الجذر يمكننا إما اختياره أو لا:\nanswer = max(dp0[root], dp1[root])",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "البرمجة الديناميكية على الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/dp-on-trees.html#التنفيذ-dfs",
    "href": "b3/trees/dp-on-trees.html#التنفيذ-dfs",
    "title": "البرمجة الديناميكية على الأشجار",
    "section": "",
    "text": "int n;\nvector&lt;vector&lt;int&gt;&gt; g;\n\nvector&lt;int&gt; dp0, dp1;\n\nvoid dfs(int v, int p) {\n    dp1[v] = 1;  // choose v\n    dp0[v] = 0;  // don't choose v\n\n    for (int to : g[v]) {\n        if (to == p) continue;\n        dfs(to, v);\n\n        // if we choose v, we must NOT choose child\n        dp1[v] += dp0[to];\n\n        // if we don't choose v, child can be either\n        dp0[v] += max(dp0[to], dp1[to]);\n    }\n}\n\nالاستخدام:\n\nint root = 0;\ndp0.assign(n, 0);\ndp1.assign(n, 0);\n\ndfs(root, -1);\n\nint ans = max(dp0[root], dp1[root]);",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "البرمجة الديناميكية على الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/dp-on-trees.html#مثال-توضيحي-صغير",
    "href": "b3/trees/dp-on-trees.html#مثال-توضيحي-صغير",
    "title": "البرمجة الديناميكية على الأشجار",
    "section": "",
    "text": "لنقل إن v لديه ابنان: a و b.\nوقد حسبت مسبقاً:\n\ndp0[a] = 3، dp1[a] = 4\ndp0[b] = 2، dp1[b] = 2\n\nحينها:\nإذا اخترت v:\n\nيجب أن تترك a و b\n\ndp1[v] = 1 + dp0[a] + dp0[b] = 1 + 3 + 2 = 6\nإذا تركت v:\n\nتختار الأفضل لكل ابن\n\ndp0[v] = max(3,4) + max(2,2) = 4 + 2 = 6\nإذن الطريقتان تعطيان 6 هنا.",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "البرمجة الديناميكية على الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/dp-on-trees.html#ما-الذي-تتذكره-نمط-tree-dp",
    "href": "b3/trees/dp-on-trees.html#ما-الذي-تتذكره-نمط-tree-dp",
    "title": "البرمجة الديناميكية على الأشجار",
    "section": "",
    "text": "أغلب مسائل Tree DP تكون بهذا الشكل:\n\nاختر جذراً\nعرّف حالات DP لكل عقدة\nنفّذ DFS لحساب الأبناء أولاً\nادمج نتائج الأبناء بصيغ بسيطة\n\nلكن كلما تعقدت المسائل، قد تحتاج تصاميم أكثر تعقيداً.\nتصميم شائع جداً هو بالضبط ما رأيته:\n\nالحالة = “خذ العقدة” مقابل “اترك العقدة”",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "البرمجة الديناميكية على الأشجار"
    ]
  },
  {
    "objectID": "b3/problems/subordinates.html",
    "href": "b3/problems/subordinates.html",
    "title": "",
    "section": "",
    "text": "Subordinates\n\nCSES\neasy\n\n\n\nشركة لديها n موظفاً مرقمين من 1..n. الموظف 1 هو المدير العام.\nلكل موظف من 2..n يُعطى رقم مديره المباشر. هذا يحدد الهيكل الإداري للشركة (يمكن للمدير أن يكون لديه عدة موظفين مباشرين).\nمهمتك هي حساب، لكل موظف من 1..n، كم عدد المرؤوسين لديه بالمجموع (مباشرين وغير مباشرين).\nالمدخل:\n\nالسطر الأول: عدد صحيح n — عدد الموظفين.\nالسطر الثاني: n-1 أعداد صحيحة p2 p3 ... pn حيث pi هو المدير المباشر للموظف i.\n\nالمخرجات:\n\nاطبع n أعداد صحيحة: لكل موظف من 1..n، عدد مرؤوسيه.\n\nالقيود:\n\n1 ≤ n ≤ 2 · 10^5\n\nمثال:\nالمدخل:\n\n5\n1 1 2 3\n\nالمخرجات:\n\n4 1 1 0 0",
    "crumbs": [
      "المرحلة 4",
      "Practice Problems",
      "Subordinates"
    ]
  },
  {
    "objectID": "b3/problems/subordinates.html#subordinates",
    "href": "b3/problems/subordinates.html#subordinates",
    "title": "",
    "section": "",
    "text": "Subordinates\n\nCSES\neasy\n\n\n\nشركة لديها n موظفاً مرقمين من 1..n. الموظف 1 هو المدير العام.\nلكل موظف من 2..n يُعطى رقم مديره المباشر. هذا يحدد الهيكل الإداري للشركة (يمكن للمدير أن يكون لديه عدة موظفين مباشرين).\nمهمتك هي حساب، لكل موظف من 1..n، كم عدد المرؤوسين لديه بالمجموع (مباشرين وغير مباشرين).\nالمدخل:\n\nالسطر الأول: عدد صحيح n — عدد الموظفين.\nالسطر الثاني: n-1 أعداد صحيحة p2 p3 ... pn حيث pi هو المدير المباشر للموظف i.\n\nالمخرجات:\n\nاطبع n أعداد صحيحة: لكل موظف من 1..n، عدد مرؤوسيه.\n\nالقيود:\n\n1 ≤ n ≤ 2 · 10^5\n\nمثال:\nالمدخل:\n\n5\n1 1 2 3\n\nالمخرجات:\n\n4 1 1 0 0",
    "crumbs": [
      "المرحلة 4",
      "Practice Problems",
      "Subordinates"
    ]
  },
  {
    "objectID": "b3/problems/labyrinth.html",
    "href": "b3/problems/labyrinth.html",
    "title": "",
    "section": "",
    "text": "Labyrinth\n\nCSES\neasy\n\n\n\nأُعطيت خريطة لمتاهة، ومهمتك إيجاد مسار من البداية إلى النهاية. يمكنك المشي يساراً ويميناً وأعلى وأسفل.\nالمدخل:\n\nالسطر الأول: عددان صحيحان n و m — الارتفاع والعرض.\nثم n أسطر: كل سطر يحتوي m حرفاً:\n\n. أرضية\n# جدار\nA البداية\nB النهاية\nيوجد بالضبط حرف A واحد وحرف B واحد.\n\n\nالمخرجات:\n\nاطبع \"YES\" إذا كان هناك مسار، وإلا اطبع \"NO\".\nإذا كان هناك مسار، اطبع أيضاً:\n\nطول أقصر مسار\nسلسلة تصف المسار باستخدام L, R, U, D\n(أي أقصر مسار مقبول)\n\n\nالقيود:\n\n1 ≤ n, m ≤ 1000\n\nمثال:\nالمدخل:\n\n5 8\n########\n#.A#...#\n#.##.#B#\n#......#\n########\n\nالمخرجات:\n\nYES\n9\nLDDRRRRRU\n\n\n\n\n\n\nSolution\n\nنحتاج أقصر مسار في شبكة غير موزونة (كل حركة تكلفتها 1). هذا بالضبط ما تعطيه BFS.\nاعتبر كل خلية مفتوحة عقدة، وتوجد أحرف بين الخلايا المفتوحة المتجاورة (أعلى/أسفل/يسار/يمين). شغّل BFS من A، وخزّن من أين أتينا (أب + حركة)، ثم أعد بناء المسار عندما نصل إلى B.\n\n\n\nنحافظ على:\n\ndist[r][c] = المسافة من A إلى الخلية (r,c) (-1 يعني غير مُزارة)\nparDir[r][c] = أي حركة استُخدمت للدخول إلى (r,c) من أبيها (واحدة من L,R,U,D)\n\nBFS تستكشف الخلايا بترتيب مسافة متزايدة، لذا أول مرة نصل فيها إلى B تكون مضمونة أنها الأقصر.\n\n\n\n\nإذا كانت B قابلة للوصول، نرجع للخلف من B إلى A باستخدام parDir:\n\nإذا كانت parDir[cur] == 'U' فهذا يعني أننا تحركنا للأعلى للوصول إلى cur، إذن الأب يقع صفاً واحداً للأسفل، وهكذا.\nنجمع الحركات ثم نعكسها في النهاية.\n\n\n\n\n\n\nإذا كانت dist[B] == -1 → اطبع NO.\nغير ذلك اطبع YES، ثم dist[B]، ثم سلسلة الحركات المُعادة بناؤها.\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;queue&gt;\n#include &lt;utility&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;string&gt; grid(n);\n    for (int i = 0; i &lt; n; i++) cin &gt;&gt; grid[i];\n\n    pair&lt;int,int&gt; A{-1,-1}, B{-1,-1};\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; m; j++) {\n            if (grid[i][j] == 'A') A = {i, j};\n            if (grid[i][j] == 'B') B = {i, j};\n        }\n    }\n\n    vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(m, -1));\n    vector&lt;vector&lt;char&gt;&gt; parDir(n, vector&lt;char&gt;(m, 0));\n\n    queue&lt;pair&lt;int,int&gt;&gt; q;\n    dist[A.first][A.second] = 0;\n    q.push(A);\n\n    // Directions: (dr, dc, moveChar)\n    const int dr[4] = {-1, 1, 0, 0};\n    const int dc[4] = {0, 0, -1, 1};\n    const char mv[4] = {'U', 'D', 'L', 'R'};\n\n    while (!q.empty()) {\n        auto [r, c] = q.front(); q.pop();\n\n        for (int k = 0; k &lt; 4; k++) {\n            int nr = r + dr[k];\n            int nc = c + dc[k];\n\n            if (nr &lt; 0 || nr &gt;= n || nc &lt; 0 || nc &gt;= m) continue;\n            if (grid[nr][nc] == '#') continue;\n            if (dist[nr][nc] != -1) continue;\n\n            dist[nr][nc] = dist[r][c] + 1;\n            parDir[nr][nc] = mv[k];\n            q.push({nr, nc});\n        }\n    }\n\n    if (dist[B.first][B.second] == -1) {\n        cout &lt;&lt; \"NO\\n\";\n        return 0;\n    }\n\n    cout &lt;&lt; \"YES\\n\";\n    cout &lt;&lt; dist[B.first][B.second] &lt;&lt; \"\\n\";\n\n    // Reconstruct path from B back to A\n    string path;\n    int r = B.first, c = B.second;\n    while (!(r == A.first && c == A.second)) {\n        char d = parDir[r][c];\n        path.push_back(d);\n\n        // Move to parent (reverse the move)\n        if (d == 'U') r += 1;\n        else if (d == 'D') r -= 1;\n        else if (d == 'L') c += 1;\n        else if (d == 'R') c -= 1;\n    }\n\n    reverse(path.begin(), path.end());\n    cout &lt;&lt; path &lt;&lt; \"\\n\";\n    return 0;\n}",
    "crumbs": [
      "المرحلة 4",
      "Problems",
      "Labyrinth"
    ]
  },
  {
    "objectID": "b3/problems/labyrinth.html#labyrinth",
    "href": "b3/problems/labyrinth.html#labyrinth",
    "title": "",
    "section": "",
    "text": "Labyrinth\n\nCSES\neasy\n\n\n\nأُعطيت خريطة لمتاهة، ومهمتك إيجاد مسار من البداية إلى النهاية. يمكنك المشي يساراً ويميناً وأعلى وأسفل.\nالمدخل:\n\nالسطر الأول: عددان صحيحان n و m — الارتفاع والعرض.\nثم n أسطر: كل سطر يحتوي m حرفاً:\n\n. أرضية\n# جدار\nA البداية\nB النهاية\nيوجد بالضبط حرف A واحد وحرف B واحد.\n\n\nالمخرجات:\n\nاطبع \"YES\" إذا كان هناك مسار، وإلا اطبع \"NO\".\nإذا كان هناك مسار، اطبع أيضاً:\n\nطول أقصر مسار\nسلسلة تصف المسار باستخدام L, R, U, D\n(أي أقصر مسار مقبول)\n\n\nالقيود:\n\n1 ≤ n, m ≤ 1000\n\nمثال:\nالمدخل:\n\n5 8\n########\n#.A#...#\n#.##.#B#\n#......#\n########\n\nالمخرجات:\n\nYES\n9\nLDDRRRRRU",
    "crumbs": [
      "المرحلة 4",
      "Problems",
      "Labyrinth"
    ]
  },
  {
    "objectID": "b3/problems/atothenmodm.html",
    "href": "b3/problems/atothenmodm.html",
    "title": "",
    "section": "",
    "text": "AtotheNmodM\n\n\nmedium\n\n\n\nلديك الأعداد الطبيعية \\(A, N\\) و\\(M\\). حدّد ما إذا كان العدد \\(A^N\\) يقبل القسمة القسمة على \\(M\\).\nملاحظة: انتبه إلى أن العدد \\(A^N\\) قد يكون ضخمًا جدًا — يُنصح بتحليل العددين \\(A\\) و\\(M\\) إلى عواملهما الأولية ودراسة عواملهما الأولية!\nالمدخلات:\n\nالسطر الأول والوحيد يحتوي، بالترتيب، على الأعداد الطبيعية \\(N, M\\) و\\(A\\).\n\nالمخرجات:\n\nاطبع “YES” إذا كان العدد \\(A^N\\) يقبل القسمة على \\(M\\)، وإلا اطبع “NO”.\n\nالمحددات:\n\n\\(1 \\leq A, N, M \\leq 10^9\\)\n\nإذا كانت هذه المسألة صعبة جدًا عليك، فحاول حلّها عندما * يكون كل من \\(A\\) و\\(M\\) قوتين للعدد 2\nأو، إذا كانت لا تزال صعبة جدًا، فحاول حلّها عندما * \\(1 \\leq N \\leq 2\\)\nمثال:\nمدخل:\n50 2 10\nمخرج:\nYES\n\n\n\n\n\nSolution\n\nالعدد \\(A^N\\) قد يكون ضخمًا بشكل فلكي، لذلك يجب ألا نحسبه مباشرة.\nحلّل إلى عوامل أولية:\n\\[M = \\prod p_i^{e_i}\\]\nليكن \\(v_i = v_{p_i}(A)\\) هو أسّ العدد الأولي \\(p_i\\) في \\(A\\).\nعندئذٍ في \\(A^N\\) يصبح الأسّ:\n\\[v_{p_i}(A^N) = N \\cdot v_{p_i}(A)\\]\nإذًا:\n\\[M \\mid A^N \\iff \\forall i:\\; N\\cdot v_{p_i}(A)\\ge e_i\\]\nوعليه تكون الخوارزمية كما يلي:\n\nإذا كان \\(M = 1\\): فالجواب YES.\nحلّل \\(M\\) إلى قوى أولية \\(p^e\\).\nلكل عدد أولي \\(p^e\\) في \\(M\\):\n\nاحسب عدد المرات التي يقسم فيها \\(p\\) العدد \\(A\\)، ولنسمّه \\(v\\).\nإذا كان \\(v = 0\\)، فإن \\(A^N\\) لا يحتوي على \\(p\\)، إذًا الجواب NO.\nوإلا تحقّق من أن \\(N\\cdot v \\ge e\\).\nلتجنّب تجاوز السعة المستخدمة، استخدم: \\[N \\ge \\left\\lceil \\frac{e}{v} \\right\\rceil\\]\n\nإذا تحققت جميع الشروط للقوى الأولية، فالجواب YES، وإلا NO.\n\nدرجة التعقية:\n\nالتحليل إلى عوامل أولية باستخدام القسمة التجريبية: \\(O(\\sqrt{M})\\)\nولكل عامل أولي، حساب الأسّ في \\(A\\): \\(O(\\log A)\\)\n\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nlong long ceil_div(long long a, long long b) {\n    // b &gt; 0\n    return (a + b - 1) / b;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    long long A, N, M;\n    cin &gt;&gt; A &gt;&gt; N &gt;&gt; M;\n\n    if (M == 1) {\n        cout &lt;&lt; \"YES\\n\";\n        return 0;\n    }\n\n    long long m = M;\n\n    // Factorize M: m = product p^e\n    for (long long p = 2; p * p &lt;= m; ++p) {\n        if (m % p != 0) \n            continue;\n\n        long long e = 0;\n        while (m % p == 0) {\n            m /= p;\n            e++;\n        }\n\n        // Compute v_p(A)\n        long long v = 0;\n        long long tempA = A;\n        while (tempA % p == 0) {\n            tempA /= p;\n            v++;\n        }\n\n        if (v == 0) {\n            cout &lt;&lt; \"NO\\n\";\n            return 0;\n        }\n\n        // Need N * v &gt;= e  &lt;=&gt;  N &gt;= ceil(e / v)\n        long long need = ceil_div(e, v);\n        if (N &lt; need) {\n            cout &lt;&lt; \"NO\\n\";\n            return 0;\n        }\n    }\n\n    // If remaining m &gt; 1, it's a prime factor with exponent 1\n    if (m &gt; 1) {\n        long long p = m;\n        long long e = 1;\n\n        long long v = 0;\n        long long tempA = A;\n        while (tempA % p == 0) {\n            tempA /= p;\n            v++;\n        }\n\n        if (v == 0) {\n            cout &lt;&lt; \"NO\\n\";\n            return 0;\n        }\n\n        long long need = ceil_div(e, v); // e=1 =&gt; need=1 always if v&gt;=1\n        if (N &lt; need) {\n            cout &lt;&lt; \"NO\\n\";\n            return 0;\n        }\n    }\n\n    cout &lt;&lt; \"YES\\n\";\n    return 0;\n}",
    "crumbs": [
      "المرحلة 4",
      "Problems",
      "AtotheNmodM"
    ]
  },
  {
    "objectID": "b3/problems/atothenmodm.html#atothenmodm",
    "href": "b3/problems/atothenmodm.html#atothenmodm",
    "title": "",
    "section": "",
    "text": "AtotheNmodM\n\n\nmedium\n\n\n\nلديك الأعداد الطبيعية \\(A, N\\) و\\(M\\). حدّد ما إذا كان العدد \\(A^N\\) يقبل القسمة القسمة على \\(M\\).\nملاحظة: انتبه إلى أن العدد \\(A^N\\) قد يكون ضخمًا جدًا — يُنصح بتحليل العددين \\(A\\) و\\(M\\) إلى عواملهما الأولية ودراسة عواملهما الأولية!\nالمدخلات:\n\nالسطر الأول والوحيد يحتوي، بالترتيب، على الأعداد الطبيعية \\(N, M\\) و\\(A\\).\n\nالمخرجات:\n\nاطبع “YES” إذا كان العدد \\(A^N\\) يقبل القسمة على \\(M\\)، وإلا اطبع “NO”.\n\nالمحددات:\n\n\\(1 \\leq A, N, M \\leq 10^9\\)\n\nإذا كانت هذه المسألة صعبة جدًا عليك، فحاول حلّها عندما * يكون كل من \\(A\\) و\\(M\\) قوتين للعدد 2\nأو، إذا كانت لا تزال صعبة جدًا، فحاول حلّها عندما * \\(1 \\leq N \\leq 2\\)\nمثال:\nمدخل:\n50 2 10\nمخرج:\nYES",
    "crumbs": [
      "المرحلة 4",
      "Problems",
      "AtotheNmodM"
    ]
  },
  {
    "objectID": "b3/number-theory/sieve.html",
    "href": "b3/number-theory/sieve.html",
    "title": "غربال إراتوستينس",
    "section": "",
    "text": "نعلم كيفية التحقق مما إذا كان عدد واحد أولياً (\\(O(\\sqrt{N})\\)). ولكن ماذا لو كنت بحاجة لإيجاد جميع الأعداد الأولية حتى \\(1,000,000\\)؟\nاستخدام الطريقة السابقة داخل حلقة سيكون بطيئاً جداً (\\(N \\times \\sqrt{N}\\)). نحتاج إلى عملية مجمعة. نحتاج إلى غربال.\n\n\nبدلاً من فحص الأعداد واحداً تلو الآخر، نقوم بتصفيتها.\nتخيل كتابة جميع الأعداد من 1 إلى 20. 1. نعلم أن 2 أولي. ضع دائرة حوله. الآن اشطب جميع مضاعفات 2 (4، 6، 8، 10…). 2. العدد التالي غير المشطوب هو 3. ضع دائرة حوله. اشطب جميع مضاعفات 3 (6، 9، 12…). 3. العدد التالي غير المشطوب هو 5 (4 مشطوب). ضع دائرة حوله. اشطب المضاعفات…\nبحلول الوقت الذي تصل فيه إلى النهاية، تبقى الأعداد الأولية فقط غير مشطوبة.\n\n\n\nنستخدم مصفوفة منطقية isPrime[] حيث isPrime[i] صحيح إذا كان i محتمل أن يكون أولياً. في البداية، نفترض أن كل شيء أولي.\n\n\n\nأنشئ مصفوفة من القيم المنطقية، اجعلها جميعاً true.\nضع علامة على 0 و 1 كـ false (ليسا أوليين).\nابدأ الحلقة من i = 2.\nإذا كان i أولياً (true)، فهذا يعني أنه لا يوجد عدد أصغر قسمه.\nحلقة عبر جميع مضاعفات i (2*i، 3*i…) وضع عليها علامة false.\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Maximum number we want to check (e.g., 1 million)\nconst int MAX_N = 1000000;\nvector&lt;bool&gt; is_prime(MAX_N + 1, true); // Assume all are prime first\n\nvoid sieve() {\n    is_prime[0] = is_prime[1] = false; // Edge cases\n\n    for (int i = 2; i * i &lt;= MAX_N; i++) {\n        // If i is not crossed out yet, it is a prime\n        if (is_prime[i]) {\n            // Cross out all multiples of i\n            // Optimization: Start from i * i (smaller multiples are already handled)\n            for (int j = i * i; j &lt;= MAX_N; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n}\n\n\n\n\nهذا تحسين حاسم. عندما \\(i = 5\\)، لماذا لا نشطب 10 (\\(2 \\times 5\\)) أو 15 (\\(3 \\times 5\\))؟\n\nلأن 10 تم شطبه بالفعل بواسطة 2.\nلأن 15 تم شطبه بالفعل بواسطة 3.\n\nأول مضاعف لـ 5 لم يُلمس بعد هو \\(5 \\times 5 = 25\\).\n\n\n\nهذه الخوارزمية فعالة بشكل مشهور. على الرغم من وجود حلقات متداخلة، فهي بشكل مفاجئ ليست \\(O(N^2)\\). إنها \\(O(N \\log (\\log N))\\). هذا تقريباً خطي. بالنسبة لـ \\(N = 10^7\\) (10 مليون)، تعمل في جزء من الثانية.\n\n\n\n\n\n\n\n\n\nNoldbach\n\n\n\n\n\nينص Noldbach على أن على الأقل \\(k\\) عدداً أولياً من \\(2\\) إلى \\(n\\) شاملاً يمكن التعبير عنه كمجموع ثلاثة أعداد صحيحة: عددان أوليان متجاوران و \\(1\\). على سبيل المثال، \\(19 = 7 + 11 + 1\\)، أو \\(13 = 5 + 7 + 1\\).\nيُطلق على عددين أوليين اسم متجاورين إذا لم تكن هناك أعداد أولية أخرى بينهما.\nاكتشف ما إذا كان Noldbach على حق أم على خطأ.\n\n\n\n\n\nSolution\n\nلحل هذا، نحتاج إلى قائمة بجميع الأعداد الأولية بين \\(2\\) و \\(n\\). بينما يمكنك اختبار كل عدد بشكل فردي، فإن غربال إراتوستينس أسرع لتوليد قائمة من الأعداد الأولية في نطاق.\nبعد سرد جميع الأعداد الأولية حتى \\(n\\)، يجب أن نتحقق من كل عددين أوليين متتاليين \\(p\\) و \\(q\\)، ما إذا كان \\(p + q + 1\\) عدداً أولياً (تذكر من الدرس الأخير كيفية القيام بذلك!).\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Maximum number we want to check (e.g., 1 million)\nconst int MAX_N = 1000000;\nvector&lt;bool&gt; is_prime(MAX_N + 1, true); // Assume all are prime first\nvector&lt;int&gt; primes;\n\nint findPrime(int n) {\n    is_prime[0] = is_prime[1] = false; // Edge cases\n\n    for (int i = 2; i * i &lt;= MAX_N; i++) {\n        // If i is not crossed out yet, it is a prime\n        if (is_prime[i]) {\n            // Cross out all multiples of i\n            // Optimization: Start from i * i (smaller multiples are already handled)\n            for (int j = i * i; j &lt;= MAX_N; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    for (int i = 2; i &lt;= n; ++i){\n        if (is_prime[i]) // We only care about prime numbers\n            primes.push_back(i);\n    }\n\n    int count = 0;\n    for (int i = 1; i &lt; (int)primes.size(); ++i){\n        if (is_prime[primes[i] + primes[i-1] + 1]){ // check whether consecutive primes + 1 is a prime\n            count++;\n        }\n    }\n\n    return count;\n}\n\n\nint main() { \n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    int count = findPrime(n);\n\n    if (count &gt;= k)\n        cout &lt;&lt; \"YES\\n\";\n    else\n        cout &lt;&lt; \"NO\\n\";\n    return 0;\n}",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "غربال إراتوستينس"
    ]
  },
  {
    "objectID": "b3/number-theory/sieve.html#المفهوم",
    "href": "b3/number-theory/sieve.html#المفهوم",
    "title": "غربال إراتوستينس",
    "section": "",
    "text": "بدلاً من فحص الأعداد واحداً تلو الآخر، نقوم بتصفيتها.\nتخيل كتابة جميع الأعداد من 1 إلى 20. 1. نعلم أن 2 أولي. ضع دائرة حوله. الآن اشطب جميع مضاعفات 2 (4، 6، 8، 10…). 2. العدد التالي غير المشطوب هو 3. ضع دائرة حوله. اشطب جميع مضاعفات 3 (6، 9، 12…). 3. العدد التالي غير المشطوب هو 5 (4 مشطوب). ضع دائرة حوله. اشطب المضاعفات…\nبحلول الوقت الذي تصل فيه إلى النهاية، تبقى الأعداد الأولية فقط غير مشطوبة.",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "غربال إراتوستينس"
    ]
  },
  {
    "objectID": "b3/number-theory/sieve.html#الخوارزمية",
    "href": "b3/number-theory/sieve.html#الخوارزمية",
    "title": "غربال إراتوستينس",
    "section": "",
    "text": "نستخدم مصفوفة منطقية isPrime[] حيث isPrime[i] صحيح إذا كان i محتمل أن يكون أولياً. في البداية، نفترض أن كل شيء أولي.\n\n\n\nأنشئ مصفوفة من القيم المنطقية، اجعلها جميعاً true.\nضع علامة على 0 و 1 كـ false (ليسا أوليين).\nابدأ الحلقة من i = 2.\nإذا كان i أولياً (true)، فهذا يعني أنه لا يوجد عدد أصغر قسمه.\nحلقة عبر جميع مضاعفات i (2*i، 3*i…) وضع عليها علامة false.\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Maximum number we want to check (e.g., 1 million)\nconst int MAX_N = 1000000;\nvector&lt;bool&gt; is_prime(MAX_N + 1, true); // Assume all are prime first\n\nvoid sieve() {\n    is_prime[0] = is_prime[1] = false; // Edge cases\n\n    for (int i = 2; i * i &lt;= MAX_N; i++) {\n        // If i is not crossed out yet, it is a prime\n        if (is_prime[i]) {\n            // Cross out all multiples of i\n            // Optimization: Start from i * i (smaller multiples are already handled)\n            for (int j = i * i; j &lt;= MAX_N; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n}\n\n\n\n\nهذا تحسين حاسم. عندما \\(i = 5\\)، لماذا لا نشطب 10 (\\(2 \\times 5\\)) أو 15 (\\(3 \\times 5\\))؟\n\nلأن 10 تم شطبه بالفعل بواسطة 2.\nلأن 15 تم شطبه بالفعل بواسطة 3.\n\nأول مضاعف لـ 5 لم يُلمس بعد هو \\(5 \\times 5 = 25\\).\n\n\n\nهذه الخوارزمية فعالة بشكل مشهور. على الرغم من وجود حلقات متداخلة، فهي بشكل مفاجئ ليست \\(O(N^2)\\). إنها \\(O(N \\log (\\log N))\\). هذا تقريباً خطي. بالنسبة لـ \\(N = 10^7\\) (10 مليون)، تعمل في جزء من الثانية.",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "غربال إراتوستينس"
    ]
  },
  {
    "objectID": "b3/number-theory/sieve.html#noldbach",
    "href": "b3/number-theory/sieve.html#noldbach",
    "title": "غربال إراتوستينس",
    "section": "",
    "text": "Noldbach\n\n\n\n\n\nينص Noldbach على أن على الأقل \\(k\\) عدداً أولياً من \\(2\\) إلى \\(n\\) شاملاً يمكن التعبير عنه كمجموع ثلاثة أعداد صحيحة: عددان أوليان متجاوران و \\(1\\). على سبيل المثال، \\(19 = 7 + 11 + 1\\)، أو \\(13 = 5 + 7 + 1\\).\nيُطلق على عددين أوليين اسم متجاورين إذا لم تكن هناك أعداد أولية أخرى بينهما.\nاكتشف ما إذا كان Noldbach على حق أم على خطأ.",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "غربال إراتوستينس"
    ]
  },
  {
    "objectID": "b3/number-theory/factorization.html",
    "href": "b3/number-theory/factorization.html",
    "title": "التحليل إلى عوامل أولية",
    "section": "",
    "text": "التحليل إلى عوامل أولية هو عملية تفكيك عدد إلى لبناته الأساسية (الأعداد الأولية).\nوفقاً لـ المبرهنة الأساسية في الحساب، كل عدد صحيح \\(&gt;1\\) له مجموعة فريدة من العوامل الأولية.\n\n\\(12 = 2 \\times 2 \\times 3\\) (أو \\(2^2 \\times 3\\))\n\\(100 = 2 \\times 2 \\times 5 \\times 5\\)\n\\(13 = 13\\) (أولي)\n\n\n\nإذا كان لديك عدد كبير (مثل \\(10^{12}\\))، نستخدم المنطق من درس “القواسم”. نكرر من \\(2\\) حتى \\(\\sqrt{N}\\).\nالخوارزمية: 1. ابدأ بـ \\(d=2\\). 2. طالما \\(d\\) يقسم \\(N\\)، استمر في قسمة \\(N\\) على \\(d\\) وسجل \\(d\\). 3. زد \\(d\\). 4. الخطوة الحاسمة: إذا بعد الحلقة \\(N &gt; 1\\)، فإن \\(N\\) المتبقي هو عدد أولي بحد ذاته.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid factorize(long long n) {\n    cout &lt;&lt; \"Factors of \" &lt;&lt; n &lt;&lt; \": \";\n    \n    for (long long i = 2; i * i &lt;= n; i++) {\n        // While i divides n, it is a factor\n        while (n % i == 0) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n            n /= i;\n        }\n    }\n    \n    // EDGE CASE: If n is still &gt; 1, it is a prime factor\n    if (n &gt; 1) {\n        cout &lt;&lt; n;\n    }\n    cout &lt;&lt; endl;\n}\n\n\n\nبحلول الوقت الذي نصل فيه إلى \\(5\\)، نكون قد قسمنا بالفعل جميع عوامل \\(2\\)، لذا لا يمكن أن يكون \\(N\\) قابلاً للقسمة على \\(4\\).\nنقوم بتجريد العدد حتى يبقى العدد الأولي الأخير فقط.\nالتعقيد: \\(O(\\sqrt{N})\\).\n\n\n\n\nإذا كنت بحاجة لتحليل 100,000 عدد (حيث كل عدد صغير، \\(&lt; 10^7\\))، فإن الطريقة 1 بطيئة جداً.\nيمكننا استخدام غربال معدل للتحليل في وقت لوغاريتمي (\\(O(\\log N)\\)).\n\n\nبدلاً من تخزين صحيح/خطأ في غربالنا، نخزن أصغر عامل أولي لكل عدد. - spf[10] = 2 - spf[15] = 3 - spf[7] = 7 (إنه أولي)\nبمجرد حصولنا على هذه المصفوفة، يمكننا “القفز” إلى أسفل العدد فوراً. \\(N \\to N / spf[N] \\to \\dots \\to 1\\)\n\n\n\nconst int MAXN = 1000000;\nint spf[MAXN + 1];\n\nvoid sieve() {\n    // Initialize: smallest prime factor of i is i itself\n    for (int i = 1; i &lt;= MAXN; i++) spf[i] = i;\n\n    for (int i = 2; i * i &lt;= MAXN; i++) {\n        if (spf[i] == i) { // If i is prime\n            for (int j = i * i; j &lt;= MAXN; j += i) {\n                // Mark smallest factor for j if not marked yet\n                if (spf[j] == j) {\n                    spf[j] = i;\n                }\n            }\n        }\n    }\n}\n\n\n\n\n\nvector&lt;int&gt; getFactors(int x) {\n    vector&lt;int&gt; ret;\n    while (x != 1) {\n        ret.push_back(spf[x]);\n        x = x / spf[x]; // Divide by smallest prime and continue\n    }\n    return ret;\n}\n\nالتعقيد: \\(O(\\log N)\\) لكل استعلام.\n\n\n\n\n\n\n\n\n\n\n\n\n\nالسيناريو\nالطريقة\nالتعقيد\n\n\n\n\n\\(N\\) ضخم (\\(10^{12}\\))\nالقسمة التجريبية\n\\(O(\\sqrt{N})\\)\n\n\nاستعلامات كثيرة، \\(N\\) صغير (\\(10^7\\))\nSPF (الغربال)\n\\(O(\\log N)\\)\n\n\nالذاكرة محدودة\nالقسمة التجريبية\n\\(O(1)\\)\n\n\n\n\n\n\n\n\nThe Perfect Square Inventory\n\n\n\n\n\nمدير مستودع تلقى شحنة من \\(n\\) صندوق تخزين مربع متطابق. يريد تكديسها على الأرض لتشكيل ترتيب مربع مثالي (مثلاً، \\(10 \\times 10\\)، \\(20 \\times 20\\)). ومع ذلك، أدرك أن \\(n\\) قد لا يكون عدداً مربعاً كاملاً، لذا لا يمكنه تشكيل مربع مع المخزون الحالي.\nقرر طلب المزيد من الشحنات بنفس الحجم بالضبط (\\(n\\) صندوقاً لكل شحنة) حتى يسمح له العدد الإجمالي للصناديق ببناء مربع مثالي.\nما هو الحد الأدنى لعدد الشحنات (بما في ذلك الأولى) التي يحتاجها في المجموع؟\n\n\n\n\n\nSolution\n\nهذه مسألة تحليل لأننا نسأل: “بأي عدد صحيح \\(k\\) يجب أن نضرب \\(n\\) حتى تكون النتيجة مربعاً كاملاً؟”\nعندما نحلل العدد إلى أعداد أولية، لكي نجعله مربعاً كاملاً، يجب أن يكون كل أس زوجياً. على سبيل المثال \\(15 = 3^1 \\cdot 5^1\\)، يجب أن نضرب في \\(3\\cdot 5\\) لجعل العدد \\(225 = 3^2\\cdot5^2\\). من ناحية أخرى، العدد \\(64 = 2^6\\) هو بالفعل مربع كامل.\nلذا في الأساس، لكل أس فردي يجب أن نضرب العدد بذلك العدد الأولي.\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n// Function to find the smallest multiplier to make 'n' a perfect square\nint findSmallestMultiplier(int n) {\n    int multiplier = 1;\n\n    // Step 1: Check for divisibility by 2\n    int count = 0;\n    while (n % 2 == 0) {\n        count++;\n        n /= 2;\n    }\n    // If the count of 2s is odd, we need one more 2 to make a pair\n    if (count % 2 != 0) {\n        multiplier *= 2;\n    }\n\n    // Step 2: Check for odd factors (3, 5, 7, ...)\n    for (int i = 3; i * i &lt;= n; i += 2) {\n        count = 0;\n        while (n % i == 0) {\n            count++;\n            n /= i;\n        }\n        // If the count of this factor is odd, we need one more to make a pair\n        if (count % 2 != 0) {\n            multiplier *= i;\n        }\n    }\n\n    // Step 3: Handle the remaining prime number (if any)\n    // If n &gt; 2 at this point, the remaining n is a prime factor with a count of 1 (odd)\n    if (n &gt; 2) {\n        multiplier *= n;\n    }\n\n    return multiplier;\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int necessary_shipments = findSmallestMultiplier(n);\n    cout &lt;&lt; necessary_shipments &lt;&lt; \"\\n\";\n\n    return 0;\n}\n\nعلى سبيل المثال، لنفترض \\(n = 540\\). سيعيد الكود 15. دعونا نتحقق مما إذا كان هذا صحيحاً. \\(540\\cdot 15 =8100 = 90^2\\). يمكننا أيضاً التأكد من أن هذا هو أصغر عدد من هذا القبيل عن طريق تجربة الأعداد الأصغر ورؤية أنها لا تعمل.",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "التحليل إلى عوامل أولية"
    ]
  },
  {
    "objectID": "b3/number-theory/factorization.html#الطريقة-1-القسمة-التجريبية-جيدة-لـ-n-كبير",
    "href": "b3/number-theory/factorization.html#الطريقة-1-القسمة-التجريبية-جيدة-لـ-n-كبير",
    "title": "التحليل إلى عوامل أولية",
    "section": "",
    "text": "إذا كان لديك عدد كبير (مثل \\(10^{12}\\))، نستخدم المنطق من درس “القواسم”. نكرر من \\(2\\) حتى \\(\\sqrt{N}\\).\nالخوارزمية: 1. ابدأ بـ \\(d=2\\). 2. طالما \\(d\\) يقسم \\(N\\)، استمر في قسمة \\(N\\) على \\(d\\) وسجل \\(d\\). 3. زد \\(d\\). 4. الخطوة الحاسمة: إذا بعد الحلقة \\(N &gt; 1\\)، فإن \\(N\\) المتبقي هو عدد أولي بحد ذاته.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid factorize(long long n) {\n    cout &lt;&lt; \"Factors of \" &lt;&lt; n &lt;&lt; \": \";\n    \n    for (long long i = 2; i * i &lt;= n; i++) {\n        // While i divides n, it is a factor\n        while (n % i == 0) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n            n /= i;\n        }\n    }\n    \n    // EDGE CASE: If n is still &gt; 1, it is a prime factor\n    if (n &gt; 1) {\n        cout &lt;&lt; n;\n    }\n    cout &lt;&lt; endl;\n}\n\n\n\nبحلول الوقت الذي نصل فيه إلى \\(5\\)، نكون قد قسمنا بالفعل جميع عوامل \\(2\\)، لذا لا يمكن أن يكون \\(N\\) قابلاً للقسمة على \\(4\\).\nنقوم بتجريد العدد حتى يبقى العدد الأولي الأخير فقط.\nالتعقيد: \\(O(\\sqrt{N})\\).",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "التحليل إلى عوامل أولية"
    ]
  },
  {
    "objectID": "b3/number-theory/factorization.html#الطريقة-2-تحسين-spf-جيد-للعديد-من-الاستعلامات",
    "href": "b3/number-theory/factorization.html#الطريقة-2-تحسين-spf-جيد-للعديد-من-الاستعلامات",
    "title": "التحليل إلى عوامل أولية",
    "section": "",
    "text": "إذا كنت بحاجة لتحليل 100,000 عدد (حيث كل عدد صغير، \\(&lt; 10^7\\))، فإن الطريقة 1 بطيئة جداً.\nيمكننا استخدام غربال معدل للتحليل في وقت لوغاريتمي (\\(O(\\log N)\\)).\n\n\nبدلاً من تخزين صحيح/خطأ في غربالنا، نخزن أصغر عامل أولي لكل عدد. - spf[10] = 2 - spf[15] = 3 - spf[7] = 7 (إنه أولي)\nبمجرد حصولنا على هذه المصفوفة، يمكننا “القفز” إلى أسفل العدد فوراً. \\(N \\to N / spf[N] \\to \\dots \\to 1\\)\n\n\n\nconst int MAXN = 1000000;\nint spf[MAXN + 1];\n\nvoid sieve() {\n    // Initialize: smallest prime factor of i is i itself\n    for (int i = 1; i &lt;= MAXN; i++) spf[i] = i;\n\n    for (int i = 2; i * i &lt;= MAXN; i++) {\n        if (spf[i] == i) { // If i is prime\n            for (int j = i * i; j &lt;= MAXN; j += i) {\n                // Mark smallest factor for j if not marked yet\n                if (spf[j] == j) {\n                    spf[j] = i;\n                }\n            }\n        }\n    }\n}\n\n\n\n\n\nvector&lt;int&gt; getFactors(int x) {\n    vector&lt;int&gt; ret;\n    while (x != 1) {\n        ret.push_back(spf[x]);\n        x = x / spf[x]; // Divide by smallest prime and continue\n    }\n    return ret;\n}\n\nالتعقيد: \\(O(\\log N)\\) لكل استعلام.",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "التحليل إلى عوامل أولية"
    ]
  },
  {
    "objectID": "b3/number-theory/factorization.html#أيهما-تستخدم",
    "href": "b3/number-theory/factorization.html#أيهما-تستخدم",
    "title": "التحليل إلى عوامل أولية",
    "section": "",
    "text": "السيناريو\nالطريقة\nالتعقيد\n\n\n\n\n\\(N\\) ضخم (\\(10^{12}\\))\nالقسمة التجريبية\n\\(O(\\sqrt{N})\\)\n\n\nاستعلامات كثيرة، \\(N\\) صغير (\\(10^7\\))\nSPF (الغربال)\n\\(O(\\log N)\\)\n\n\nالذاكرة محدودة\nالقسمة التجريبية\n\\(O(1)\\)",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "التحليل إلى عوامل أولية"
    ]
  },
  {
    "objectID": "b3/number-theory/factorization.html#the-perfect-square-inventory",
    "href": "b3/number-theory/factorization.html#the-perfect-square-inventory",
    "title": "التحليل إلى عوامل أولية",
    "section": "",
    "text": "The Perfect Square Inventory\n\n\n\n\n\nمدير مستودع تلقى شحنة من \\(n\\) صندوق تخزين مربع متطابق. يريد تكديسها على الأرض لتشكيل ترتيب مربع مثالي (مثلاً، \\(10 \\times 10\\)، \\(20 \\times 20\\)). ومع ذلك، أدرك أن \\(n\\) قد لا يكون عدداً مربعاً كاملاً، لذا لا يمكنه تشكيل مربع مع المخزون الحالي.\nقرر طلب المزيد من الشحنات بنفس الحجم بالضبط (\\(n\\) صندوقاً لكل شحنة) حتى يسمح له العدد الإجمالي للصناديق ببناء مربع مثالي.\nما هو الحد الأدنى لعدد الشحنات (بما في ذلك الأولى) التي يحتاجها في المجموع؟",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "التحليل إلى عوامل أولية"
    ]
  },
  {
    "objectID": "b3/graphs/intro.html",
    "href": "b3/graphs/intro.html",
    "title": "الرسوم",
    "section": "",
    "text": "الـ graph هو هيكل رياضي يُستخدم لتمثيل العلاقات بين عناصر منفصلة تُسمّى vertices. العلاقة الواحدة تُسمّى edge، وهي تعبّر عن أن زوجًا من الـ vertices مرتبطان ببعض.\n\n\n\nمثال كلاسيكي على الـ graph هو شبكة مدن مرتبطة بطرق. تخيّل عدة مدن في دولة، بعض أزواج المدن بينهم طرق، والبعض الآخر لا. إذا كنت تخطط للسفر من المدينة \\(A\\) إلى المدينة \\(B\\)، قد تحتاج تمرّ على مدينة أو أكثر كمدن وسيطة في الطريق.\n\n\n\nتمثيل المسائل على شكل graphs يسمح لنا بحلّها بكفاءة باستخدام خوارزميات الرسوم البيانية، مثل:\n\n“هل ممكن نوصل من المدينة \\(A\\) إلى المدينة \\(B\\)؟”\n“وش أقصر مسار من المدينة \\(A\\) إلى المدينة \\(B\\)؟”\n\n\n\n\nفيه أنواع متعددة من graphs، وفيه طرق مختلفة لتخزين كل نوع. بنناقش الأنواع اللي غالبًا تظهر في المسائل، وطرق تخزينها.\n\n\n\n\nأحيانًا الـ edges يكون لها اتجاه، وهذا يعني أن edge \\((U, V)\\) و edge \\((V, U)\\) مختلفين. غالبًا يُذكر هذا في نص المسألة بمصطلحات مثل unidirectional أو directed، بينما مصطلحات مثل bidirectional و undirected تعني أن الـ edges ما لها اتجاه معيّن.\n\n\n\nفي بعض الـ graphs، الـ edges (وأحيانًا الـ vertices) يكون مرتبط فيها قيمة أو أكثر. مثال على ذلك إننا نعطي مدة زمنية للطرق في مثال المدن والطرق. ممكن نقول إن edge \\((U, V, W)\\) يعني أن السفر على الطريق بين المدينتين \\(U\\) و \\(V\\) يحتاج وقت مقداره \\(W\\).\n\n\n\n\n\n\nNote\n\n\n\nلاحظ أن في الصياغة \\((U, V, W)\\) ما تم ذكر اتجاه محدد للـ edge، لذلك نقدر نفترض أنها undirected.\n\n\n\n\n\n\nقبل ما نتكلم عن طرق التخزين، بنناقش بعض الاستعلامات (queries) اللي ممكن نسويها، واللي بتساعدنا نقارن بين طرق التخزين المختلفة ونفهم نقاط القوة والضعف لكل وحدة.\n\nكم التعقيد المكاني (space complexity) لهذه الطريقة؟\nكم التعقيد الزمني (time complexity) للتحقق إذا كانت الـ edge \\((U, V)\\) موجودة؟\nإذا كان عندنا vertex معيّن \\(U\\)، كم التعقيد الزمني للمرور على كل الـ vertices \\(V\\) المجاورة له؟\n\nلازم أيضًا نفهم كيف يُعطى لنا الـ graph في مدخلات المسألة. الطريقة الأكثر شيوعًا هي أننا نقرأ أولًا \\(N\\) و \\(M\\)، حيث يمثلان عدد الـ vertices وعدد الـ edges على الترتيب، ثم في كل واحد من الأسطر الـ \\(M\\) التالية يُعطى زوج أعداد صحيحة \\(U\\) \\(V\\) (وأحيانًا وزن \\(W\\)). هذا يعني أن فيه edge بين الـ vertices \\(U\\) و \\(V\\) (وإذا كان الـ graph موجه فعادة يكون من \\(U\\) إلى \\(V\\) إلا إذا ذُكر غير ذلك).\n\n\n\n\n\n\nTip\n\n\n\nنوصي أنك تطلع على الموقع التالي: Graph Editor\n\n\nوأخيرًا، من أفضل الممارسات إننا نخلي كل الحاويات (containers) المتعلقة بالـ graph معرفة بشكل global. السبب أن أغلب خوارزميات الرسوم البيانية يُفضّل تنفيذها باستخدام دوال (functions)، ويكون الوصول للـ graph أسهل إذا كان global. لذلك مهم جدًا تعرف القيود (constraints) على متغيرات مثل \\(N\\) و \\(M\\) عشان تضبط أحجام الحاويات بشكل صحيح وتتجنب الوصول خارج الحدود (out of bounds).\n\n\n\n\n\n\nCaution\n\n\n\nهنا نفترض أن الـ graph ما يحتوي على multiple edges، يعني ما فيه زوج vertices مرتبطين مباشرة بأكثر من edge واحدة.\n\n\n\n\nهذه أبسط طريقة لتخزين الـ edges. بما أن الـ edges تُعطى على شكل قائمة أزواج، بنخزنها مباشرة في array من أزواج.\n\n\nconst int maxN = 100'000;\nconst int maxM = 200'000;\n\npair&lt;int,int&gt; E[maxM];\n\nint main () {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v; cin &gt;&gt; u &gt;&gt; v;\n        E[i] = {u, v};\n    }\n}\n\n\n\n\n\n\n\nNote\n\n\n\nفي حالة الـ weighted graphs نقدر نعرّف struct يحتوي القيم الثلاث \\(3\\) أو نستخدم std::tuple أو std::array. عمومًا يُفضّل نتجنب nesting للـ pairs.\n\n\n\n\n\n\n\n\n\nCategory\nComplexity\n\n\n\n\nSpace\n\\(O(M)\\)\n\n\nChecking if an edge exists\n\\(O(M)\\)\n\n\nLooping over neighbors of a vertex\n\\(O(M)\\)\n\n\n\n\n\n\nفي هذه الطريقة ننشئ \\(N\\) قوائم، كل وحدة عبارة عن vector، بحيث أن القائمة رقم \\(i_{th}\\) تخزن كل الجيران (neighbors) للـ vertex رقم \\(i\\).\n\n\nconst int maxN = 100'000;\nconst int maxM = 200'000;\n\nvector&lt;int&gt; adjacency_list[maxN + 1]; // زدنا واحد لأن غالبًا الـ vertices تبدأ من 1 (1-indexed)\n\nint main () {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v; cin &gt;&gt; u &gt;&gt; v;\n        adjacency_list[u].push_back(v); // أضف v إلى جيران u\n        adjacency_list[v].push_back(u); // إذا كان undirected، نضيف u إلى قائمة v كذلك\n    }\n}\n\n\n\n\n\n\n\nNote\n\n\n\nفي حالة الـ weighted graphs نقدر نستخدم vector&lt;pair&lt;int,int&gt;&gt; بحيث \\((V, W)\\) تعني أن \\(V\\) جار والـ edge له وزن \\(W\\).\n\n\n\n\n\n\n\n\n\nCategory\nComplexity\n\n\n\n\nSpace\n\\(O(M)\\)\n\n\nChecking if an edge exists\n\\(O(K)\\) حيث \\(K\\) هو عدد الجيران\n\n\nLooping over neighbors of a vertex\n\\(O(K)\\) حيث \\(K\\) هو عدد الجيران\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nمع أن المرور على الجيران يبدو بطيء، إلا أنه فعليًا يساوي \\(O(M)\\) إذا جمعنا على كل الـ vertices.\n\n\n\n\n\n\n\n\nWarningChallenge\n\n\n\nهل تقدر تعدّل هذا الـ container بحيث تسرّع عملية “checking if an edge exists” بدون ما تأثر على باقي الاستعلامات؟\n\n\n\n\n\nهذه الطريقة تنشئ مصفوفة بحجم \\(N \\times N\\) من القيم المنطقية (booleans) اسمها \\(G\\)، بحيث أن \\(G_{i,j}\\) تساوي true إذا كان الـ vertex رقم \\(i\\) متصل مباشرة بالـ vertex رقم j، و false في غير ذلك.\n\nconst int maxN = 1'000;\nconst int maxM = 200'000;\n\nbool G[maxN + 1][maxN + 1] // زدنا واحد لأن غالبًا الـ vertices تبدأ من 1 (1-indexed)\n\nint main () {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v; cin &gt;&gt; u &gt;&gt; v;\n        G[u][v] = true;\n        G[v][u] = true; // إذا كان الـ graph غير موجه لازم نكتب هذا السطر كذلك\n    }\n}\n\n\n\n\n\n\n\nNote\n\n\n\nفي حالة الـ weighted graphs، بدل ما تكون قيم منطقية، ممكن \\(G_{i, j}\\) تكون عدد صحيح يمثل وزن الـ edge من \\(i\\) إلى \\(j\\)، لكن انتبه لكيف تميّز بين الـ edges غير الموجودة.\n\n\n\n\n\n\n\n\n\nCategory\nComplexity\n\n\n\n\nSpace\n\\(O(N^2)\\)\n\n\nChecking if an edge exists\n\\(O(1)\\)\n\n\nLooping over neighbors of a vertex\n\\(O(N)\\)",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "الرسوم"
    ]
  },
  {
    "objectID": "b3/graphs/intro.html#التعريف",
    "href": "b3/graphs/intro.html#التعريف",
    "title": "الرسوم",
    "section": "",
    "text": "الـ graph هو هيكل رياضي يُستخدم لتمثيل العلاقات بين عناصر منفصلة تُسمّى vertices. العلاقة الواحدة تُسمّى edge، وهي تعبّر عن أن زوجًا من الـ vertices مرتبطان ببعض.",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "الرسوم"
    ]
  },
  {
    "objectID": "b3/graphs/intro.html#مثال-المدن-والطرق",
    "href": "b3/graphs/intro.html#مثال-المدن-والطرق",
    "title": "الرسوم",
    "section": "",
    "text": "مثال كلاسيكي على الـ graph هو شبكة مدن مرتبطة بطرق. تخيّل عدة مدن في دولة، بعض أزواج المدن بينهم طرق، والبعض الآخر لا. إذا كنت تخطط للسفر من المدينة \\(A\\) إلى المدينة \\(B\\)، قد تحتاج تمرّ على مدينة أو أكثر كمدن وسيطة في الطريق.",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "الرسوم"
    ]
  },
  {
    "objectID": "b3/graphs/intro.html#ليش-نستخدم-graphs",
    "href": "b3/graphs/intro.html#ليش-نستخدم-graphs",
    "title": "الرسوم",
    "section": "",
    "text": "تمثيل المسائل على شكل graphs يسمح لنا بحلّها بكفاءة باستخدام خوارزميات الرسوم البيانية، مثل:\n\n“هل ممكن نوصل من المدينة \\(A\\) إلى المدينة \\(B\\)؟”\n“وش أقصر مسار من المدينة \\(A\\) إلى المدينة \\(B\\)؟”",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "الرسوم"
    ]
  },
  {
    "objectID": "b3/graphs/intro.html#تخزين-أنواع-مختلفة-من-graphs",
    "href": "b3/graphs/intro.html#تخزين-أنواع-مختلفة-من-graphs",
    "title": "الرسوم",
    "section": "",
    "text": "فيه أنواع متعددة من graphs، وفيه طرق مختلفة لتخزين كل نوع. بنناقش الأنواع اللي غالبًا تظهر في المسائل، وطرق تخزينها.\n\n\n\n\nأحيانًا الـ edges يكون لها اتجاه، وهذا يعني أن edge \\((U, V)\\) و edge \\((V, U)\\) مختلفين. غالبًا يُذكر هذا في نص المسألة بمصطلحات مثل unidirectional أو directed، بينما مصطلحات مثل bidirectional و undirected تعني أن الـ edges ما لها اتجاه معيّن.\n\n\n\nفي بعض الـ graphs، الـ edges (وأحيانًا الـ vertices) يكون مرتبط فيها قيمة أو أكثر. مثال على ذلك إننا نعطي مدة زمنية للطرق في مثال المدن والطرق. ممكن نقول إن edge \\((U, V, W)\\) يعني أن السفر على الطريق بين المدينتين \\(U\\) و \\(V\\) يحتاج وقت مقداره \\(W\\).\n\n\n\n\n\n\nNote\n\n\n\nلاحظ أن في الصياغة \\((U, V, W)\\) ما تم ذكر اتجاه محدد للـ edge، لذلك نقدر نفترض أنها undirected.\n\n\n\n\n\n\nقبل ما نتكلم عن طرق التخزين، بنناقش بعض الاستعلامات (queries) اللي ممكن نسويها، واللي بتساعدنا نقارن بين طرق التخزين المختلفة ونفهم نقاط القوة والضعف لكل وحدة.\n\nكم التعقيد المكاني (space complexity) لهذه الطريقة؟\nكم التعقيد الزمني (time complexity) للتحقق إذا كانت الـ edge \\((U, V)\\) موجودة؟\nإذا كان عندنا vertex معيّن \\(U\\)، كم التعقيد الزمني للمرور على كل الـ vertices \\(V\\) المجاورة له؟\n\nلازم أيضًا نفهم كيف يُعطى لنا الـ graph في مدخلات المسألة. الطريقة الأكثر شيوعًا هي أننا نقرأ أولًا \\(N\\) و \\(M\\)، حيث يمثلان عدد الـ vertices وعدد الـ edges على الترتيب، ثم في كل واحد من الأسطر الـ \\(M\\) التالية يُعطى زوج أعداد صحيحة \\(U\\) \\(V\\) (وأحيانًا وزن \\(W\\)). هذا يعني أن فيه edge بين الـ vertices \\(U\\) و \\(V\\) (وإذا كان الـ graph موجه فعادة يكون من \\(U\\) إلى \\(V\\) إلا إذا ذُكر غير ذلك).\n\n\n\n\n\n\nTip\n\n\n\nنوصي أنك تطلع على الموقع التالي: Graph Editor\n\n\nوأخيرًا، من أفضل الممارسات إننا نخلي كل الحاويات (containers) المتعلقة بالـ graph معرفة بشكل global. السبب أن أغلب خوارزميات الرسوم البيانية يُفضّل تنفيذها باستخدام دوال (functions)، ويكون الوصول للـ graph أسهل إذا كان global. لذلك مهم جدًا تعرف القيود (constraints) على متغيرات مثل \\(N\\) و \\(M\\) عشان تضبط أحجام الحاويات بشكل صحيح وتتجنب الوصول خارج الحدود (out of bounds).\n\n\n\n\n\n\nCaution\n\n\n\nهنا نفترض أن الـ graph ما يحتوي على multiple edges، يعني ما فيه زوج vertices مرتبطين مباشرة بأكثر من edge واحدة.\n\n\n\n\nهذه أبسط طريقة لتخزين الـ edges. بما أن الـ edges تُعطى على شكل قائمة أزواج، بنخزنها مباشرة في array من أزواج.\n\n\nconst int maxN = 100'000;\nconst int maxM = 200'000;\n\npair&lt;int,int&gt; E[maxM];\n\nint main () {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v; cin &gt;&gt; u &gt;&gt; v;\n        E[i] = {u, v};\n    }\n}\n\n\n\n\n\n\n\nNote\n\n\n\nفي حالة الـ weighted graphs نقدر نعرّف struct يحتوي القيم الثلاث \\(3\\) أو نستخدم std::tuple أو std::array. عمومًا يُفضّل نتجنب nesting للـ pairs.\n\n\n\n\n\n\n\n\n\nCategory\nComplexity\n\n\n\n\nSpace\n\\(O(M)\\)\n\n\nChecking if an edge exists\n\\(O(M)\\)\n\n\nLooping over neighbors of a vertex\n\\(O(M)\\)\n\n\n\n\n\n\nفي هذه الطريقة ننشئ \\(N\\) قوائم، كل وحدة عبارة عن vector، بحيث أن القائمة رقم \\(i_{th}\\) تخزن كل الجيران (neighbors) للـ vertex رقم \\(i\\).\n\n\nconst int maxN = 100'000;\nconst int maxM = 200'000;\n\nvector&lt;int&gt; adjacency_list[maxN + 1]; // زدنا واحد لأن غالبًا الـ vertices تبدأ من 1 (1-indexed)\n\nint main () {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v; cin &gt;&gt; u &gt;&gt; v;\n        adjacency_list[u].push_back(v); // أضف v إلى جيران u\n        adjacency_list[v].push_back(u); // إذا كان undirected، نضيف u إلى قائمة v كذلك\n    }\n}\n\n\n\n\n\n\n\nNote\n\n\n\nفي حالة الـ weighted graphs نقدر نستخدم vector&lt;pair&lt;int,int&gt;&gt; بحيث \\((V, W)\\) تعني أن \\(V\\) جار والـ edge له وزن \\(W\\).\n\n\n\n\n\n\n\n\n\nCategory\nComplexity\n\n\n\n\nSpace\n\\(O(M)\\)\n\n\nChecking if an edge exists\n\\(O(K)\\) حيث \\(K\\) هو عدد الجيران\n\n\nLooping over neighbors of a vertex\n\\(O(K)\\) حيث \\(K\\) هو عدد الجيران\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nمع أن المرور على الجيران يبدو بطيء، إلا أنه فعليًا يساوي \\(O(M)\\) إذا جمعنا على كل الـ vertices.\n\n\n\n\n\n\n\n\nWarningChallenge\n\n\n\nهل تقدر تعدّل هذا الـ container بحيث تسرّع عملية “checking if an edge exists” بدون ما تأثر على باقي الاستعلامات؟\n\n\n\n\n\nهذه الطريقة تنشئ مصفوفة بحجم \\(N \\times N\\) من القيم المنطقية (booleans) اسمها \\(G\\)، بحيث أن \\(G_{i,j}\\) تساوي true إذا كان الـ vertex رقم \\(i\\) متصل مباشرة بالـ vertex رقم j، و false في غير ذلك.\n\nconst int maxN = 1'000;\nconst int maxM = 200'000;\n\nbool G[maxN + 1][maxN + 1] // زدنا واحد لأن غالبًا الـ vertices تبدأ من 1 (1-indexed)\n\nint main () {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v; cin &gt;&gt; u &gt;&gt; v;\n        G[u][v] = true;\n        G[v][u] = true; // إذا كان الـ graph غير موجه لازم نكتب هذا السطر كذلك\n    }\n}\n\n\n\n\n\n\n\nNote\n\n\n\nفي حالة الـ weighted graphs، بدل ما تكون قيم منطقية، ممكن \\(G_{i, j}\\) تكون عدد صحيح يمثل وزن الـ edge من \\(i\\) إلى \\(j\\)، لكن انتبه لكيف تميّز بين الـ edges غير الموجودة.\n\n\n\n\n\n\n\n\n\nCategory\nComplexity\n\n\n\n\nSpace\n\\(O(N^2)\\)\n\n\nChecking if an edge exists\n\\(O(1)\\)\n\n\nLooping over neighbors of a vertex\n\\(O(N)\\)",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "الرسوم"
    ]
  },
  {
    "objectID": "b3/graphs/components.html",
    "href": "b3/graphs/components.html",
    "title": "المكونات المتصلة",
    "section": "",
    "text": "في الرسم البياني غير الموجه، يُقال أن الرأسين \\(u\\) و \\(v\\) ينتميان إلى نفس المكون المتصل إذا كان هناك مسار يربط بينهما. إذا كان الرسم البياني يتكون من مكون واحد فقط، فإنه يُعتبر متصلاً.\n\n\n\n\nBuilding Roads\n\nCSES\neasy\n\n\n\nيوجد \\(n\\) مدينة، و \\(m\\) طريقاً بينها. مهمتك هي إيجاد الحد الأدنى من عدد الطرق التي يجب إضافتها بحيث يكون هناك مسار بين أي مدينتين، وأيضاً تحديد أي الطرق يجب بناؤها.\n\n\n\n\n\nSolution\n\nالهدف هنا هو إضافة أحرف حتى يصبح الرسم البياني متصلاً. إذا أضفنا حرفاً يربط رؤوس نفس المكون، فإن المكونات الأخرى لن تتأثر، وإذا أضفنا حرفاً بين رؤوس مكونات مختلفة فإنها ستندمج.\nإذا كان هناك \\(C\\) مكوناً فإننا بحاجة لإضافة \\(C - 1\\) حرفاً. هناك طرق عديدة لاختيار هذه الأحرف، طريقة بسيطة هي اختيار رأس عشوائي من المكون الأول وربطه برأس عشوائي من كل مكون من المكونات المتبقية.\n\n\nconst int maxN = 200'001;\n\nbool vis[maxN];\nvector&lt;int&gt; adj[maxN];\n\nvoid dfs (int u) {\n    vis[u] = true;\n\n    for (int v : adj[u]) {\n        if (!vis[v]) dfs(v);\n    }\n}\n\nint main () { \n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector&lt;int&gt; sources;\n\n    for (int i = 1 ; i &lt;= n ; i++) if (!vis[i]) {\n        sources.push_back(i);\n        dfs(i);\n    }\n\n    cout &lt;&lt; sources.size() - 1 &lt;&lt; endl;\n\n    for (int i = 1 ; i &lt; sources.size() ; i++) {\n        cout &lt;&lt; sources[0] &lt;&lt; ' ' &lt;&lt; sources[i] &lt;&lt; endl;\n    }\n}\n\n\n\n\n\n\n\n\n\nCyclic Components\n\nCodeforces\neasy\n\n\n\nمعطى رسم بياني غير موجه، احسب عدد المكونات التي هي دورات. مكون من \\(k\\) رأساً \\(v_1, v_2, ..., v_k\\) يُعتبر دورة إذا كان له بالضبط \\(k\\) حرفاً: \\((v_1, v_2), (v_2, v_3), ..., (v_k, v_1)\\).\n\n\n\n\n\n\nNote\n\n\n\nإذا كان هناك أي ترتيب للرؤوس يحقق الشرط أعلاه فإنها دورة.\n\n\n\n\n\n\n\nSolution\n\nإذا كان المكون دورة فإن جميع رؤوسه مجاورة لبالضبط \\(2\\) رأساً آخرين. في الواقع، هذا شرط كافٍ لتحديد ما إذا كان المكون دورة.\nيمكن استخدام DFS لاستكشاف جميع رؤوس المكون للتحقق من هذا الشرط.\n\n\nconst int maxN = 200'001;\n\nvector&lt;int&gt; adj[maxN];\nbool vis[maxN];\n \nbool dfs (int u) {\n    vis[u] = 1;\n    bool ret = (adj[u].size() == 2);\n \n    for (int v : adj[u]) {\n        if (!vis[v]) ret &= dfs(v);\n    }\n \n    return ret;\n}\n \nint main () { \n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n \n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n \n    int ans = 0;\n \n    for (int i = 1 ; i &lt;= n ; i++) {\n        if (!vis[i]) ans += dfs(i);\n    }\n    \n    cout &lt;&lt; ans &lt;&lt; endl;\n}",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "المكونات المتصلة"
    ]
  },
  {
    "objectID": "b3/graphs/components.html#building-roads",
    "href": "b3/graphs/components.html#building-roads",
    "title": "المكونات المتصلة",
    "section": "",
    "text": "Building Roads\n\nCSES\neasy\n\n\n\nيوجد \\(n\\) مدينة، و \\(m\\) طريقاً بينها. مهمتك هي إيجاد الحد الأدنى من عدد الطرق التي يجب إضافتها بحيث يكون هناك مسار بين أي مدينتين، وأيضاً تحديد أي الطرق يجب بناؤها.",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "المكونات المتصلة"
    ]
  },
  {
    "objectID": "b3/graphs/components.html#cyclic-components",
    "href": "b3/graphs/components.html#cyclic-components",
    "title": "المكونات المتصلة",
    "section": "",
    "text": "Cyclic Components\n\nCodeforces\neasy\n\n\n\nمعطى رسم بياني غير موجه، احسب عدد المكونات التي هي دورات. مكون من \\(k\\) رأساً \\(v_1, v_2, ..., v_k\\) يُعتبر دورة إذا كان له بالضبط \\(k\\) حرفاً: \\((v_1, v_2), (v_2, v_3), ..., (v_k, v_1)\\).\n\n\n\n\n\n\nNote\n\n\n\nإذا كان هناك أي ترتيب للرؤوس يحقق الشرط أعلاه فإنها دورة.",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "المكونات المتصلة"
    ]
  },
  {
    "objectID": "b3/ds/ordered-sets.html",
    "href": "b3/ds/ordered-sets.html",
    "title": "ordered_set",
    "section": "",
    "text": "ordered_set هي set ولكن مع وظيفتين إضافيتين:\n\nfind_by_order(k): تقوم بإرجاع مؤشراً إلى العنصر بترتيب k من الأصغر إلى الأكبر (بترقيم يبدأ من 0) بزمن قدره \\(O(\\log n)\\).\n\norder_of_key(x): تقوم بإرجاع عدد العناصر الأصغر من x بزمن قدره \\(O(\\log n)\\).\n\n\n\nلكي نتمكن من إنشاء ordered set يجب أن نكتب ما يلي في النطاق العام:\n\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\n\ntemplate&lt;typename T&gt;\nusing ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; ordered_set;\n\nالآن أصبحنا جاهزين لاستخدامها. لإنشاء ordered set نكتب ببساطة ordered_set&lt;T&gt;، حيث T هو النوع المطلوب (مثلًا int، long long، string، إلخ).\n\n\n\n\n\nSliding Window Median\n\nCSES\neasy\n\n\n\nلديك مصفوفة \\(x\\) تحتوي على \\(n\\) عنصرًا وقيمة \\(k\\). اطبع الوسيط لكل المصفوفات الجزئية بطول \\(k\\).\nالوسيط هو العنصر الأوسط بعد ترتيب العناصر. إذا كان عدد العناصر زوجيًا، فهناك وسيطان محتملان ونفترض أن الوسيط هو القيمة الصغرى بينهما.\n\n\n\n\n\nSolution\n\nيمكننا حل هذه المسألة باستخدام ordered_set من خلال تطبيق نافذة منزلقة على جميع المصفوفات الجزئية بطول \\(k\\). لكل نافذة، نجد العنصر بترتيب \\(\\frac{k}{2}\\) من الأصغر إلى الأكبر باستخدام find_by_order(k/2)\n(لاحظ أنه إذا كان \\(k\\) زوجيًا فإننا نأخذ بدلًا من ذلك k/2 - 1).\nمثل set، فإن ordered_set لا تسمح بالتكرارات. لحل ذلك، نمثل المصفوفة الأصلية كأزواج، حيث يكون العنصر الأول هو القيمة\nوالعنصر الثاني هو موقعها، مما يضمن أن جميع العناصر مختلفة.\nنظرًا لأننا نجري عملية إدخال واحدة وحذف واحدة مع كل تحريك للنافذة،\nفإن التعقيد الزمني الكلي هو \\(O(n \\log n)\\).\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\n\ntemplate&lt;typename T&gt;\nusing ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;;\n\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    pair&lt;int, int&gt; a[n];\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; a[i].first;\n        a[i].second  = i;\n    }\n\n    ordered_set&lt;pair&lt;int ,int&gt; &gt; os;\n\n    // أدخل النافذة الأولى\n    for (int i = 0 ; i &lt; k; i++){\n        os.insert(a[i]);\n    }\n\n    // أوجد الوسيط للنافذة الأولى\n    int median;\n    if (k % 2 == 0){\n        median = k/2 - 1;\n    }\n    else{\n        median = k/2;\n    }\n\n    pair&lt;int ,int&gt; ans = *os.find_by_order(median);\n    cout &lt;&lt; ans.first &lt;&lt; ' ';\n\n    //تحرك عبر جميع النوافذ\n    for( int i = 0 ; i &lt; n - k ; i++){\n        //اذهب للنافذة التالية\n        // احذف القيمة الاولى في الهافذة\n        os.erase(a[i]);\n\n        // اضف القيمة التي بعد آخر قيمة في النافذة\n        os.insert(a[i + k]);\n\n        // اطبع الحل للنافذة الحالية\n        pair&lt;int , int&gt; ans = *os.find_by_order(median);\n        cout &lt;&lt; ans.first &lt;&lt; ' ';\n    }\n\n}",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "<span dir =\"ltr\">`ordered_set`</span>"
    ]
  },
  {
    "objectID": "b3/ds/ordered-sets.html#implementation",
    "href": "b3/ds/ordered-sets.html#implementation",
    "title": "ordered_set",
    "section": "",
    "text": "لكي نتمكن من إنشاء ordered set يجب أن نكتب ما يلي في النطاق العام:\n\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;\n#include &lt;ext/pb_ds/tree_policy.hpp&gt;\nusing namespace __gnu_pbds;\n\ntemplate&lt;typename T&gt;\nusing ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; ordered_set;\n\nالآن أصبحنا جاهزين لاستخدامها. لإنشاء ordered set نكتب ببساطة ordered_set&lt;T&gt;، حيث T هو النوع المطلوب (مثلًا int، long long، string، إلخ).",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "<span dir =\"ltr\">`ordered_set`</span>"
    ]
  },
  {
    "objectID": "b3/ds/ordered-sets.html#sliding-window-median",
    "href": "b3/ds/ordered-sets.html#sliding-window-median",
    "title": "ordered_set",
    "section": "",
    "text": "Sliding Window Median\n\nCSES\neasy\n\n\n\nلديك مصفوفة \\(x\\) تحتوي على \\(n\\) عنصرًا وقيمة \\(k\\). اطبع الوسيط لكل المصفوفات الجزئية بطول \\(k\\).\nالوسيط هو العنصر الأوسط بعد ترتيب العناصر. إذا كان عدد العناصر زوجيًا، فهناك وسيطان محتملان ونفترض أن الوسيط هو القيمة الصغرى بينهما.",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "<span dir =\"ltr\">`ordered_set`</span>"
    ]
  },
  {
    "objectID": "b3/ds/segment-trees.html",
    "href": "b3/ds/segment-trees.html",
    "title": "Segment Trees",
    "section": "",
    "text": "Segment tree هي هيكل بيانات تسمح بمعالجة استعلامات النطاق والتحديثات على المصفوفات بكفاءة.\nفي هذا القسم يُفترض أن كل شيء مرقم ابتداءً من 1 ما لم يُذكر خلاف ذلك.\n\n\nهي شجرة ثنائية حيث يمثل كل node قيمة استعلام على مقطع (مصفوفة جزئية) من المصفوفة الأصلية. يتم بناء الشجرة وفق القواعد التالية:\n\nكل leaf node يمثل مقطعًا بطول \\(1\\).\n\nكل internal node يمثل دمجًا ((sum, min, max, etc.)) لطفليه.\n\nلنفترض أن لدينا المصفوفة [2, 4, 6, 8]. فإن Segment Tree تحسب جمع لنطاقات مبنية على هذه المصفوفة تكون كما يلي:\n\n\n\n\n\n\ngraph TD\n    A[\"20 (1-4)\"]\n    B[\"6 (1-2)\"]\n    C[\"14 (3-4)\"]\n    D[\"2 (1-1)\"]\n    E[\"4 (2-2)\"]\n    F[\"6 (3-3)\"]\n    G[\"8 (4-4)\"]\n\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    B --&gt; E\n    C --&gt; F\n    C --&gt; G\n\n\n\n\n\n\n\nلاحظ أن جميع ال leaf nodes يمثلون عنصرًا واحدًا فقط، بينما تقوم internal nodes بدمج طفليها بأخذ مجموع قيمتيهما.\n\n\n\nليكن N عدد الـleaf nodes في segment tree، وn طول المصفوفة الأصلية.\n\n\n\nفي segment tree، يشكل عدد nodes في كل مستوى المتتالية [1, 2, 4, …]، أي قوى العدد اثنين.\n\nكل قوة للعدد 2 تساوي مجموع جميع القوى السابقة للعدد 2 زائد 1.\n\nلذلك، فإن العدد الكلي لـ nodes في segment tree هو 2N - 1.\n\n\n\n\n\nإذا كانت المصفوفة الأصلية تحتوي على n عنصرًا وn ليس قوة للعدد اثنين، نقوم بحشو المصفوفة بعناصر إضافية بحيث يصبح عدد leaf nodes N هو القوة التالية للعدد اثنين، مع ضمان أن العناصر الإضافية لا تؤثر على قيم الـnodes الأخرى.\n\nفي أسوأ الحالات، قد نحتاج إلى إضافة ما يصل إلى n عنصرًا، لأن القوة التالية للعدد اثنين أصغر من 2n.\n\n\n\nإذا غيرنا المثال السابق إلى [2, 4, 6]، فنحتاج إلى إضافة عنصر لجعل الطول قوة للعدد اثنين دون التأثير على القيم الأخرى. أفضل قيمة لإضافتها هي 0. ستكون segment tree الناتجة كما يلي:\n\n\n\n\n\n\ngraph TD\n    A[\"12 (1-4)\"]\n    B[\"6 (1-2)\"]\n    C[\"6 (3-4)\"]\n    D[\"2 (1-1)\"]\n    E[\"4 (2-2)\"]\n    F[\"6 (3-3)\"]\n    G[\"0 (4-4) مضافة\"]\n\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    B --&gt; E\n    C --&gt; F\n    C --&gt; G\n\n\n\n\n\n\n\n\n\n\n\n\nسنمثل الـsegment tree كمصفوفة تعطي موقع(أرقام) لكل node. وبالتالي سيتم إعطاء المواقع للـ segment tree السابقة كما يلي:\n\n\n\n\n\n\ngraph TD\n    A[\"1: sum = 12 (1-4)\"]\n    B[\"2: sum = 6 (1-2)\"]\n    C[\"3: sum = 6 (3-4)\"]\n    D[\"4: sum = 2 (1-1)\"]\n    E[\"5: sum = 4 (2-2)\"]\n    F[\"6: sum = 6 (3-3)\"]\n    G[\"7: sum = 0 (4-4) مضاف\"]\n\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    B --&gt; E\n    C --&gt; F\n    C --&gt; G\n\n\n\n\n\n\n\nكل node i لها طفلان في الموضعين 2 * i و2 * i + 1، ووالدها في الموضع i / 2.\nفي هذا المثال، عدد leaf nodes N هو 4، وهو أيضًا موقع أول leaf node. لذلك فإن الـleaf node في الموضع i تقابل الموقع i - N + 1 في المصفوفة الأصلية.\n\n\n\nلنعرّف الدالة query(id, l, r, ql, qr) التي تقوم بحساب ناتج استعلام من ql إلى qr، حيث:\n\nid هو موقع الـnode الحالي.\n\nl هو بداية النطاق الذي يغطيه الـnode الحالي.\n\nr هو نهاية النطاق الذي يغطيه الـnode الحالي.\n\nql هو بداية نطاق الاستعلام.\n\nqr هو نهاية نطاق الاستعلام.\n\nتعمل الدالة كما يلي:\n\nإذا كان المجالان [ql, qr] و[l, r] غير متقاطعين تمامًا، يتم تجاهل الـnode الحالي لأنه لا يسهم في الاستعلام.\n\nإذا كان المجال [ql, qr] يغطي بالكامل المجال [l, r]، نقوم بإرجاع القيمة المخزنة في الـnode الحالي.\n\nخلاف ذلك، نقسم المجال عند المنتصف m = (l + r) / 2 ونحصل على حساب الاستدعاء على الأطفال:\n\nquery(2 * id, l, m, ql, qr)\n\nquery(2 * id + 1, m + 1, r, ql, qr)\nثم ندمج النتائج للحصول على إجابة الـnode الحالي.\n\n\nلحل استعلام [ql, qr] نستدعي query(1, 1, N, ql, qr).\nتعقيد الزمن لهذه الخوارزمية هو \\(O(\\log n)\\).\n\n\n\nبعض المسائل تطلب تحديث الموقع j إلى القيمة v. لتنفيذ ذلك نقوم بتحديث الـleaf node في الموضع j + N - 1 ثم نعيد حساب جميع قيم الـinternal node.\nعدد الآباء لكل leaf node j + N - 1 هو logn. لذلك فإن تعقيد تحديث النقطة هو \\(O(\\log n)\\).\n\n\n\nعند بناء segment tree لدينا فقط المصفوفة الأصلية a (مرقمة ابتداء من ال0) وحجمها n.\n\n\nأولًا نحتاج إلى حساب عدد الـleaf nodes N. يمكن حسابه بطريقتين:\nإما باستخدام معادلة:\n\nint N = 1 &lt;&lt; (32 - __builtin_clz(n - 1));\n\nأو باستخدام حلقة:\n\nint N;\nfor (N = 1; N &lt; n; N *= 2); // ال; مهمة جدا\n\nحجم الشجرة سيكون 2*N.\n\nint seg[2*N]\n\n\n\n\n\n\nلبناء الشجرة نضع أولًا قيم الـleaf nodes.\n\nfor (int i = 0 ; i &lt; n; i++) {\n    seg[i + N] = a[i];\n}\n\nثم نقوم بحشو العناصر الجديدة لإكمال الـleaf nodes.\n\nfor (int i = n + N; i &lt; 2*N; i++){\n    seg[i] = 0; // segment treeالقيم المضافة تعتمد على نوع ال\n}\n\n\n\n\n\nلبناء الـinternal nodes نمر عليها بترتيب عكسي ونقوم بدمج طفلي كل internal node.\n\nfor (int i = N - 1; i &gt; 0 ; i--) {\n    seg[i] = seg[i * 2] + seg[i * 2 + 1]; // دمج قيم الطفلين\n}\n\n\n\n\n\nint query(int id, int l, int r, int ql, int qr) {\n    // تأكد إذا لا يتقاطعان\n    if (ql &gt; r || l &gt; qr) {\n        return 0; \n    }\n    // بالكامل [l, r] يشمل [ql, qr] تأكد إذا\n    if (ql &lt;= l && r &lt;= qr) {\n        return seg[id];\n    }\n    // قم بالاستدعاء الذاتي والدمج\n    int m = (l + r) / 2;\n    return query(id * 2, l, m, ql, qr) + query(id * 2 + 1, m + 1, r, ql, qr);\n}\n\n\n\n\n\nvoid pointUpdate(int j, int v){\n    a[j] = v;\n\n    int idx = j + N - 1;\n    seg[idx] = v;\n\n    // أعد بناء حميع الآباء\n    for (int i = idx / 2; i &gt; 0; i /= 2) {\n        seg[i] = seg[i * 2] + seg[i * 2 + 1];\n    }\n}\n\n\n\n\n\n\n\n\n\n\nDynamic Range Minimum Queries\n\nCSES\neasy\n\n\n\nلديك المصفوفة \\(x\\) المكونة من \\(n\\) عنصر و\\(q\\) استعلامات. كل استعلام يكون من أحد النوعين:\n\n“1 \\(k\\) \\(u\\)”: تحديث القيمة في الموضع \\(k\\) إلى \\(u\\).\n“2 \\(a\\) \\(b\\)”: ما هي أصغر قيمة في المجال [\\(a\\),\\(b\\)]؟\n\n\n\n\n\n\nSolution\n\nسنقوم ببناء segment tree للقيمة الصغرى ونطبق الاستعلامات وتحديثات leaf nodes مباشرة عليها.\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;climits&gt;\nusing namespace std;\n\nconst int MAXN = 200000;\nconst int N = (1 &lt;&lt; (32 - __builtin_clz(MAXN - 1)));\n\nint seg[N * 2];\nint a[MAXN];\n\nint query(int id, int l, int r, int ql, int qr) {\n    if (ql &gt; r || l &gt; qr) {\n        return INT_MAX; \n    }\n    \n    if (ql &lt;= l && r &lt;= qr) {\n        return seg[id];\n    }\n    \n    int m = (l + r)/2;\n    return min(query(id * 2, l, m, ql, qr) , query(id * 2 + 1, m + 1, r, ql, qr));\n}\n\nvoid pointUpdate(int j, int v) {\n    a[j - 1] = v;\n\n    int idx = j + N - 1;\n    seg[idx] = v;\n\n\n    for (int i = idx/2; i &gt; 0; i /= 2) {\n        seg[i] = min(seg[i * 2] , seg[i * 2 + 1]);\n    }\n}\n\nint main() {\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; a[i];\n    }\n\n    for (int i = 0 ; i &lt; n; i++) {\n        seg[i + N] = a[i];\n    }\n\n    for (int i = n + N; i &lt; 2*N; i++) {\n        seg[i] = INT_MAX; \n    }\n\n    for (int i = N - 1; i &gt; 0; i--) {\n        seg[i] = min(seg[i * 2] , seg[i * 2 + 1]);\n    }\n\n    while (q--) {\n        int type;\n        cin &gt;&gt; type;\n        \n        if (type == 1) {\n            int k, u;\n            cin &gt;&gt; k &gt;&gt; u;\n            pointUpdate(k, u);\n        }\n        else {\n            int ql, qr;\n            cin &gt;&gt; ql &gt;&gt; qr;\n\n            cout &lt;&lt; query(1, 1, N, ql, qr) &lt;&lt; \"\\n\";\n        }\n    }\n\n}",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "<span dir=\"ltr\">Segment Trees</span>"
    ]
  },
  {
    "objectID": "b3/ds/segment-trees.html#ما-هي-segment-tree",
    "href": "b3/ds/segment-trees.html#ما-هي-segment-tree",
    "title": "Segment Trees",
    "section": "",
    "text": "هي شجرة ثنائية حيث يمثل كل node قيمة استعلام على مقطع (مصفوفة جزئية) من المصفوفة الأصلية. يتم بناء الشجرة وفق القواعد التالية:\n\nكل leaf node يمثل مقطعًا بطول \\(1\\).\n\nكل internal node يمثل دمجًا ((sum, min, max, etc.)) لطفليه.\n\nلنفترض أن لدينا المصفوفة [2, 4, 6, 8]. فإن Segment Tree تحسب جمع لنطاقات مبنية على هذه المصفوفة تكون كما يلي:\n\n\n\n\n\n\ngraph TD\n    A[\"20 (1-4)\"]\n    B[\"6 (1-2)\"]\n    C[\"14 (3-4)\"]\n    D[\"2 (1-1)\"]\n    E[\"4 (2-2)\"]\n    F[\"6 (3-3)\"]\n    G[\"8 (4-4)\"]\n\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    B --&gt; E\n    C --&gt; F\n    C --&gt; G\n\n\n\n\n\n\n\nلاحظ أن جميع ال leaf nodes يمثلون عنصرًا واحدًا فقط، بينما تقوم internal nodes بدمج طفليها بأخذ مجموع قيمتيهما.",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "<span dir=\"ltr\">Segment Trees</span>"
    ]
  },
  {
    "objectID": "b3/ds/segment-trees.html#عدد-الـnodes-والحشو",
    "href": "b3/ds/segment-trees.html#عدد-الـnodes-والحشو",
    "title": "Segment Trees",
    "section": "",
    "text": "ليكن N عدد الـleaf nodes في segment tree، وn طول المصفوفة الأصلية.\n\n\n\nفي segment tree، يشكل عدد nodes في كل مستوى المتتالية [1, 2, 4, …]، أي قوى العدد اثنين.\n\nكل قوة للعدد 2 تساوي مجموع جميع القوى السابقة للعدد 2 زائد 1.\n\nلذلك، فإن العدد الكلي لـ nodes في segment tree هو 2N - 1.\n\n\n\n\n\nإذا كانت المصفوفة الأصلية تحتوي على n عنصرًا وn ليس قوة للعدد اثنين، نقوم بحشو المصفوفة بعناصر إضافية بحيث يصبح عدد leaf nodes N هو القوة التالية للعدد اثنين، مع ضمان أن العناصر الإضافية لا تؤثر على قيم الـnodes الأخرى.\n\nفي أسوأ الحالات، قد نحتاج إلى إضافة ما يصل إلى n عنصرًا، لأن القوة التالية للعدد اثنين أصغر من 2n.\n\n\n\nإذا غيرنا المثال السابق إلى [2, 4, 6]، فنحتاج إلى إضافة عنصر لجعل الطول قوة للعدد اثنين دون التأثير على القيم الأخرى. أفضل قيمة لإضافتها هي 0. ستكون segment tree الناتجة كما يلي:\n\n\n\n\n\n\ngraph TD\n    A[\"12 (1-4)\"]\n    B[\"6 (1-2)\"]\n    C[\"6 (3-4)\"]\n    D[\"2 (1-1)\"]\n    E[\"4 (2-2)\"]\n    F[\"6 (3-3)\"]\n    G[\"0 (4-4) مضافة\"]\n\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    B --&gt; E\n    C --&gt; F\n    C --&gt; G",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "<span dir=\"ltr\">Segment Trees</span>"
    ]
  },
  {
    "objectID": "b3/ds/segment-trees.html#التمثيل",
    "href": "b3/ds/segment-trees.html#التمثيل",
    "title": "Segment Trees",
    "section": "",
    "text": "سنمثل الـsegment tree كمصفوفة تعطي موقع(أرقام) لكل node. وبالتالي سيتم إعطاء المواقع للـ segment tree السابقة كما يلي:\n\n\n\n\n\n\ngraph TD\n    A[\"1: sum = 12 (1-4)\"]\n    B[\"2: sum = 6 (1-2)\"]\n    C[\"3: sum = 6 (3-4)\"]\n    D[\"4: sum = 2 (1-1)\"]\n    E[\"5: sum = 4 (2-2)\"]\n    F[\"6: sum = 6 (3-3)\"]\n    G[\"7: sum = 0 (4-4) مضاف\"]\n\n    A --&gt; B\n    A --&gt; C\n    B --&gt; D\n    B --&gt; E\n    C --&gt; F\n    C --&gt; G\n\n\n\n\n\n\n\nكل node i لها طفلان في الموضعين 2 * i و2 * i + 1، ووالدها في الموضع i / 2.\nفي هذا المثال، عدد leaf nodes N هو 4، وهو أيضًا موقع أول leaf node. لذلك فإن الـleaf node في الموضع i تقابل الموقع i - N + 1 في المصفوفة الأصلية.",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "<span dir=\"ltr\">Segment Trees</span>"
    ]
  },
  {
    "objectID": "b3/ds/segment-trees.html#الاستعلام",
    "href": "b3/ds/segment-trees.html#الاستعلام",
    "title": "Segment Trees",
    "section": "",
    "text": "لنعرّف الدالة query(id, l, r, ql, qr) التي تقوم بحساب ناتج استعلام من ql إلى qr، حيث:\n\nid هو موقع الـnode الحالي.\n\nl هو بداية النطاق الذي يغطيه الـnode الحالي.\n\nr هو نهاية النطاق الذي يغطيه الـnode الحالي.\n\nql هو بداية نطاق الاستعلام.\n\nqr هو نهاية نطاق الاستعلام.\n\nتعمل الدالة كما يلي:\n\nإذا كان المجالان [ql, qr] و[l, r] غير متقاطعين تمامًا، يتم تجاهل الـnode الحالي لأنه لا يسهم في الاستعلام.\n\nإذا كان المجال [ql, qr] يغطي بالكامل المجال [l, r]، نقوم بإرجاع القيمة المخزنة في الـnode الحالي.\n\nخلاف ذلك، نقسم المجال عند المنتصف m = (l + r) / 2 ونحصل على حساب الاستدعاء على الأطفال:\n\nquery(2 * id, l, m, ql, qr)\n\nquery(2 * id + 1, m + 1, r, ql, qr)\nثم ندمج النتائج للحصول على إجابة الـnode الحالي.\n\n\nلحل استعلام [ql, qr] نستدعي query(1, 1, N, ql, qr).\nتعقيد الزمن لهذه الخوارزمية هو \\(O(\\log n)\\).",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "<span dir=\"ltr\">Segment Trees</span>"
    ]
  },
  {
    "objectID": "b3/ds/segment-trees.html#تحديث-نقطة",
    "href": "b3/ds/segment-trees.html#تحديث-نقطة",
    "title": "Segment Trees",
    "section": "",
    "text": "بعض المسائل تطلب تحديث الموقع j إلى القيمة v. لتنفيذ ذلك نقوم بتحديث الـleaf node في الموضع j + N - 1 ثم نعيد حساب جميع قيم الـinternal node.\nعدد الآباء لكل leaf node j + N - 1 هو logn. لذلك فإن تعقيد تحديث النقطة هو \\(O(\\log n)\\).",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "<span dir=\"ltr\">Segment Trees</span>"
    ]
  },
  {
    "objectID": "b3/ds/segment-trees.html#طريقة-الكتابة",
    "href": "b3/ds/segment-trees.html#طريقة-الكتابة",
    "title": "Segment Trees",
    "section": "",
    "text": "عند بناء segment tree لدينا فقط المصفوفة الأصلية a (مرقمة ابتداء من ال0) وحجمها n.\n\n\nأولًا نحتاج إلى حساب عدد الـleaf nodes N. يمكن حسابه بطريقتين:\nإما باستخدام معادلة:\n\nint N = 1 &lt;&lt; (32 - __builtin_clz(n - 1));\n\nأو باستخدام حلقة:\n\nint N;\nfor (N = 1; N &lt; n; N *= 2); // ال; مهمة جدا\n\nحجم الشجرة سيكون 2*N.\n\nint seg[2*N]\n\n\n\n\n\n\nلبناء الشجرة نضع أولًا قيم الـleaf nodes.\n\nfor (int i = 0 ; i &lt; n; i++) {\n    seg[i + N] = a[i];\n}\n\nثم نقوم بحشو العناصر الجديدة لإكمال الـleaf nodes.\n\nfor (int i = n + N; i &lt; 2*N; i++){\n    seg[i] = 0; // segment treeالقيم المضافة تعتمد على نوع ال\n}\n\n\n\n\n\nلبناء الـinternal nodes نمر عليها بترتيب عكسي ونقوم بدمج طفلي كل internal node.\n\nfor (int i = N - 1; i &gt; 0 ; i--) {\n    seg[i] = seg[i * 2] + seg[i * 2 + 1]; // دمج قيم الطفلين\n}\n\n\n\n\n\nint query(int id, int l, int r, int ql, int qr) {\n    // تأكد إذا لا يتقاطعان\n    if (ql &gt; r || l &gt; qr) {\n        return 0; \n    }\n    // بالكامل [l, r] يشمل [ql, qr] تأكد إذا\n    if (ql &lt;= l && r &lt;= qr) {\n        return seg[id];\n    }\n    // قم بالاستدعاء الذاتي والدمج\n    int m = (l + r) / 2;\n    return query(id * 2, l, m, ql, qr) + query(id * 2 + 1, m + 1, r, ql, qr);\n}\n\n\n\n\n\nvoid pointUpdate(int j, int v){\n    a[j] = v;\n\n    int idx = j + N - 1;\n    seg[idx] = v;\n\n    // أعد بناء حميع الآباء\n    for (int i = idx / 2; i &gt; 0; i /= 2) {\n        seg[i] = seg[i * 2] + seg[i * 2 + 1];\n    }\n}",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "<span dir=\"ltr\">Segment Trees</span>"
    ]
  },
  {
    "objectID": "b3/ds/segment-trees.html#dynamic-range-minimum-queries",
    "href": "b3/ds/segment-trees.html#dynamic-range-minimum-queries",
    "title": "Segment Trees",
    "section": "",
    "text": "Dynamic Range Minimum Queries\n\nCSES\neasy\n\n\n\nلديك المصفوفة \\(x\\) المكونة من \\(n\\) عنصر و\\(q\\) استعلامات. كل استعلام يكون من أحد النوعين:\n\n“1 \\(k\\) \\(u\\)”: تحديث القيمة في الموضع \\(k\\) إلى \\(u\\).\n“2 \\(a\\) \\(b\\)”: ما هي أصغر قيمة في المجال [\\(a\\),\\(b\\)]؟",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "<span dir=\"ltr\">Segment Trees</span>"
    ]
  },
  {
    "objectID": "b3/constructive.html",
    "href": "b3/constructive.html",
    "title": "الخوارزميات البنائية",
    "section": "",
    "text": "الخوارزمية البنائية هي خوارزميات تطلب بناء مثال محدد يحقق مجموعة من القواعد، أو إثبات أنه لا يوجد مثل هذا المثال.\nعلى عكس المسائل الخوارزمية العطبيعية حيث قد تحسب أقصر مسار أو أقصى ربح في مثال، فإن المسائل البنائية تطلب المثال نفسه (على سبيل المثال “اطبع المصفوفة التي تحقق الشروط التالية…”).\nلننظر إلى بعض الأمثلة لمعرفة كيفية عمل ذلك.\n\n\n\n\n\n\n\nZero Sum Array\n\n\n\n\n\nلديك عدد صحيح \\(N\\)، اطبع \\(N\\) أعدادًا صحيحة مختلفة بحيث يكون مجموعها مساويًا لـ \\(0\\).\n\n\n\n\n\nSolution\n\nالبناء: بدلًا من البحث عن أعداد عشوائية، يمكننا بناء الإجابة باستخدام نمط ثابت.\nنعلم أنه لأي عدد \\(x\\)، فإن المجموع \\(x + (-x) = 0\\). يمكننا ببساطة إخراج أزواج من الأعداد الموجبة والسالبة. إذا كان \\(N\\) فرديًا، نضيف العدد \\(0\\) إلى المجموعة.\n\n\\(N = 1\\): 0\n\\(N = 2\\): 1 -1\n\\(N = 3\\): 1 -1 0\n\\(N = 4\\): 1 -1 2 -2 0\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n / 2; i++) {\n        cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; -i &lt;&lt; \" \";\n    }\n\n    if (n % 2 != 0) cout &lt;&lt; 0;\n    cout &lt;&lt; endl;\n}\n\n\n\n\n\n\n\n\nAnti-Identity Permutation\n\n\n\n\n\nأنشئ تبديلًا بطول \\(N\\) (بترقيم يبدأ من 1) بحيث لكل موقع \\(i\\)، يكون \\(A[i] \\neq i\\).\nعلى سبيل المثال، إذا كان \\(N=3\\)، فإن [1, 2, 3] غير صالح لأن \\(1\\) في الموقع \\(1\\). ولكن المصفوفة [2, 3, 1] صالحة.\n\n\n\n\n\nSolution\n\nإذا قمنا ببساطة بتدوير المصفوفة بمقدار موضع واحد، فلن يبقى أي رقم في موقعه الأصلي.\nتصبح الصيغة عندئذٍ \\(A[i] = i+1\\)، لكل \\(i &lt; N\\) و \\(A[N] = 1\\).\n\n\\(N=3\\): 2 3 1\n\\(N=4\\): 2 3 4 1\n\\(N=5\\): 2 3 4 5 1\n\nملاحظة: عندما يكون \\(N=1\\)، فمن المستحيل وضع \\(1\\) في أي مكان غير الموقع \\(1\\)، لذا لا يوجد حل.\n\n\n\n\n\n\n\nChessboard Domineering\n\n\n\n\n\nلديك رقعة شطرنج طبيعية بحجم \\(8 \\times 8\\) مع إزالة زاويتين متقابلتين (ليتبقى 62 مربعًا). أوجد طريقة لتغطية الرقعة بالكامل بقطع دومينو بحجم \\(2 \\times 1\\)؟\n\n\n\n\n\nSolution\n\nلقد خدعناك!\nأحيانًا يكون “البناء” هو إثبات أن المهمة مستحيلة.\nتحتوي رقعة الشطرنج القياسية على 32 مربعًا أسود و32 مربعًا أبيض. الزوايا المتقابلة تكون دائمًا من نفس اللون. إذا أزلنا زاويتين متقابلتين (مثلًا أبيضان)، يتبقى لدينا 32 مربعًا أسود و30 مربعًا أبيض. قطعة دومينو واحدة تغطي بالضبط مربعًا أسود واحدًا ومربعًا أبيض واحدًا. لتغطية الرقعة، نحتاج إلى عدد متساوٍ من المربعات السوداء والبيضاء. الاستنتاج: هذا مستحيل.\nهذه ليست ممارسة اعتيادية، لكنها قد تحدث من وقت لآخر. الدرس المستفاد هنا هو أنه قد يكون من الأسهل بكثير حل المسألة باستخدام الورقة والقلم وبعض التفكير خارج الصندوق بدلًا من محاولة كتابة الكود مباشرة.\n\n\n\n\n\nالآن بعد أن رأيت طبيعة هذه المسائل، إليك كيفية التعامل معها. على عكس نظرية الرسوم البيانية أو DP، لا تستخدم خوارزميات مباشرة مثل Dijkstra. بل تعتمد على المنطق والملاحظة.\n\n\nهذه أهم استراتيجية. إذا طلبت المسألة حلًا لـ \\(N=100000\\)، فلا تحاول تخمين معادلة معقدة مباشرة. أحضر قلمًا وحلها للحالات \\(N=1, 2, 3, 4\\). كثير من المسائل البنائية تُحل باكتشاف نمط في الحالات الصغيرة.\n\n\n\nتعتمد العديد من البُنى على خصائص الأعداد الزوجية والفردية (فردي + فريدي = زوجي).\n\nمثال: إذا سألت مسألة “هل يمكنك جعل الرقمين التاليين متساويين بأضافة 2؟”، فتحقق من الفردية والزوجية. إذا كان أحد العددين فرديًا والآخر زوجيًا، فلن يتساويا أبدًا، لأن إضافة 2 لا تغيّر الفردية.\n\n\n\n\nإذا كان لديك \\(N\\) عنصر و\\(N-1\\) صناديق، فلا بد أن يحتوي صندوق واحد على عنصرين على الأقل. يُستخدم هذا كثيرًا لإثبات وجود حل (أو لإثبات الاستحالة).\n\n\n\nاسأل نفسك: إذا كان لديّ حل صحيح لـ \\(N\\)، فهل يمكنني بسهولة إضافة عنصر واحد لجعله صحيحًا لـ \\(N+1\\)؟ هذا يسمح لك ببناء الإجابة تدريجيًا.\n\n\n\nأحيانًا تكون الإجابة بديهية. قبل المبالغة في التفكير، تحقق مما إذا كانت الإجابة ببساطة:\n\nالمصفوفة المرتبة 1, 2, 3...\nالمصفوفة المرتبة عكسيًا N, N-1, N-2...\nجميعها أصفار أو جميعها آحاد.",
    "crumbs": [
      "المرحلة 4",
      "الخوارزميات البنائية"
    ]
  },
  {
    "objectID": "b3/constructive.html#zero-sum-array",
    "href": "b3/constructive.html#zero-sum-array",
    "title": "الخوارزميات البنائية",
    "section": "",
    "text": "Zero Sum Array\n\n\n\n\n\nلديك عدد صحيح \\(N\\)، اطبع \\(N\\) أعدادًا صحيحة مختلفة بحيث يكون مجموعها مساويًا لـ \\(0\\).",
    "crumbs": [
      "المرحلة 4",
      "الخوارزميات البنائية"
    ]
  },
  {
    "objectID": "b3/constructive.html#anti-identity-permutation",
    "href": "b3/constructive.html#anti-identity-permutation",
    "title": "الخوارزميات البنائية",
    "section": "",
    "text": "Anti-Identity Permutation\n\n\n\n\n\nأنشئ تبديلًا بطول \\(N\\) (بترقيم يبدأ من 1) بحيث لكل موقع \\(i\\)، يكون \\(A[i] \\neq i\\).\nعلى سبيل المثال، إذا كان \\(N=3\\)، فإن [1, 2, 3] غير صالح لأن \\(1\\) في الموقع \\(1\\). ولكن المصفوفة [2, 3, 1] صالحة.",
    "crumbs": [
      "المرحلة 4",
      "الخوارزميات البنائية"
    ]
  },
  {
    "objectID": "b3/constructive.html#chessboard-domineering",
    "href": "b3/constructive.html#chessboard-domineering",
    "title": "الخوارزميات البنائية",
    "section": "",
    "text": "Chessboard Domineering\n\n\n\n\n\nلديك رقعة شطرنج طبيعية بحجم \\(8 \\times 8\\) مع إزالة زاويتين متقابلتين (ليتبقى 62 مربعًا). أوجد طريقة لتغطية الرقعة بالكامل بقطع دومينو بحجم \\(2 \\times 1\\)؟",
    "crumbs": [
      "المرحلة 4",
      "الخوارزميات البنائية"
    ]
  },
  {
    "objectID": "b3/constructive.html#كيف-نحل-المسائل-البنائية",
    "href": "b3/constructive.html#كيف-نحل-المسائل-البنائية",
    "title": "الخوارزميات البنائية",
    "section": "",
    "text": "الآن بعد أن رأيت طبيعة هذه المسائل، إليك كيفية التعامل معها. على عكس نظرية الرسوم البيانية أو DP، لا تستخدم خوارزميات مباشرة مثل Dijkstra. بل تعتمد على المنطق والملاحظة.\n\n\nهذه أهم استراتيجية. إذا طلبت المسألة حلًا لـ \\(N=100000\\)، فلا تحاول تخمين معادلة معقدة مباشرة. أحضر قلمًا وحلها للحالات \\(N=1, 2, 3, 4\\). كثير من المسائل البنائية تُحل باكتشاف نمط في الحالات الصغيرة.\n\n\n\nتعتمد العديد من البُنى على خصائص الأعداد الزوجية والفردية (فردي + فريدي = زوجي).\n\nمثال: إذا سألت مسألة “هل يمكنك جعل الرقمين التاليين متساويين بأضافة 2؟”، فتحقق من الفردية والزوجية. إذا كان أحد العددين فرديًا والآخر زوجيًا، فلن يتساويا أبدًا، لأن إضافة 2 لا تغيّر الفردية.\n\n\n\n\nإذا كان لديك \\(N\\) عنصر و\\(N-1\\) صناديق، فلا بد أن يحتوي صندوق واحد على عنصرين على الأقل. يُستخدم هذا كثيرًا لإثبات وجود حل (أو لإثبات الاستحالة).\n\n\n\nاسأل نفسك: إذا كان لديّ حل صحيح لـ \\(N\\)، فهل يمكنني بسهولة إضافة عنصر واحد لجعله صحيحًا لـ \\(N+1\\)؟ هذا يسمح لك ببناء الإجابة تدريجيًا.\n\n\n\nأحيانًا تكون الإجابة بديهية. قبل المبالغة في التفكير، تحقق مما إذا كانت الإجابة ببساطة:\n\nالمصفوفة المرتبة 1, 2, 3...\nالمصفوفة المرتبة عكسيًا N, N-1, N-2...\nجميعها أصفار أو جميعها آحاد.",
    "crumbs": [
      "المرحلة 4",
      "الخوارزميات البنائية"
    ]
  },
  {
    "objectID": "b2/dp-problems/frog1.html",
    "href": "b2/dp-problems/frog1.html",
    "title": "",
    "section": "",
    "text": "Frog 1\n\nAtcoder\neasy\n\n\n\nلديك مصفوفة \\(h\\) تحتوي على \\(N\\) عنصرًا.أنت تبدأ من العنصر الأول ويجب أن تصل إلى العنصر الأخير باستخدام الحركات التالية:\n\nالتحرك من الموقع \\(i\\) إلى \\(i + 1\\) بتكلفة \\(|h_i - h_{i + 1}|\\).\nالتحرك من الموقع \\(i\\) إلى \\(i + 2\\) بتكلفة \\(|h_i - h_{i + 2}|\\).\n\nجد أقل تكلفة للتحرك من العنصر الأول إلى العنصر الأخير.\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nفي هذه المشكلة سنفترض أن كل شيء يبدأ من الصفر. أي أن جميع مواقع المصفوفة تبدأ من \\(0\\).\n\n\n\n\nSolution\n\nسنقوم بحل هذه المشكلة باستخدام البرمجة الديناميكية.\nأولاً، سنعرف الحالة \\(f(i)\\) لتكون أقل تكلفة للوصول إلى الموقع \\(i\\) بدءًا من الموقع \\(0\\).\nبعد ذلك، سنعرف الانتقال. هناك طريقتان للوصول إلى الموقع \\(i\\): من \\(i - 1\\) أو من \\(i - 2\\).\nإذا وصلنا إلى الموقع \\(i\\) من \\(i-1\\)، فإن \\(f(i)\\) هو أقل تكلفة للوصول إلى \\(i-1\\) من \\(0\\) بالإضافة إلى تكلفة الانتقال من \\(i-1\\) إلى \\(i\\).\n\\(f(i) = f(i - 1) + |h_{i - 1} - h_i|\\)\nإذا وصلنا إلى الموقع \\(i\\) من \\(i-2\\)، فإن \\(f(i)\\) هو أقل تكلفة للوصول إلى \\(i-2\\) من \\(0\\) بالإضافة إلى تكلفة الانتقال من \\(i-2\\) إلى \\(i\\).\n\\(f(i) = f(i - 2) + |h_{i - 2} - h_i|\\)\nبما أننا لا نعرف أي الخيارين هو الأمثل، فسنأخذ الأدنى بين كلا الخيارين .\n\\(f(i) = min(f(i - 1) + |h_{i - 1} - h_i| , f(i - 2) + |h_{i - 2} - h_i|)\\)\nالحالة الأساسية لدينا ستكون:\n\\(f(0) = 0\\)\n\\(f(1) = |h_0 - h_1|\\)\nالمساحة في الخوارزمية يحدده عدد الحالات، وهو \\(O(N)\\).\nالزمن هو عدد الحالات \\(N\\) مضروبًا في التعقيد الزمني لكل انتقال \\(O(1)\\)، لذا يكون التعقيد الكلي \\(O(N)\\).\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint a[200000];\nint dp[200000];\n\n\nint f(int i) {\n    // الحالات الأساسية\n    if (i == 0) {\n        return 0;\n    }\n\n    if (i == 1) {\n        return abs(a[1] - a[0]);\n    }\n\n    // إذا تم حساب الحل من قبل\n    if (dp[i] != -1) {\n        return dp[i];\n    }\n\n    dp[i] = min(\n        f(i - 1) + abs(a[i] - a[i - 1]),\n        f(i - 2) + abs(a[i] - a[i - 2])\n    );\n\n    return dp[i];\n}\n\n\nint main() {\n  // أسند 1- لجميع العناصر للإشارة إلى أننا لا نعرف حل أي حالة\n    for (int i = 0; i &lt; 200000; i++) {\n        dp[i] = -1;\n    }\n\n    int n;\n    cin &gt;&gt; n;\n\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; a[i];\n    }\n\n    cout &lt;&lt; f(n - 1) &lt;&lt; \"\\n\";\n}",
    "crumbs": [
      "المرحلة 3",
      "DP problems",
      "Frog 1"
    ]
  },
  {
    "objectID": "b2/dp-problems/frog1.html#frog-1",
    "href": "b2/dp-problems/frog1.html#frog-1",
    "title": "",
    "section": "",
    "text": "Frog 1\n\nAtcoder\neasy\n\n\n\nلديك مصفوفة \\(h\\) تحتوي على \\(N\\) عنصرًا.أنت تبدأ من العنصر الأول ويجب أن تصل إلى العنصر الأخير باستخدام الحركات التالية:\n\nالتحرك من الموقع \\(i\\) إلى \\(i + 1\\) بتكلفة \\(|h_i - h_{i + 1}|\\).\nالتحرك من الموقع \\(i\\) إلى \\(i + 2\\) بتكلفة \\(|h_i - h_{i + 2}|\\).\n\nجد أقل تكلفة للتحرك من العنصر الأول إلى العنصر الأخير.",
    "crumbs": [
      "المرحلة 3",
      "DP problems",
      "Frog 1"
    ]
  },
  {
    "objectID": "b2/dp-problems/knapsack1.html",
    "href": "b2/dp-problems/knapsack1.html",
    "title": "",
    "section": "",
    "text": "Knapsack 1\n\nAtcoder\nmedium\n\n\n\nلديك مجموعة تحتوي على \\(N\\) عنصرًا، كل عنصر \\(i\\) له وزن \\(w_i\\) وقيمة \\(v_i\\). اختر مجموعة جزئية من العناصر بحيث لا يتجاوز وزنها الإجمالي \\(W\\). حدد أكبر قيمة إجمالية ممكنة.\n\n\n\n\n\nSolution\n\nسنحل هذه المشكلة باستخدام البرمجة الديناميكية.\nدعنا نعرف الحالة:\n\\(f(i, capacity)\\) هي أكبر قيمة إجمالية ممكنة بالنظر فقط إلى العناصر من \\(0\\) حتى \\(i\\) بأقصى وزن إجمالي ممكن. \\(capacity\\)\nبعد ذلك، نعرف الانتقال. في كل خطوة، يمكننا إما إضافة العنصر \\(i\\) أو إستبعاده.\nفي حالة إضافة العنصر \\(i\\)، يكون الانتقال:\n\\(f(i, capacity) = f(i - 1, capacity - w_i) + v_i\\)\nفي حالة إستبعاده، يكون الانتقال:\n\\(f(i, capacity) = f(i - 1, capacity)\\)\nنظرًا لأننا لا نستطيع تحديد أي الخيارين أفضل مسبقًا، فإننا نأخذ القيمة الأكبر بين الانتقالين:\n\\(f(i, capacity) = max(f(i - 1, capacity ), f(i - 1, capacity - w_i) + v_i)\\)\nفي هذه المشكلة، تكون الحالة الأساسية:\n \\(f(0,\\text{capacity}) =\n\\begin{cases}\nv_i, & \\text{capacity} \\ge w_i,\\\\[6pt]\n0,   & \\text{capacity} &lt; w_i.\n\\end{cases}\\) \nتعقيد المساحة في الخوارزمية يحدده عدد الحالات، وهو \\(O(N \\cdot W)\\).\nالتعقيد الزمني هو عدد الحالات N W مضروبًا في تعقيد كل انتقال \\(O(1)\\)، لذا يكون التعقيد الكلي \\(O(N \\cdot W)\\).\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nlong long dp[200][200000];\nint v[200], w[200]; \n\n\nlong long f (int i, int capacity) {\n\n    if (i == 0) {\n    if (capacity &lt; w[i]) {\n      return 0;\n    }\n    else {\n      return v[i];\n    }\n    }\n\n  if (dp[i][capacity] != -1) {\n    return dp[i][capacity];\n  }\n\n  // i في حالة إستبعاد العنصر \n  dp[i][capacity] = f(i - 1, capacity);\n\n  // i في حالة أخذ العنصر \n  if (capacity &gt;= w[i]) {\n    dp[i][capacity] = max(dp[i][capacity], f(i - 1, capacity - w[i]) + v[i]);\n  }\n\n  return dp[i][capacity];\n}\n\n\nint main() {\n  \n    for (int i = 0; i &lt; 200; i++) {\n    for (int j = 0; j &lt; 200000; j++) {\n          dp[i][j] = -1;\n    }\n    }\n\n    int n, weight;\n    cin &gt;&gt; n &gt;&gt; weight;\n  \n  for (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; w[i] &gt;&gt; v[i];\n  }\n\n  cout &lt;&lt; f(n - 1, weight) &lt;&lt; endl;\n}",
    "crumbs": [
      "المرحلة 3",
      "DP problems",
      "Knapsack 1"
    ]
  },
  {
    "objectID": "b2/dp-problems/knapsack1.html#knapsack-1",
    "href": "b2/dp-problems/knapsack1.html#knapsack-1",
    "title": "",
    "section": "",
    "text": "Knapsack 1\n\nAtcoder\nmedium\n\n\n\nلديك مجموعة تحتوي على \\(N\\) عنصرًا، كل عنصر \\(i\\) له وزن \\(w_i\\) وقيمة \\(v_i\\). اختر مجموعة جزئية من العناصر بحيث لا يتجاوز وزنها الإجمالي \\(W\\). حدد أكبر قيمة إجمالية ممكنة.",
    "crumbs": [
      "المرحلة 3",
      "DP problems",
      "Knapsack 1"
    ]
  },
  {
    "objectID": "b2/problems/grid-paths-I.html",
    "href": "b2/problems/grid-paths-I.html",
    "title": "",
    "section": "",
    "text": "Grid Paths I\n\nCSES\neasy\n\n\n\nاعتبر شبكة بحجم \\(n \\times n\\)، قد تحتوي بعض مربعاتها على فخاخ. لا يُسمح لك بالتحرك إلى مربع يحتوي على فخ.\nمهمتك هي حساب عدد المسارات من المربع العلوي الأيسر إلى المربع السفلي الأيمن. يمكنك التحرك فقط إلى اليمين أو إلى الأسفل.\nالإدخال:\n\nالسطر الأول: عدد صحيح \\(n\\) — حجم الشبكة.\nالسطور \\(n\\) التالية: يحتوي كل سطر على \\(n\\) محارف:\n\n. تمثّل خلية فارغة\n* تمثّل فخًا\n\n\nالمخرجات:\n\nاطبع عدد المسارات الصحيحة، بتطبيق باقي القسمة على \\(10^9 + 7\\).\n\nالقيود:\n\n\\(1 \\le n \\le 1000\\)\n\nمثال:\nالإدخال:\n4\n....\n.*..\n...*\n*...\nالمخرجات:\n3\n\n\n\n\n\nSolution\n\nنريد عدّ المسارات من \\((0,0)\\) إلى \\((n-1,n-1)\\) مع السماح بالحركة إلى اليمين أو الأسفل فقط، ومنع الدخول إلى أي خلية تحمل *.\nهذه مسألة برمجة ديناميكية قياسية على الشبكات.\n\n\n\nلنعرّف dp[i][j] على أنه عدد الطرق للوصول إلى الخلية \\((i,j)\\) بدايةً من \\((0,0)\\).\n\nإذا كانت الخلية \\((i,j)\\) فخًا: dp[i][j] = 0.\nوإلا يمكننا الوصول إليها من:\n\nالأعلى: \\((i-1,j)\\) عبر نزول خطوة،\nاليسار: \\((i,j-1)\\) عبر حركة إلى اليمين.\n\n\nإذًا للخلية الفارغة:\n\\[\ndp[i][j] =\n\\begin{cases}\n0, & \\text{if } g_{i,j} = \\ast,\\\\[4pt]\n1, & (i,j) = (0,0) \\text{ and } g_{0,0} \\neq \\ast,\\\\[4pt]\n\\bigl(dp[i-1][j] + dp[i][j-1]\\bigr) \\bmod M, & \\text{otherwise}.\n\\end{cases}\n\\]\nحيث \\(M = 10^9 + 7\\).\nنملأ الجدول بالتتابع باستخدام حلقتين متداخلتين:\n\ni من 0 إلى n-1،\nj من 0 إلى n-1.\n\nالجواب هو dp[n-1][n-1].\n\n\n\n\n\n\ndp[i][j] = عدد المسارات الصحيحة من الخلية الابتدائية \\((0,0)\\) إلى الخلية \\((i,j)\\)، مع الالتزام بأن:\n\nالحركة فقط إلى اليمين أو الأسفل،\nلا ندخل أي خلية فخ *.\n\nما نريده في النهاية هو حالة الهدف dp[n-1][n-1].\n\n\n\n\nللخلية غير الفخ \\((i,j)\\) (أي grid[i][j] == '.'):\n\nأي مسار يصل إلى \\((i,j)\\) لا يمكن أن يأتي إلا من:\n\nالأعلى \\((i-1,j)\\) أو\nاليسار \\((i,j-1)\\)،\n\n\nلأن الحركات الوحيدة المسموحة هي إلى اليمين أو الأسفل، ولا توجد طرق أخرى للدخول.\nلذا:\n \\[\ndp[i][j] = dp[i-1][j] + dp[i][j-1] \\pmod M,\n\\] \nمع اعتبار أي مؤشر خارج الحدود يساهم بـ 0.\nإذا كانت grid[i][j] == '*':\n \\[\ndp[i][j] = 0,\n\\] \nلأننا لا يمكن أن نقف على خلية فخ.\n\n\n\n\nفي الكود، لكل خلية:\n\nif (grid[i][j] == '*') dp[i][j] = 0;\nelse if (i == 0 && j == 0) dp[i][j] = 1;\nelse {\n    long long from_up   = (i &gt; 0 ? dp[i-1][j] : 0);\n    long long from_left = (j &gt; 0 ? dp[i][j-1] : 0);\n    dp[i][j] = (from_up + from_left) % MOD;\n}\n\nوهذا يطبّق العلاقة العودية مباشرة.\n\n\n\n\n\nالخلية الابتدائية \\((0,0)\\):\n\nإذا كانت فخًا → لا يوجد أي مسار → dp[0][0] = 0 (مغطاة بحالة الفخ).\nإذا كانت فارغة → يوجد مسار واحد فقط يبدأ منها:\ndp[0][0] = 1.\n\nالصف الأول (i = 0, j &gt; 0):\n\nيمكن الوصول إليه فقط من اليسار، ولا يوجد صف أعلى.\nالعلاقة مع dp[i-1][j] = 0 تعطي تلقائيًا:\n\ndp[0][j] = dp[0][j-1] إذا لم تكن الخلية فخًا، وإلا 0.\n\n\nالعمود الأول (j = 0, i &gt; 0):\n\nيمكن الوصول إليه فقط من الأعلى؛ والحدود تُدار بنفس الطريقة.\n\n\nكل هذه الحالات تُغطّى تلقائيًا عبر القواعد العامة مع فحص حدود المصفوفة.\n\n\n\n\nنكرّر على (i,j) بترتيب الصفوف:\n\nالحلقة الخارجية: i = 0..n-1\nالحلقة الداخلية: j = 0..n-1\n\nعند حساب dp[i][j] نستخدم فقط:\n\ndp[i-1][j] (الصف السابق)،\ndp[i][j-1] (العمود السابق في نفس الصف)،\n\nوكلتاهما تم حسابهما سابقًا لأن:\n\ni-1 &lt; i،\nj-1 &lt; j.\n\nإذًا الترتيب صحيح والـ DP معرّف جيدًا.\n\n\n\n\n\nعدد الخلايا \\(n^2\\).\nلكل خلية، نقوم بعمل ثابت \\(O(1)\\).\n\nإذًا:\n\nالزمن: \\(O(n^2)\\) (حتى \\(10^6\\) عملية تقريبًا، وهذا مناسب).\nالذاكرة: \\(O(n^2)\\) لجدول dp.\n\n\n\n\n\n\nالقيمة dp[n-1][n-1] هي بالضبط عدد المسارات الصحيحة من الزاوية العلوية اليسرى إلى الزاوية السفلية اليمنى، بتطبيق باقي القسمة على \\(10^9+7\\).\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconst long long MOD = 1000000007LL;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;string&gt; grid(n);\n    for (int i = 0; i &lt; n; ++i) {\n        cin &gt;&gt; grid[i];\n    }\n\n    // dp[i][j] = number of ways to reach (i, j)\n    vector&lt;vector&lt;long long&gt;&gt; dp(n, vector&lt;long long&gt;(n, 0));\n\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j) {\n            if (grid[i][j] == '*') {\n                dp[i][j] = 0; // cannot use traps\n                continue;\n            }\n\n            if (i == 0 && j == 0) {\n                dp[i][j] = 1; // starting cell (if not trap)\n            } else {\n                long long from_up   = (i &gt; 0 ? dp[i - 1][j] : 0);\n                long long from_left = (j &gt; 0 ? dp[i][j - 1] : 0);\n                dp[i][j] = (from_up + from_left) % MOD;\n            }\n        }\n    }\n\n    cout &lt;&lt; dp[n - 1] [n - 1] &lt;&lt; \"\\n\";\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nCautionملاحظات حول المودولو والحدود\n\n\n\n\nنتأكد دائمًا من أخذ النتيجة بتطبيق باقي القسمة على \\(10^9 + 7\\).\nنتجنب الخروج عن حدود المصفوفة باستخدام فحص الشرطين i &gt; 0 و j &gt; 0 قبل الوصول إلى dp[i-1][j] أو dp[i][j-1].\nإذا كانت خلية الهدف فخًا، فسيكون الناتج تلقائيًا 0 لأن dp[n-1][n-1] سيُضبط إلى صفر.",
    "crumbs": [
      "المرحلة 3",
      "Problems",
      "Grid Paths I"
    ]
  },
  {
    "objectID": "b2/problems/grid-paths-I.html#grid-paths-i",
    "href": "b2/problems/grid-paths-I.html#grid-paths-i",
    "title": "",
    "section": "",
    "text": "Grid Paths I\n\nCSES\neasy\n\n\n\nاعتبر شبكة بحجم \\(n \\times n\\)، قد تحتوي بعض مربعاتها على فخاخ. لا يُسمح لك بالتحرك إلى مربع يحتوي على فخ.\nمهمتك هي حساب عدد المسارات من المربع العلوي الأيسر إلى المربع السفلي الأيمن. يمكنك التحرك فقط إلى اليمين أو إلى الأسفل.\nالإدخال:\n\nالسطر الأول: عدد صحيح \\(n\\) — حجم الشبكة.\nالسطور \\(n\\) التالية: يحتوي كل سطر على \\(n\\) محارف:\n\n. تمثّل خلية فارغة\n* تمثّل فخًا\n\n\nالمخرجات:\n\nاطبع عدد المسارات الصحيحة، بتطبيق باقي القسمة على \\(10^9 + 7\\).\n\nالقيود:\n\n\\(1 \\le n \\le 1000\\)\n\nمثال:\nالإدخال:\n4\n....\n.*..\n...*\n*...\nالمخرجات:\n3",
    "crumbs": [
      "المرحلة 3",
      "Problems",
      "Grid Paths I"
    ]
  },
  {
    "objectID": "b2/problems/coin-combinations-I.html",
    "href": "b2/problems/coin-combinations-I.html",
    "title": "",
    "section": "",
    "text": "Coin Combinations I\n\nCSES\nmedium\n\n\n\nاعتبر نظامًا نقديًا يتكوّن من \\(n\\) عملات. كل عملة لها قيمة صحيحة موجبة. مهمتك هي حساب عدد الطرق المختلفة التي يمكنك بها تكوين مجموع مالي مقداره \\(x\\) باستخدام العملات المتاحة.\nترتيب العملات مهم في التركيبة. فعلى سبيل المثال، إذا كانت العملات \\({2,3,5}\\) والمجموع المطلوب هو \\(9\\)، فهناك 8 طرق:\n\n2 + 2 + 5\n2 + 5 + 2\n5 + 2 + 2\n3 + 3 + 3\n2 + 2 + 2 + 3\n2 + 2 + 3 + 2\n2 + 3 + 2 + 2\n3 + 2 + 2 + 2\n\nالإدخال:\n\nالسطر الأول يحتوي عددين صحيحين \\(n\\) و \\(x\\): عدد العملات والمجموع المطلوب من المال.\nالسطر الثاني يحتوي \\(n\\) عددًا مميزًا \\(c_1, c_2, \\dots, c_n\\): قيمة كل عملة.\n\nالمخرجات:\n\nاطبع عددًا صحيحًا واحدًا: عدد الطرق لتكوين المجموع \\(x\\)، بتطبيق باقي القسمة على \\(10^9 + 7\\).\n\nالقيود:\n\n\\(1 \\le n \\le 100\\)\n\\(1 \\le x \\le 10^6\\)\n\\(1 \\le c_i \\le 10^6\\)\n\nمثال:\nالإدخال:\n3 9\n2 3 5\nالمخرجات:\n8",
    "crumbs": [
      "المرحلة 3",
      "Practice Problems",
      "Coin Combinations I"
    ]
  },
  {
    "objectID": "b2/problems/coin-combinations-I.html#coin-combinations-i",
    "href": "b2/problems/coin-combinations-I.html#coin-combinations-i",
    "title": "",
    "section": "",
    "text": "Coin Combinations I\n\nCSES\nmedium\n\n\n\nاعتبر نظامًا نقديًا يتكوّن من \\(n\\) عملات. كل عملة لها قيمة صحيحة موجبة. مهمتك هي حساب عدد الطرق المختلفة التي يمكنك بها تكوين مجموع مالي مقداره \\(x\\) باستخدام العملات المتاحة.\nترتيب العملات مهم في التركيبة. فعلى سبيل المثال، إذا كانت العملات \\({2,3,5}\\) والمجموع المطلوب هو \\(9\\)، فهناك 8 طرق:\n\n2 + 2 + 5\n2 + 5 + 2\n5 + 2 + 2\n3 + 3 + 3\n2 + 2 + 2 + 3\n2 + 2 + 3 + 2\n2 + 3 + 2 + 2\n3 + 2 + 2 + 2\n\nالإدخال:\n\nالسطر الأول يحتوي عددين صحيحين \\(n\\) و \\(x\\): عدد العملات والمجموع المطلوب من المال.\nالسطر الثاني يحتوي \\(n\\) عددًا مميزًا \\(c_1, c_2, \\dots, c_n\\): قيمة كل عملة.\n\nالمخرجات:\n\nاطبع عددًا صحيحًا واحدًا: عدد الطرق لتكوين المجموع \\(x\\)، بتطبيق باقي القسمة على \\(10^9 + 7\\).\n\nالقيود:\n\n\\(1 \\le n \\le 100\\)\n\\(1 \\le x \\le 10^6\\)\n\\(1 \\le c_i \\le 10^6\\)\n\nمثال:\nالإدخال:\n3 9\n2 3 5\nالمخرجات:\n8",
    "crumbs": [
      "المرحلة 3",
      "Practice Problems",
      "Coin Combinations I"
    ]
  },
  {
    "objectID": "b2/cpp/structs.html",
    "href": "b2/cpp/structs.html",
    "title": "الهياكل (struct)",
    "section": "",
    "text": "في لغة C++ تسمح لك البنية (struct) بتجميع عدة أجزاء من البيانات تحت اسم واحد. يمكنك التفكير فيها كنوع بيانات مخصّص تقوم أنت بتصميمه بنفسك.\n\n\nالبنية struct تجمع مجموعة من المتغيرات ذات العلاقة (تسمّى أعضاء أو members) وقد تكون من أنواع مختلفة داخل نفس الكيان.\n\n\n\nstruct TypeName {\n    member_type1 member_name1;\n    member_type2 member_name2;\n    // ...\n};\n\n\nTypeName → اسم نوع البيانات الجديد الذي تعرّفه.\nداخل الأقواس المعقوفة { } → الأعضاء (members)، وهي المتغيرات التي تنتمي لهذا النوع.\n\n\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct product {\n    int weight;     // in grams\n    double price;   // in riyals\n};\n\nint main() {\n    product apple;\n    product banana, melon;\n\n    apple.weight = 150;\n    apple.price  = 1.99;\n\n    banana.weight = 120;\n    banana.price  = 0.99;\n\n    cout &lt;&lt; \"Apple: \"  &lt;&lt; apple.weight  &lt;&lt; \" g, \" &lt;&lt; apple.price &lt;&lt; \" SAR\" &lt;&lt; endl;\n    cout &lt;&lt; \"Banana: \" &lt;&lt; banana.weight &lt;&lt; \" g, \" &lt;&lt; banana.price &lt;&lt; \" SAR\" &lt;&lt; endl;\n}\n\nفي هذا المثال:\n\nعرّفنا نوعًا جديدًا اسمه product.\nهذا النوع يحتوي عضوين:\n\nweight من نوع int يمثّل الوزن بالجرام.\nprice من نوع double يمثّل السعر بالريال.\n\n\nبعدها أنشأنا متغيّرات (كائنات) من هذا النوع: apple، banana، وmelon، وأعطينا كلًا منها قيمًا خاصة به.\n\n\nنستخدم عامل النقطة .:\n\napple.weight → عضو من نوع int\napple.price → عضو من نوع double\n\nيمكنك القراءة من هذه الأعضاء أو التعديل عليها مثل أي متغير عادي تمامًا.\n\n\n\n\nيمكنك أيضًا تعريف المتغيرات في نهاية تعريف البنية مباشرة:\n\nstruct product {\n    int weight;\n    double price;\n} apple, banana, melon;\n\nهنا:\n\nproduct هو اسم النوع (البنية).\napple، banana، melon هي متغيرات (كائنات) من هذا النوع.",
    "crumbs": [
      "المرحلة 3",
      "C++",
      "الهياكل (<span dir=\"ltr\">`struct`</span>)"
    ]
  },
  {
    "objectID": "b2/cpp/structs.html#ما-هي-البنية-struct",
    "href": "b2/cpp/structs.html#ما-هي-البنية-struct",
    "title": "الهياكل (struct)",
    "section": "",
    "text": "البنية struct تجمع مجموعة من المتغيرات ذات العلاقة (تسمّى أعضاء أو members) وقد تكون من أنواع مختلفة داخل نفس الكيان.\n\n\n\nstruct TypeName {\n    member_type1 member_name1;\n    member_type2 member_name2;\n    // ...\n};\n\n\nTypeName → اسم نوع البيانات الجديد الذي تعرّفه.\nداخل الأقواس المعقوفة { } → الأعضاء (members)، وهي المتغيرات التي تنتمي لهذا النوع.",
    "crumbs": [
      "المرحلة 3",
      "C++",
      "الهياكل (<span dir=\"ltr\">`struct`</span>)"
    ]
  },
  {
    "objectID": "b2/cpp/structs.html#مثال-بنية-product",
    "href": "b2/cpp/structs.html#مثال-بنية-product",
    "title": "الهياكل (struct)",
    "section": "",
    "text": "#include &lt;iostream&gt;\nusing namespace std;\n\nstruct product {\n    int weight;     // in grams\n    double price;   // in riyals\n};\n\nint main() {\n    product apple;\n    product banana, melon;\n\n    apple.weight = 150;\n    apple.price  = 1.99;\n\n    banana.weight = 120;\n    banana.price  = 0.99;\n\n    cout &lt;&lt; \"Apple: \"  &lt;&lt; apple.weight  &lt;&lt; \" g, \" &lt;&lt; apple.price &lt;&lt; \" SAR\" &lt;&lt; endl;\n    cout &lt;&lt; \"Banana: \" &lt;&lt; banana.weight &lt;&lt; \" g, \" &lt;&lt; banana.price &lt;&lt; \" SAR\" &lt;&lt; endl;\n}\n\nفي هذا المثال:\n\nعرّفنا نوعًا جديدًا اسمه product.\nهذا النوع يحتوي عضوين:\n\nweight من نوع int يمثّل الوزن بالجرام.\nprice من نوع double يمثّل السعر بالريال.\n\n\nبعدها أنشأنا متغيّرات (كائنات) من هذا النوع: apple، banana، وmelon، وأعطينا كلًا منها قيمًا خاصة به.\n\n\nنستخدم عامل النقطة .:\n\napple.weight → عضو من نوع int\napple.price → عضو من نوع double\n\nيمكنك القراءة من هذه الأعضاء أو التعديل عليها مثل أي متغير عادي تمامًا.",
    "crumbs": [
      "المرحلة 3",
      "C++",
      "الهياكل (<span dir=\"ltr\">`struct`</span>)"
    ]
  },
  {
    "objectID": "b2/cpp/structs.html#تعريف-كائنات-مباشرة-بعد-تعريف-البنية",
    "href": "b2/cpp/structs.html#تعريف-كائنات-مباشرة-بعد-تعريف-البنية",
    "title": "الهياكل (struct)",
    "section": "",
    "text": "يمكنك أيضًا تعريف المتغيرات في نهاية تعريف البنية مباشرة:\n\nstruct product {\n    int weight;\n    double price;\n} apple, banana, melon;\n\nهنا:\n\nproduct هو اسم النوع (البنية).\napple، banana، melon هي متغيرات (كائنات) من هذا النوع.",
    "crumbs": [
      "المرحلة 3",
      "C++",
      "الهياكل (<span dir=\"ltr\">`struct`</span>)"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html",
    "href": "b2/bit-manipulation.html",
    "title": "حيل التعامل مع البِتّات (Bit Manipulation Tricks)",
    "section": "",
    "text": "سنفترض وجود المتغيرين التاليين:\n\nint x;       // some non-negative integer\nint k;       // 0-based bit index (0 = least significant bit)\n\nوسنستخدم أقنعة (masks) مثل 1 &lt;&lt; k، والتي يكون فيها البِت رقم k فقط مساويًا لـ1.\n\n\n\nbool isSet = (x &gt;&gt; k) & 1;\n\n\nx &gt;&gt; k → إزاحة لليمين بحيث ينتقل البِت رقم k إلى أقصى اليمين.\n(x &gt;&gt; k) & 1 → تُبقي البِت الأيمن فقط وتصفّر باقي البِتّات.\nالناتج يكون 0 أو 1، وهو يعادل false أو true منطقيًا.\n\n\n\n\nافحص ما إذا كان البِت رقم 1 في x مُعينًا (يساوي 1).\n\n\nint x = 10;     // 10 = 1010 (in binary)\nint k = 1;\n\nbool isSet = (x &gt;&gt; 1) & 1; // 1010 &gt;&gt; 1 = 101;  101 & 1 = 1 (true)\n\n\nمعطى عددان n وk، اكتب دالة تحدد ما إذا كان البِت رقم k في n مساويًا لـ1.\n\n\nbool kthBitIsSet(int n, int k) {\n    return (n &gt;&gt; k) && 1;\n}\n\n\n\n\n\n\nx |= (1 &lt;&lt; k);\n\n\nالعامل | يعيّن البِت إلى 1 إذا كان على الأقل أحد الطرفين يحتوي 1.\nبهذا نجبر البِت رقم k أن يصبح 1، بينما تبقى باقي البِتّات كما هي.\n\n\n\n\nint x = 4;      // 0100\nx |= (1 &lt;&lt; 0);  // 0100 | 0001 = 0101 (5)\n\n\n\n\n\n\nx &= ~(1 &lt;&lt; k);\n\n\n1 &lt;&lt; k → قناع فيه البِت رقم k يساوي 1.\n~(1 &lt;&lt; k) → قناع فيه البِت رقم k يساوي 0، وجميع البِتّات الأخرى تساوي 1.\nإجراء & مع هذا القناع يقوم بتصفير البِت رقم k فقط.\n\n\n\n\nint x = 13;         // 1101\nx &= ~(1 &lt;&lt; 2);     // ~(0100) = ...1011\n                    // 1101 & 1011 = 1001 (9)\n\nالآن البِت رقم 2 أصبح 0.\n\n\n\n\n\nx ^= (1 &lt;&lt; k);\n\n\nالعامل ^ (XOR) يقلب البِت عندما يكون القناع فيه 1:\n\n0 ^ 1 = 1\n1 ^ 1 = 0\n\n\n\n\n\nint x = 5;     // 0101\nx ^= (1 &lt;&lt; 2); // 0101 ^ 0100 = 0001 (1)\n\nالبِت رقم 2 كان 1 → أصبح الآن 0.\n\n\n\n\nهذه حيلة مشهورة جدًّا:\n\nx = x & (x - 1);\n\nهذا السطر يزيل (يُصفّر) أقل بِت معيّن (أول 1 من جهة اليمين) في x.\n\n\nفكّر ماذا يحدث للبِتّات عندما نطرح 1:\n\nعند تنفيذ x - 1، نمشي من اليمين حتى نجد أول بِت قيمته 1.\nهذا البِت الأقل (أقرب 1 لليمين) يتحوّل إلى 0.\nكل البِتّات التي على يمينه (والتي كانت 0) تتحوّل إلى 1 (بسبب الاقتراض في الطرح).\n\nإذًا حول أقل بِت معيّن، النمط يكون بهذا الشكل:\n\nx:       .... 1 0 0 0 0\nx - 1:   .... 0 1 1 1 1\n\nعند إجراء AND:\n\nx        = .... 1 0 0 0 0\nx - 1    = .... 0 1 1 1 1\n-------------------------\nx&(x-1)  = .... 0 0 0 0 0\n\n\nأقل بِت معيّن يصبح 0 لأنه 1 & 0.\nكل البِتّات التي على يمينه كانت 0 في x، ومع أي قيمة في x - 1 تعطي 0 & something = 0.\nكل البِتّات التي على يساره لا تتأثر، لأن الطرح لم يغيّرها؛ أي أن قيمتها في x وx - 1 متطابقة، وبالتالي تبقى كما هي بعد AND.\n\nلذلك x & (x - 1) تساوي قيمة x نفسها لكن مع أقل بِت معيّن مصفّرًا.\n\n\n\n\nx           = 12 = 1100\nx - 1       = 11 = 1011\nx & (x - 1) =  8 = 1000\n\nإذًا قمنا بإزالة أقل بِت معيّن (البِت رقم 2).\n\n\n\n\nسنفترض أن x عدد موجب، ونستخدم الحيلة السابقة:\n\nbool isPowerOfTwo = (x & (x - 1)) == 0;\n\nلماذا تعمل هذه الحيلة؟\n\nالعدد الذي هو قوة للعدد 2 في الثنائي (1, 10, 100, 1000, …) يحتوي بِتًا واحدًا فقط معيّنًا.\nعند تنفيذ x & (x - 1) نقوم بإزالة أقل بِت معيّن.\nإذا كان هناك بِت واحد فقط معيّن، فبعد إزالة هذا البِت تصبح القيمة 0.\n\nإذًا:\n\nx & (x - 1) == 0 ⇔ x لديه بِت واحد معيّن فقط (أي قوة للعدد 2).\n\n\n\n\nx = 8 (1000) → x & (x-1) = 1000 & 0111 = 0000 → قوة للعدد 2.\nx = 12 (1100) → x & (x-1) = 1100 & 1011 = 1000 → ليست 0 → ليس قوة للعدد 2.\n\n\n\n\n\n\nint lowest = x & -x;\n\nهنا -x هو المتمّم الثنائي (two’s complement) للعدد x.\nالفكرة:\n\nالتعبير x & -x يعزل أقل بِت معيّن (أول 1 من جهة اليمين) ويصفّر جميع البِتّات الأخرى.\n\n\n\n\nx                = 12 = ...00001100\n-x (two's complement) = ...11110100\nx & -x                = ...00000100 = 4\n\nأقل بِت معيّن في x يمثّل القيمة 4 (أي البِت رقم 2).\n\n\n\n\n\nفحص البِت رقم k: isSet = (x &gt;&gt; k) & 1;\nضبط البِت رقم k إلى 1: x |= (1 &lt;&lt; k);\nتصفير البِت رقم k: x &= ~(1 &lt;&lt; k);\nقلب (تبديل) البِت رقم k: x ^= (1 &lt;&lt; k);\nإزالة أقل بِت معيّن: x &= (x - 1);\nفحص إذا كان x قوة للعدد 2: x &gt; 0 && (x & (x - 1)) == 0\nالحصول على أقل بِت معيّن فقط: lowest = x & -x;\n\nهذه هي أهم وأشهر حيل التعامل مع البِتّات (bit manipulation) في البرمجة.",
    "crumbs": [
      "المرحلة 3",
      "حيل التعامل مع البِتّات (Bit Manipulation Tricks)"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#فحص-ما-إذا-كان-البت-k-يساوي-1",
    "href": "b2/bit-manipulation.html#فحص-ما-إذا-كان-البت-k-يساوي-1",
    "title": "حيل التعامل مع البِتّات (Bit Manipulation Tricks)",
    "section": "",
    "text": "bool isSet = (x &gt;&gt; k) & 1;\n\n\nx &gt;&gt; k → إزاحة لليمين بحيث ينتقل البِت رقم k إلى أقصى اليمين.\n(x &gt;&gt; k) & 1 → تُبقي البِت الأيمن فقط وتصفّر باقي البِتّات.\nالناتج يكون 0 أو 1، وهو يعادل false أو true منطقيًا.\n\n\n\n\nافحص ما إذا كان البِت رقم 1 في x مُعينًا (يساوي 1).\n\n\nint x = 10;     // 10 = 1010 (in binary)\nint k = 1;\n\nbool isSet = (x &gt;&gt; 1) & 1; // 1010 &gt;&gt; 1 = 101;  101 & 1 = 1 (true)\n\n\nمعطى عددان n وk، اكتب دالة تحدد ما إذا كان البِت رقم k في n مساويًا لـ1.\n\n\nbool kthBitIsSet(int n, int k) {\n    return (n &gt;&gt; k) && 1;\n}",
    "crumbs": [
      "المرحلة 3",
      "حيل التعامل مع البِتّات (Bit Manipulation Tricks)"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#ضبط-البت-رقم-k-إلى-1",
    "href": "b2/bit-manipulation.html#ضبط-البت-رقم-k-إلى-1",
    "title": "حيل التعامل مع البِتّات (Bit Manipulation Tricks)",
    "section": "",
    "text": "x |= (1 &lt;&lt; k);\n\n\nالعامل | يعيّن البِت إلى 1 إذا كان على الأقل أحد الطرفين يحتوي 1.\nبهذا نجبر البِت رقم k أن يصبح 1، بينما تبقى باقي البِتّات كما هي.\n\n\n\n\nint x = 4;      // 0100\nx |= (1 &lt;&lt; 0);  // 0100 | 0001 = 0101 (5)",
    "crumbs": [
      "المرحلة 3",
      "حيل التعامل مع البِتّات (Bit Manipulation Tricks)"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#تصفير-البت-رقم-k-جعله-0",
    "href": "b2/bit-manipulation.html#تصفير-البت-رقم-k-جعله-0",
    "title": "حيل التعامل مع البِتّات (Bit Manipulation Tricks)",
    "section": "",
    "text": "x &= ~(1 &lt;&lt; k);\n\n\n1 &lt;&lt; k → قناع فيه البِت رقم k يساوي 1.\n~(1 &lt;&lt; k) → قناع فيه البِت رقم k يساوي 0، وجميع البِتّات الأخرى تساوي 1.\nإجراء & مع هذا القناع يقوم بتصفير البِت رقم k فقط.\n\n\n\n\nint x = 13;         // 1101\nx &= ~(1 &lt;&lt; 2);     // ~(0100) = ...1011\n                    // 1101 & 1011 = 1001 (9)\n\nالآن البِت رقم 2 أصبح 0.",
    "crumbs": [
      "المرحلة 3",
      "حيل التعامل مع البِتّات (Bit Manipulation Tricks)"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#قلب-تبديل-البت-رقم-k",
    "href": "b2/bit-manipulation.html#قلب-تبديل-البت-رقم-k",
    "title": "حيل التعامل مع البِتّات (Bit Manipulation Tricks)",
    "section": "",
    "text": "x ^= (1 &lt;&lt; k);\n\n\nالعامل ^ (XOR) يقلب البِت عندما يكون القناع فيه 1:\n\n0 ^ 1 = 1\n1 ^ 1 = 0\n\n\n\n\n\nint x = 5;     // 0101\nx ^= (1 &lt;&lt; 2); // 0101 ^ 0100 = 0001 (1)\n\nالبِت رقم 2 كان 1 → أصبح الآن 0.",
    "crumbs": [
      "المرحلة 3",
      "حيل التعامل مع البِتّات (Bit Manipulation Tricks)"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#إزالة-أقل-بت-معين-أقل-1-من-اليمين",
    "href": "b2/bit-manipulation.html#إزالة-أقل-بت-معين-أقل-1-من-اليمين",
    "title": "حيل التعامل مع البِتّات (Bit Manipulation Tricks)",
    "section": "",
    "text": "هذه حيلة مشهورة جدًّا:\n\nx = x & (x - 1);\n\nهذا السطر يزيل (يُصفّر) أقل بِت معيّن (أول 1 من جهة اليمين) في x.\n\n\nفكّر ماذا يحدث للبِتّات عندما نطرح 1:\n\nعند تنفيذ x - 1، نمشي من اليمين حتى نجد أول بِت قيمته 1.\nهذا البِت الأقل (أقرب 1 لليمين) يتحوّل إلى 0.\nكل البِتّات التي على يمينه (والتي كانت 0) تتحوّل إلى 1 (بسبب الاقتراض في الطرح).\n\nإذًا حول أقل بِت معيّن، النمط يكون بهذا الشكل:\n\nx:       .... 1 0 0 0 0\nx - 1:   .... 0 1 1 1 1\n\nعند إجراء AND:\n\nx        = .... 1 0 0 0 0\nx - 1    = .... 0 1 1 1 1\n-------------------------\nx&(x-1)  = .... 0 0 0 0 0\n\n\nأقل بِت معيّن يصبح 0 لأنه 1 & 0.\nكل البِتّات التي على يمينه كانت 0 في x، ومع أي قيمة في x - 1 تعطي 0 & something = 0.\nكل البِتّات التي على يساره لا تتأثر، لأن الطرح لم يغيّرها؛ أي أن قيمتها في x وx - 1 متطابقة، وبالتالي تبقى كما هي بعد AND.\n\nلذلك x & (x - 1) تساوي قيمة x نفسها لكن مع أقل بِت معيّن مصفّرًا.\n\n\n\n\nx           = 12 = 1100\nx - 1       = 11 = 1011\nx & (x - 1) =  8 = 1000\n\nإذًا قمنا بإزالة أقل بِت معيّن (البِت رقم 2).",
    "crumbs": [
      "المرحلة 3",
      "حيل التعامل مع البِتّات (Bit Manipulation Tricks)"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#فحص-ما-إذا-كان-x-قوة-للعدد-2",
    "href": "b2/bit-manipulation.html#فحص-ما-إذا-كان-x-قوة-للعدد-2",
    "title": "حيل التعامل مع البِتّات (Bit Manipulation Tricks)",
    "section": "",
    "text": "سنفترض أن x عدد موجب، ونستخدم الحيلة السابقة:\n\nbool isPowerOfTwo = (x & (x - 1)) == 0;\n\nلماذا تعمل هذه الحيلة؟\n\nالعدد الذي هو قوة للعدد 2 في الثنائي (1, 10, 100, 1000, …) يحتوي بِتًا واحدًا فقط معيّنًا.\nعند تنفيذ x & (x - 1) نقوم بإزالة أقل بِت معيّن.\nإذا كان هناك بِت واحد فقط معيّن، فبعد إزالة هذا البِت تصبح القيمة 0.\n\nإذًا:\n\nx & (x - 1) == 0 ⇔ x لديه بِت واحد معيّن فقط (أي قوة للعدد 2).\n\n\n\n\nx = 8 (1000) → x & (x-1) = 1000 & 0111 = 0000 → قوة للعدد 2.\nx = 12 (1100) → x & (x-1) = 1100 & 1011 = 1000 → ليست 0 → ليس قوة للعدد 2.",
    "crumbs": [
      "المرحلة 3",
      "حيل التعامل مع البِتّات (Bit Manipulation Tricks)"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#الحصول-على-أقل-بت-معين-فقط",
    "href": "b2/bit-manipulation.html#الحصول-على-أقل-بت-معين-فقط",
    "title": "حيل التعامل مع البِتّات (Bit Manipulation Tricks)",
    "section": "",
    "text": "int lowest = x & -x;\n\nهنا -x هو المتمّم الثنائي (two’s complement) للعدد x.\nالفكرة:\n\nالتعبير x & -x يعزل أقل بِت معيّن (أول 1 من جهة اليمين) ويصفّر جميع البِتّات الأخرى.\n\n\n\n\nx                = 12 = ...00001100\n-x (two's complement) = ...11110100\nx & -x                = ...00000100 = 4\n\nأقل بِت معيّن في x يمثّل القيمة 4 (أي البِت رقم 2).",
    "crumbs": [
      "المرحلة 3",
      "حيل التعامل مع البِتّات (Bit Manipulation Tricks)"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#ملخص-سريع",
    "href": "b2/bit-manipulation.html#ملخص-سريع",
    "title": "حيل التعامل مع البِتّات (Bit Manipulation Tricks)",
    "section": "",
    "text": "فحص البِت رقم k: isSet = (x &gt;&gt; k) & 1;\nضبط البِت رقم k إلى 1: x |= (1 &lt;&lt; k);\nتصفير البِت رقم k: x &= ~(1 &lt;&lt; k);\nقلب (تبديل) البِت رقم k: x ^= (1 &lt;&lt; k);\nإزالة أقل بِت معيّن: x &= (x - 1);\nفحص إذا كان x قوة للعدد 2: x &gt; 0 && (x & (x - 1)) == 0\nالحصول على أقل بِت معيّن فقط: lowest = x & -x;\n\nهذه هي أهم وأشهر حيل التعامل مع البِتّات (bit manipulation) في البرمجة.",
    "crumbs": [
      "المرحلة 3",
      "حيل التعامل مع البِتّات (Bit Manipulation Tricks)"
    ]
  },
  {
    "objectID": "b1/simulation.html",
    "href": "b1/simulation.html",
    "title": "المحاكاة",
    "section": "",
    "text": "مشاكل المحاكاة تتعلق بتقليد عمليات حقيقية أو منطقية خطوة بخطوة. يُطلب منك أن “تحاكي” ما يحدث — تمامًا مثل تشغيل برنامج صغير داخل برنامجك!\n\n\nفي البرمجة التنافسية، المحاكاة تعني اتباع قواعد المشكلة بعناية وتنفيذ كل خطوة كما هي موصوفة تمامًا.\nلست بحاجة لخوارزمية معقدة — فقط قم بتكرار ما يحدث عادةً باستخدام الحلقات.\nهنا مثال بسيط لمشكلة تُحل باستخدام المحاكاة.\n\n\n\n\n\nCollatz conjecture\n\n\n\n\n\nاعتبر العملية التالية.\n\nابدأ بعدد معين \\(n\\).\nفي كل خطوة:\n\nإذا كان \\(n\\) زوجيًا، استبدله بـ \\(n/2\\).\nإذا كان \\(n\\) فرديًا، استبدله بـ \\(3n+1\\).\n\nاطبع عدد الخطوات التي استغرقتها العملية قبل أن يصبح \\(n\\) مساويًا لـ 1.\n\n\n\n\nقد تتساءل هل هذه العملية أصلًا يجب أن تصل إلى 1. حسنًا، لا أحد يملك إجابة لذلك، فهي مسألة رياضية مشهورة وغير محلولة! لكن يمكننا محاولة محاكاتها ورؤية ما يحدث.\n\n\nSolution\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    long long n;\n    cin &gt;&gt; n;\n\n    int steps = 0;\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3*n + 1;\n        }\n        steps++;\n    }\n\n    cout &lt;&lt; steps &lt;&lt; \"\\n\";\n    return 0;\n}\n\nIf n = 3, the program goes like this:\n\n\n\nstep\nn\n\n\n\n\n0\n3\n\n\n1\n10\n\n\n2\n5\n\n\n3\n16\n\n\n4\n8\n\n\n5\n4\n\n\n6\n2\n\n\n7\n1\n\n\n\nلذا الإجابة هي 7.\n\n\n\n\n\nالمحاكاة ممتازة عندما:\n\nتعطيك المشكلة قائمة خطوات أو أفعال مفصلة.\nلا يوجد اختصار رياضي.\nيمكنك فقط اتباع العملية مباشرة.\n\nأمثلة شائعة:\n\nالألعاب (مثل tic-tac-toe، snake، إلخ)\nالتحرك على شبكة (روبوتات، سيارات، أشخاص يمشون)\nالتحويلات النصية (تحرير نص، تدوير)\nإدارة العناصر (طوابير، مكدسات، أو مهام مع الوقت)\n\n\n\n\nمعظم مشاكل المحاكاة تتبع نفس النمط:\n\ninitialize variables\nwhile (there are still actions left) {\n    read next action\n    update variables according to rules\n}\nprint final result\n\nأنت basically تقوم “بتشغيل” القواعد خطوة بخطوة.\n\n\n\n\n\n\n\n\nRobot on a grid\n\n\n\n\n\nروبوت يبدأ عند \\((0, 0)\\). يستقبل سلسلة من الحركات مكونة من N, S, E, W. اطبع إحداثياته النهائية.\n\n\n\n\n\nSolution\n\n\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string moves;\n    cin &gt;&gt; moves;\n\n    int x = 0, y = 0;\n    for (char c : moves) {\n        if (c == 'N') y++;\n        else if (c == 'S') y--;\n        else if (c == 'E') x++;\n        else if (c == 'W') x--;\n    }\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y;\n}\n\n\nإذا كان الإدخال NNEEWS، ينتهي الروبوت عند (1, 1).\n\n\n\n\n\n\n\nGame simulation\n\n\n\n\n\nيوجد عدة أبطال في اللعبة، ولكلٍّ منهم قوة خاصة به. في كل ثانية، يقوم أضعف بطل، A، بإلحاق ضرر بأقوى بطل، B، ويُقلّل من قوة B بمقدار قوة A. تنتهي اللعبة عندما تصل قوة أحد الأبطال إلى 0. اطبع عدد الثواني التي استمرت فيها اللعبة.\n\n\n\n\n\nSolution\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    int n; cin &gt;&gt; n;\n    vector&lt;int&gt; strength(n);\n    for (int &x : strength) cin &gt;&gt; x;\n\n    int seconds = 0;\n    while (true) {\n        sort(strength.begin(), strength.end());\n        if (strength[0] == 0) break;\n        strength[n-1] -= strength[0];\n        seconds++;\n    }\n    cout &lt;&lt; seconds;\n}\n\n\nهذه تحاكي العملية بالكامل كما هي موصوفة.\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nأحيانًا، توجد طرق لتجاوز بعض خطوات المحاكاة وجعل عملية المحاكاة أسرع. هل يمكنك التفكير في طريقة كهذه في المثال السابق؟\n\n\n\n\n\nاتبع القواعد حرفيًا. لا تحاول التفكير الزائد — فقط نفّذ ما تقوله المشكلة.\nاستخدم الحلقات والشرطيات للتعامل مع الحالات المختلفة.\nاطبع الخطوات الوسيطة أثناء التصحيح لتتأكد أن منطقك مطابق للوصف.\nكن حذرًا مع الحدود (مثل الخروج من الشبكة أو استخدام فهارس خاطئة).\nاستخدم حالات صغيرة لاختبار الكود يدويًا.\nقم بمحاكاة البرنامج بالقلم والورق لفهم ما يحدث فعلًا وبرمجته خطوة بخطوة.\n\n\n\n\nأحيانًا، قد تكون المحاكاة بطيئة جدًا إذا كانت العملية تستغرق مليارات الخطوات. في هذه الحالات، تحتاج لإيجاد أنماط أو اختصارات.\nعلى سبيل المثال:\n\nإذا كانت العملية تتكرر بعد عدد معين من الخطوات، استخدم الرياضيات لتجاوز الدورات.\nإذا لم يعد الناتج يتغير بعد فترة، توقف مبكرًا.\n\n\n\n\n\nمباشرة جدًا — لا حاجة لخوارزميات معقدة\nسهلة التنفيذ والفهم\nتعمل مع أي عملية تعتمد على قواعد تقريبًا\n\n\n\n\n\nقد تكون بطيئة للمدخلات الكبيرة\nسهل ارتكاب أخطاء صغيرة عند اتباع العديد من الخطوات\nالتصحيح قد يستغرق وقتًا إذا لم تطبع النتائج الوسيطة\n\n\n\n\n\nالمحاكاة تعني تقليد العملية خطوة بخطوة.\nممتازة للمشاكل التي تصف قواعد أو أفعالًا دقيقة.\nركّز على الحلقات، الشرطيات، وتحديث المتغيرات.\nتحقق دائمًا من أمثلة صغيرة يدويًا.\nعندما تكون بطيئة جدًا — ابحث عن أنماط متكررة!",
    "crumbs": [
      "المرحلة 2",
      "المحاكاة"
    ]
  },
  {
    "objectID": "b1/simulation.html#ماذا-تعني-المحاكاة",
    "href": "b1/simulation.html#ماذا-تعني-المحاكاة",
    "title": "المحاكاة",
    "section": "",
    "text": "في البرمجة التنافسية، المحاكاة تعني اتباع قواعد المشكلة بعناية وتنفيذ كل خطوة كما هي موصوفة تمامًا.\nلست بحاجة لخوارزمية معقدة — فقط قم بتكرار ما يحدث عادةً باستخدام الحلقات.\nهنا مثال بسيط لمشكلة تُحل باستخدام المحاكاة.",
    "crumbs": [
      "المرحلة 2",
      "المحاكاة"
    ]
  },
  {
    "objectID": "b1/simulation.html#collatz-conjecture",
    "href": "b1/simulation.html#collatz-conjecture",
    "title": "المحاكاة",
    "section": "",
    "text": "Collatz conjecture\n\n\n\n\n\nاعتبر العملية التالية.\n\nابدأ بعدد معين \\(n\\).\nفي كل خطوة:\n\nإذا كان \\(n\\) زوجيًا، استبدله بـ \\(n/2\\).\nإذا كان \\(n\\) فرديًا، استبدله بـ \\(3n+1\\).\n\nاطبع عدد الخطوات التي استغرقتها العملية قبل أن يصبح \\(n\\) مساويًا لـ 1.",
    "crumbs": [
      "المرحلة 2",
      "المحاكاة"
    ]
  },
  {
    "objectID": "b1/simulation.html#متى-نستخدم-المحاكاة",
    "href": "b1/simulation.html#متى-نستخدم-المحاكاة",
    "title": "المحاكاة",
    "section": "",
    "text": "المحاكاة ممتازة عندما:\n\nتعطيك المشكلة قائمة خطوات أو أفعال مفصلة.\nلا يوجد اختصار رياضي.\nيمكنك فقط اتباع العملية مباشرة.\n\nأمثلة شائعة:\n\nالألعاب (مثل tic-tac-toe، snake، إلخ)\nالتحرك على شبكة (روبوتات، سيارات، أشخاص يمشون)\nالتحويلات النصية (تحرير نص، تدوير)\nإدارة العناصر (طوابير، مكدسات، أو مهام مع الوقت)",
    "crumbs": [
      "المرحلة 2",
      "المحاكاة"
    ]
  },
  {
    "objectID": "b1/simulation.html#نمط-المحاكاة",
    "href": "b1/simulation.html#نمط-المحاكاة",
    "title": "المحاكاة",
    "section": "",
    "text": "معظم مشاكل المحاكاة تتبع نفس النمط:\n\ninitialize variables\nwhile (there are still actions left) {\n    read next action\n    update variables according to rules\n}\nprint final result\n\nأنت basically تقوم “بتشغيل” القواعد خطوة بخطوة.",
    "crumbs": [
      "المرحلة 2",
      "المحاكاة"
    ]
  },
  {
    "objectID": "b1/simulation.html#robot-on-a-grid",
    "href": "b1/simulation.html#robot-on-a-grid",
    "title": "المحاكاة",
    "section": "",
    "text": "Robot on a grid\n\n\n\n\n\nروبوت يبدأ عند \\((0, 0)\\). يستقبل سلسلة من الحركات مكونة من N, S, E, W. اطبع إحداثياته النهائية.",
    "crumbs": [
      "المرحلة 2",
      "المحاكاة"
    ]
  },
  {
    "objectID": "b1/simulation.html#game-simulation",
    "href": "b1/simulation.html#game-simulation",
    "title": "المحاكاة",
    "section": "",
    "text": "Game simulation\n\n\n\n\n\nيوجد عدة أبطال في اللعبة، ولكلٍّ منهم قوة خاصة به. في كل ثانية، يقوم أضعف بطل، A، بإلحاق ضرر بأقوى بطل، B، ويُقلّل من قوة B بمقدار قوة A. تنتهي اللعبة عندما تصل قوة أحد الأبطال إلى 0. اطبع عدد الثواني التي استمرت فيها اللعبة.",
    "crumbs": [
      "المرحلة 2",
      "المحاكاة"
    ]
  },
  {
    "objectID": "b1/simulation.html#نصائح-لمشاكل-المحاكاة",
    "href": "b1/simulation.html#نصائح-لمشاكل-المحاكاة",
    "title": "المحاكاة",
    "section": "",
    "text": "اتبع القواعد حرفيًا. لا تحاول التفكير الزائد — فقط نفّذ ما تقوله المشكلة.\nاستخدم الحلقات والشرطيات للتعامل مع الحالات المختلفة.\nاطبع الخطوات الوسيطة أثناء التصحيح لتتأكد أن منطقك مطابق للوصف.\nكن حذرًا مع الحدود (مثل الخروج من الشبكة أو استخدام فهارس خاطئة).\nاستخدم حالات صغيرة لاختبار الكود يدويًا.\nقم بمحاكاة البرنامج بالقلم والورق لفهم ما يحدث فعلًا وبرمجته خطوة بخطوة.",
    "crumbs": [
      "المرحلة 2",
      "المحاكاة"
    ]
  },
  {
    "objectID": "b1/simulation.html#نصيحة-أداء",
    "href": "b1/simulation.html#نصيحة-أداء",
    "title": "المحاكاة",
    "section": "",
    "text": "أحيانًا، قد تكون المحاكاة بطيئة جدًا إذا كانت العملية تستغرق مليارات الخطوات. في هذه الحالات، تحتاج لإيجاد أنماط أو اختصارات.\nعلى سبيل المثال:\n\nإذا كانت العملية تتكرر بعد عدد معين من الخطوات، استخدم الرياضيات لتجاوز الدورات.\nإذا لم يعد الناتج يتغير بعد فترة، توقف مبكرًا.",
    "crumbs": [
      "المرحلة 2",
      "المحاكاة"
    ]
  },
  {
    "objectID": "b1/simulation.html#المزايا",
    "href": "b1/simulation.html#المزايا",
    "title": "المحاكاة",
    "section": "",
    "text": "مباشرة جدًا — لا حاجة لخوارزميات معقدة\nسهلة التنفيذ والفهم\nتعمل مع أي عملية تعتمد على قواعد تقريبًا",
    "crumbs": [
      "المرحلة 2",
      "المحاكاة"
    ]
  },
  {
    "objectID": "b1/simulation.html#العيوب",
    "href": "b1/simulation.html#العيوب",
    "title": "المحاكاة",
    "section": "",
    "text": "قد تكون بطيئة للمدخلات الكبيرة\nسهل ارتكاب أخطاء صغيرة عند اتباع العديد من الخطوات\nالتصحيح قد يستغرق وقتًا إذا لم تطبع النتائج الوسيطة",
    "crumbs": [
      "المرحلة 2",
      "المحاكاة"
    ]
  },
  {
    "objectID": "b1/simulation.html#خلاصة-سريعة",
    "href": "b1/simulation.html#خلاصة-سريعة",
    "title": "المحاكاة",
    "section": "",
    "text": "المحاكاة تعني تقليد العملية خطوة بخطوة.\nممتازة للمشاكل التي تصف قواعد أو أفعالًا دقيقة.\nركّز على الحلقات، الشرطيات، وتحديث المتغيرات.\nتحقق دائمًا من أمثلة صغيرة يدويًا.\nعندما تكون بطيئة جدًا — ابحث عن أنماط متكررة!",
    "crumbs": [
      "المرحلة 2",
      "المحاكاة"
    ]
  },
  {
    "objectID": "b1/binary-search.html",
    "href": "b1/binary-search.html",
    "title": "البحث الثنائي (Binary Search)",
    "section": "",
    "text": "البحث الثنائي هو طريقة سريعة لإيجاد عنصر في قائمة أو نطاق مرتبة. لكن قبل ذلك، لنبدأ بشيء أبسط — البحث الخطي (linear search).\n\n\nتخيل أن لديك قائمة من الأرقام وتريد التحقق مما إذا كان رقم موجود في القائمة. أبسط طريقة هي المرور عبر القائمة عنصرًا عنصرًا.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {4, 8, 15, 16, 23, 42};\n    int target = 15;\n\n    for (int i = 0; i &lt; arr.size(); i++) {\n        if (arr[i] == target) {\n            cout &lt;&lt; \"Found at index \" &lt;&lt; i;\n            return 0;\n        }\n    }\n    cout &lt;&lt; \"Not found\";\n}\n\nيسمى هذا البحث الخطي لأنك تنتقل خطيًا عبر القائمة. يعمل دائمًا، لكن إذا كانت القائمة طويلة، فقد يكون بطيئًا — قد تحتاج للتحقق من كل عنصر.\nإذا كان هناك مليون رقم، فهذا يعني مليون عملية تحقق.\nتخيل الآن أنك تبحث عن اسم في دليل الهاتف المطبوع. لن تبدأ من الصفحة الأولى وتقرأ واحدًا تلو الآخر. ستفتح في منتصف الدليل، وتتحقق إذا كنت في البداية أو النهاية أبجديًا، ثم تتخطى نصف الصفحات.\nهذا هو البحث الثنائي.\n\n\n\nالبحث الثنائي يشبه لعبة “خمن الرقم”. كل مرة تختار القيمة الوسطى وتسأل:\n\nهل هذه القيمة صغيرة جدًا؟\nكبيرة جدًا؟\nأم صحيحة بالضبط؟\n\nثم تقطع مساحة البحث إلى النصف. هذا يجعل البحث أسرع بكثير من البحث الخطي، لكنه يعمل فقط إذا كانت البيانات مرتبة.\n\n\n\n\n\n\n\n\nFind the 7\n\n\n\n\n\nلدينا مصفوفة مرتبة:\n\n[1, 3, 5, 6, 7, 9, 11]\n\nابحث عن الرقم 7 في المصفوفة واطبع موقعه إذا وجد.\n\n\n\n\n\nSolution\n\nنبدأ بالنطاق الكامل، ثم نضيق البحث تدريجيًا.\nأولًا، نجد العنصر في المنتصف، وهو الرقم 6. نسأل هل الرقم 7 أصغر أم أكبر من 6؟ هو أكبر، وبما أن المصفوفة مرتبة، هذا يعني أن الرقم 7 سيكون بعد 6. يمكننا تجاهل النصف الأول من المصفوفة.\nالمصفوفة المتبقية هي [7, 9, 11]. العنصر في المنتصف هو 9. الرقم 7 أصغر من 9، أي أنه قبل 9 في المصفوفة المرتبة. يمكننا تجاهل 9 وكل ما بعده.\nأخيرًا، المصفوفة هي [7]. العنصر الأوسط هو 7، وهو ما نبحث عنه بالضبط. قُمنا بثلاث مقارنات:\n\nقارننا 6 مع 7\nقارننا 9 مع 7\nقارننا 7 مع 7\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {1, 3, 5, 6, 7, 9, 11};\n    int target = 7;\n    int left = 0, right = arr.size() - 1;\n\n    while (left &lt;= right) {\n        int mid = (left + right) / 2;\n        if (arr[mid] == target) {\n            cout &lt;&lt; \"Found at index \" &lt;&lt; mid;\n            return 0;\n        } else if (arr[mid] &lt; target) \n            left = mid + 1;\n        else \n            right = mid - 1;\n    }\n\n    cout &lt;&lt; \"Not found\";\n}\n\nالمخرجات:\n\nFound at index 4\n\n\n\n\nكل خطوة تقطع النطاق إلى النصف. إذا كان هناك n عنصرًا، البحث الثنائي يحتاج حوالي \\(\\log_2(n)\\) خطوة فقط. أي حوالي 20 تحقق، حتى لو كان هناك مليون رقم.\n\n\nالبحث الثنائي يمكنه فعل أكثر من إيجاد رقم. يمكن استخدامه لإيجاد مواضع أو حدود.\n\n\n\n\n\nPosition Hunt\n\n\n\n\n\nلديك مصفوفة [2, 4, 6, 8, 10]. اعثر على أول عنصر أكبر من أو يساوي 7 باستخدام البحث الثنائي.\n\n\n\n\n\nSolution\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {2, 4, 6, 8, 10};\n    int x = 7;\n\n    int left = 0, right = arr.size() - 1;\n    int ans = -1;\n\n    while (left &lt;= right) {\n        int mid = (left + right) / 2;\n        if (arr[mid] &gt;= x) {\n            ans = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    if (ans == -1) cout &lt;&lt; \"No element found\";\n    else cout &lt;&lt; \"First element &gt;= \" &lt;&lt; x &lt;&lt; \" is at index \" &lt;&lt; ans;\n}\n\nالمخرجات:\n\nFirst element &gt;= 7 is at index 3\n\nأي أن arr[3] = 8 هو أول عنصر أكبر من أو يساوي 7.\n\n\n\n\n\n\nابدأ بمؤشرين left و right.\nاحسب منتصف النطاق mid.\nإذا كانت القيمة الوسطى هي الإجابة، توقف.\nإذا كانت صغيرة جدًا، حرك left إلى mid + 1.\nإذا كانت كبيرة جدًا، حرك right إلى mid - 1.\nكرر حتى يصبح left &gt; right.",
    "crumbs": [
      "المرحلة 2",
      "البحث الثنائي (Binary Search)"
    ]
  },
  {
    "objectID": "b1/binary-search.html#البحث-الخطي",
    "href": "b1/binary-search.html#البحث-الخطي",
    "title": "البحث الثنائي (Binary Search)",
    "section": "",
    "text": "تخيل أن لديك قائمة من الأرقام وتريد التحقق مما إذا كان رقم موجود في القائمة. أبسط طريقة هي المرور عبر القائمة عنصرًا عنصرًا.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {4, 8, 15, 16, 23, 42};\n    int target = 15;\n\n    for (int i = 0; i &lt; arr.size(); i++) {\n        if (arr[i] == target) {\n            cout &lt;&lt; \"Found at index \" &lt;&lt; i;\n            return 0;\n        }\n    }\n    cout &lt;&lt; \"Not found\";\n}\n\nيسمى هذا البحث الخطي لأنك تنتقل خطيًا عبر القائمة. يعمل دائمًا، لكن إذا كانت القائمة طويلة، فقد يكون بطيئًا — قد تحتاج للتحقق من كل عنصر.\nإذا كان هناك مليون رقم، فهذا يعني مليون عملية تحقق.\nتخيل الآن أنك تبحث عن اسم في دليل الهاتف المطبوع. لن تبدأ من الصفحة الأولى وتقرأ واحدًا تلو الآخر. ستفتح في منتصف الدليل، وتتحقق إذا كنت في البداية أو النهاية أبجديًا، ثم تتخطى نصف الصفحات.\nهذا هو البحث الثنائي.",
    "crumbs": [
      "المرحلة 2",
      "البحث الثنائي (Binary Search)"
    ]
  },
  {
    "objectID": "b1/binary-search.html#فكرة-البحث-الثنائي",
    "href": "b1/binary-search.html#فكرة-البحث-الثنائي",
    "title": "البحث الثنائي (Binary Search)",
    "section": "",
    "text": "البحث الثنائي يشبه لعبة “خمن الرقم”. كل مرة تختار القيمة الوسطى وتسأل:\n\nهل هذه القيمة صغيرة جدًا؟\nكبيرة جدًا؟\nأم صحيحة بالضبط؟\n\nثم تقطع مساحة البحث إلى النصف. هذا يجعل البحث أسرع بكثير من البحث الخطي، لكنه يعمل فقط إذا كانت البيانات مرتبة.",
    "crumbs": [
      "المرحلة 2",
      "البحث الثنائي (Binary Search)"
    ]
  },
  {
    "objectID": "b1/binary-search.html#find-the-7",
    "href": "b1/binary-search.html#find-the-7",
    "title": "البحث الثنائي (Binary Search)",
    "section": "",
    "text": "Find the 7\n\n\n\n\n\nلدينا مصفوفة مرتبة:\n\n[1, 3, 5, 6, 7, 9, 11]\n\nابحث عن الرقم 7 في المصفوفة واطبع موقعه إذا وجد.",
    "crumbs": [
      "المرحلة 2",
      "البحث الثنائي (Binary Search)"
    ]
  },
  {
    "objectID": "b1/binary-search.html#إيجاد-أول-عنصر-أكبر-من-أو-يساوي-x",
    "href": "b1/binary-search.html#إيجاد-أول-عنصر-أكبر-من-أو-يساوي-x",
    "title": "البحث الثنائي (Binary Search)",
    "section": "",
    "text": "البحث الثنائي يمكنه فعل أكثر من إيجاد رقم. يمكن استخدامه لإيجاد مواضع أو حدود.",
    "crumbs": [
      "المرحلة 2",
      "البحث الثنائي (Binary Search)"
    ]
  },
  {
    "objectID": "b1/binary-search.html#position-hunt",
    "href": "b1/binary-search.html#position-hunt",
    "title": "البحث الثنائي (Binary Search)",
    "section": "",
    "text": "Position Hunt\n\n\n\n\n\nلديك مصفوفة [2, 4, 6, 8, 10]. اعثر على أول عنصر أكبر من أو يساوي 7 باستخدام البحث الثنائي.",
    "crumbs": [
      "المرحلة 2",
      "البحث الثنائي (Binary Search)"
    ]
  },
  {
    "objectID": "b1/binary-search.html#الخوارزمية",
    "href": "b1/binary-search.html#الخوارزمية",
    "title": "البحث الثنائي (Binary Search)",
    "section": "",
    "text": "ابدأ بمؤشرين left و right.\nاحسب منتصف النطاق mid.\nإذا كانت القيمة الوسطى هي الإجابة، توقف.\nإذا كانت صغيرة جدًا، حرك left إلى mid + 1.\nإذا كانت كبيرة جدًا، حرك right إلى mid - 1.\nكرر حتى يصبح left &gt; right.",
    "crumbs": [
      "المرحلة 2",
      "البحث الثنائي (Binary Search)"
    ]
  },
  {
    "objectID": "b1/time-complexity.html",
    "href": "b1/time-complexity.html",
    "title": "التعقيد الزمني (Time Complexity)",
    "section": "",
    "text": "عندما نكتب برامج، بعض الحلول تعمل أسرع من غيرها. التعقيد الزمني هو طريقة لـ قياس مدى سرعة نمو الخوارزمية كلما كبر حجم المدخلات.\nلا نقيسه بالثواني، بل نقيسه بعدد الخطوات التي تزداد عند زيادة حجم المدخلات.\nالتعقيد الزمني يساعدك على مقارنة الخوارزميات بدون تشغيلها فعليًا.\nلنفترض أن لدينا هذا الكود:\n\nfor (int i = 0; i &lt; n; i++)\n    cout &lt;&lt; i &lt;&lt; \" \";\n\nإذا كان \\(n = 10\\)، يطبع 10 أرقام. إذا كان \\(n = 1000\\)، يطبع 1000 رقم. إذا تضاعف \\(n\\)، فإن عدد الخطوات أيضًا يتضاعف.\nنقول إن هذا الكود يعمل في \\(O(n)\\) زمن، لأنه يحتوي على \\(n\\) خطوة/عملية. هذا يعني أن الوقت ينمو خطيًا مع حجم المدخلات.\n\n\nالرمز الكبير \\(O\\) (Big O) يوضح كيف ينمو عدد الخطوات مع زيادة \\(n\\).\nنهتم فقط بالنمو الرئيسي، وليس بالثوابت أو التفاصيل الصغيرة.\n\n\n\n\n\n\n\n\nالاسم\nالمثال\nالوصف\n\n\n\n\n\\(O(1)\\)\nx = a + b;\nوقت ثابت – يعمل فورًا بغض النظر عن حجم n\n\n\n\\(O(\\log n)\\)\nset::insert\nكل خطوة تقلل المشكلة للنصف\n\n\n\\(O(n)\\)\nحلقة على مصفوفة\nالوقت ينمو خطيًا\n\n\n\\(O(n \\log n)\\)\nترتيب\nأبطأ قليلًا من \\(O(n)\\)، ولكن أسرع بكثير من \\(O(n^2)\\)\n\n\n\\(O(n^2)\\)\nحلقات متداخلة\nالوقت ينمو بسرعة كبيرة عند زيادة n\n\n\n\\(O(2^n)\\)\nتجربة جميع التركيبات\nأسي – ينمو بشكل هائل بسرعة\n\n\n\nكلما كان التعقيد أصغر، كان النمو أسرع.\n\n\n\n\n\n\n\n\nزيادة الرقم\n\n\n\n\n\nمعطى لك رقم \\(x\\). قم بزيادة \\(x\\) بمقدار 1، ثم اطبعه.\n\n\n\n\n\nSolution\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(){\n    int x;\n    cin &gt;&gt; x;\n\n    x += 1;\n\n    cout &lt;&lt; x &lt;&lt; '\\n';\n}\n\n\n\n\nهنا، قمنا بثلاثة أشياء:\n\nقراءة عدد صحيح من المدخلات\nزيادة العدد بمقدار واحد\nإخراج العدد\n\nكلها عمليات بسيطة. لكننا لا نقول إن هذا تعقيد \\(O(3)\\)، لأننا لا نهتم بالثوابت؛ نهتم فقط بالنمو الرئيسي. إذن هذا \\(O(1)\\).\n\n\n\n\n\n\n\nمجموع المال\n\n\n\n\n\nمعطى لك \\(n\\) أوراق نقدية قيمتها \\(arr[0]\\) ريال، \\(arr[1]\\) ريال، …، \\(arr[n-1]\\) ريال. كم مجموع الريالات لديك؟\n\n\n\n\n\nSolution\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(){\n    int n;\n    cin &gt;&gt; n;\n\n    int arr[n];\n\n    for (int i = 0; i &lt; n; i++)\n        cin &gt;&gt; arr[i];\n\n    long long sum = 0;\n    for (int i = 0; i &lt; n; i++)\n        sum += arr[i];\n\n    cout &lt;&lt; sum &lt;&lt; '\\n';\n}\n\n\n\n\nالحلقة تعمل مرة لكل عنصر. إذا تضاعفت المصفوفة، يتضاعف الوقت أيضًا.\nلاحظ أننا أنشأنا مصفوفة وأدخلنا العناصر؛ هذا يأخذ عمليتين لكل عنصر. أيضًا نقرأ عدد العناصر، نضبط المتغير \\(sum\\) على صفر، وفي النهاية نطبع sum. بالمجموع: \\(1 + n + n + 1 + n + 1 = 3n + 3\\). لكننا لا نهتم بالثوابت، إذن التعقيد \\(O(3n+3) = O(n)\\) - خوارزمية زمنها خطي.\n\n\n\n\n\n\n\nالنسخ\n\n\n\n\n\nمعطى لك \\(n\\) أوراق نقدية قيمتها \\(arr[0]\\) ريال، \\(arr[1]\\) ريال، …، \\(arr[n-1]\\) ريال. لكل من \\(n\\) أيام، قم بزيادة قيمة كل ورقة بمقدار واحد. بعد اليوم الأول، تصبح الأوراق: \\(arr[0]+1\\), \\(arr[1]+1\\), …، \\(arr[n-1]+1\\). بعد اليوم الثاني: \\(arr[0]+2\\), … وهكذا. بعد \\(n\\) أيام ستكون الأوراق: \\(arr[0]+n\\), …، \\(arr[n-1]+n\\).\nاطبع قيم كل الأوراق لكل يوم من الأيام \\(n\\).\n\n\n\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(){\n    int n;\n    cin &gt;&gt; n;\n\n    int arr[n];\n    for (int i = 0; i &lt; n; i++)\n        cin &gt;&gt; arr[i];\n\n    for (int days = 1; days &lt;= n; days++){\n        for (int i = 0; i &lt; n; i++){\n            cout &lt;&lt; arr[i] + days &lt;&lt; ' ';\n        }\n        cout &lt;&lt; '\\n';\n    }\n}\n\n\nهناك \\(n\\) أيام و \\(n\\) أوراق في كل يوم يجب زيادتها. بالمجموع، نقوم بـ \\(O(n^2)\\) عملية (مع تجاهل الثوابت). إذا كان \\(n = 10\\)، فإن الخطوات = 100. إذا كان \\(n = 1000\\)، فإن الخطوات = مليون.\nلهذا يمكن أن تصبح الخوارزميات \\(O(n^2)\\) بطيئة جدًا بسرعة.\n\n\nلنرى كيف تنمو مع زيادة n:\n\n\n\n\n\n\n\n\n\n\n\\(n\\)\n\\(O(1)\\)\n\\(O(\\log n)\\)\n\\(O(n)\\)\n\\(O(n^2)\\)\n\n\n\n\n10\n1\n3\n10\n100\n\n\n100\n1\n7\n100\n10,000\n\n\n1000\n1\n10\n1000\n1,000,000\n\n\n\nحتى لو بدت الفروقات صغيرة عند n صغير، فإنها تتضخم جدًا عند n كبير.\n\n\n\n\n\n\n\n\n\n\n\\(n\\)\nالتعقيد الأقصى المقبول\n\n\n\n\n\\(\\leq 10\\)\n\\(O(n!)\\)\n\n\n\\(\\leq 20\\)\nعادة \\(O(2^n)\\) مقبول\n\n\n\\(\\leq 1000\\)\nعادة \\(O(n^2)\\) مقبول\n\n\n\\(\\leq 10^5\\)\n\\(O(n \\log n)\\) أو أفضل\n\n\n\\(\\leq 10^7\\)\n\\(O(n)\\) أو أفضل\n\n\n\\(\\geq 10^9\\)\nفقط \\(O(1)\\) أو \\(O(\\log n)\\)\n\n\n\nهذا يساعدك على تخمين نوع الحل المناسب لحجم مدخلات معين.\n\n\n\nأحيانًا ليس واضحًا، لكن يمكنك جعل البرنامج أسرع بالتفكير في حلول أذكى.\n\n\n\n\n\nالمجموع البسيط\n\n\n\n\n\nمعطى لك رقم \\(n\\). أوجد مجموع: \\(-n + (-n+1) + (-n+2) + ... + -1 + 0 + 1 + ... + (n-2) + (n-1) + n\\).\n\n\n\n\n\nSolution\n\nحل بسيط خطيًا يكون هكذا:\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(){\n    int n;\n    cin &gt;&gt; n;\n\n    long long sum = 0;\n    for (int i = -n; i &lt;= n; i++)\n        sum += i;\n\n    cout &lt;&lt; sum &lt;&lt; '\\n';\n}\n\nهذا الحل خطي زمنه \\(O(n)\\).\n\n\n\n\n\nSolution\n\nيمكننا عمل أفضل من ذلك. كل عدد يظهر مرة موجبة ومرة سالبة – \\(+n\\) و \\(-n\\). إذن في النهاية، كل الأعداد تلغي بعضها البعض ويبقى فقط صفر. الحل الأبسط:\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(){\n    int n;\n    cin &gt;&gt; n;\n\n    cout &lt;&lt; 0 &lt;&lt; '\\n';\n}\n\nهذا الحل \\(O(1)\\)، وقت ثابت وأسرع بكثير من الحل البسيط. دائمًا حاول التفكير في أسرع حل ممكن.\n\n\n\n\n\nأحيانًا نهتم أيضًا بـ كمية الذاكرة التي يستخدمها البرنامج. هذا ما يسمى التعقيد المكاني. الفكرة نفسها: كيف تنمو استخدام الذاكرة مع زيادة حجم المدخلات.\nمثال:\n\nint arr[n];  // مساحة O(n)\nint x;       // مساحة O(1)",
    "crumbs": [
      "المرحلة 2",
      "التعقيد الزمني (Time Complexity)"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#ما-معنى-oldots",
    "href": "b1/time-complexity.html#ما-معنى-oldots",
    "title": "التعقيد الزمني (Time Complexity)",
    "section": "",
    "text": "الرمز الكبير \\(O\\) (Big O) يوضح كيف ينمو عدد الخطوات مع زيادة \\(n\\).\nنهتم فقط بالنمو الرئيسي، وليس بالثوابت أو التفاصيل الصغيرة.\n\n\n\n\n\n\n\n\nالاسم\nالمثال\nالوصف\n\n\n\n\n\\(O(1)\\)\nx = a + b;\nوقت ثابت – يعمل فورًا بغض النظر عن حجم n\n\n\n\\(O(\\log n)\\)\nset::insert\nكل خطوة تقلل المشكلة للنصف\n\n\n\\(O(n)\\)\nحلقة على مصفوفة\nالوقت ينمو خطيًا\n\n\n\\(O(n \\log n)\\)\nترتيب\nأبطأ قليلًا من \\(O(n)\\)، ولكن أسرع بكثير من \\(O(n^2)\\)\n\n\n\\(O(n^2)\\)\nحلقات متداخلة\nالوقت ينمو بسرعة كبيرة عند زيادة n\n\n\n\\(O(2^n)\\)\nتجربة جميع التركيبات\nأسي – ينمو بشكل هائل بسرعة\n\n\n\nكلما كان التعقيد أصغر، كان النمو أسرع.",
    "crumbs": [
      "المرحلة 2",
      "التعقيد الزمني (Time Complexity)"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#زيادة-الرقم",
    "href": "b1/time-complexity.html#زيادة-الرقم",
    "title": "التعقيد الزمني (Time Complexity)",
    "section": "",
    "text": "زيادة الرقم\n\n\n\n\n\nمعطى لك رقم \\(x\\). قم بزيادة \\(x\\) بمقدار 1، ثم اطبعه.",
    "crumbs": [
      "المرحلة 2",
      "التعقيد الزمني (Time Complexity)"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#مجموع-المال",
    "href": "b1/time-complexity.html#مجموع-المال",
    "title": "التعقيد الزمني (Time Complexity)",
    "section": "",
    "text": "مجموع المال\n\n\n\n\n\nمعطى لك \\(n\\) أوراق نقدية قيمتها \\(arr[0]\\) ريال، \\(arr[1]\\) ريال، …، \\(arr[n-1]\\) ريال. كم مجموع الريالات لديك؟",
    "crumbs": [
      "المرحلة 2",
      "التعقيد الزمني (Time Complexity)"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#النسخ",
    "href": "b1/time-complexity.html#النسخ",
    "title": "التعقيد الزمني (Time Complexity)",
    "section": "",
    "text": "النسخ\n\n\n\n\n\nمعطى لك \\(n\\) أوراق نقدية قيمتها \\(arr[0]\\) ريال، \\(arr[1]\\) ريال، …، \\(arr[n-1]\\) ريال. لكل من \\(n\\) أيام، قم بزيادة قيمة كل ورقة بمقدار واحد. بعد اليوم الأول، تصبح الأوراق: \\(arr[0]+1\\), \\(arr[1]+1\\), …، \\(arr[n-1]+1\\). بعد اليوم الثاني: \\(arr[0]+2\\), … وهكذا. بعد \\(n\\) أيام ستكون الأوراق: \\(arr[0]+n\\), …، \\(arr[n-1]+n\\).\nاطبع قيم كل الأوراق لكل يوم من الأيام \\(n\\).",
    "crumbs": [
      "المرحلة 2",
      "التعقيد الزمني (Time Complexity)"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#مقارنة-معدلات-النمو",
    "href": "b1/time-complexity.html#مقارنة-معدلات-النمو",
    "title": "التعقيد الزمني (Time Complexity)",
    "section": "",
    "text": "لنرى كيف تنمو مع زيادة n:\n\n\n\n\n\n\n\n\n\n\n\\(n\\)\n\\(O(1)\\)\n\\(O(\\log n)\\)\n\\(O(n)\\)\n\\(O(n^2)\\)\n\n\n\n\n10\n1\n3\n10\n100\n\n\n100\n1\n7\n100\n10,000\n\n\n1000\n1\n10\n1000\n1,000,000\n\n\n\nحتى لو بدت الفروقات صغيرة عند n صغير، فإنها تتضخم جدًا عند n كبير.",
    "crumbs": [
      "المرحلة 2",
      "التعقيد الزمني (Time Complexity)"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#قاعدة-سريعة",
    "href": "b1/time-complexity.html#قاعدة-سريعة",
    "title": "التعقيد الزمني (Time Complexity)",
    "section": "",
    "text": "\\(n\\)\nالتعقيد الأقصى المقبول\n\n\n\n\n\\(\\leq 10\\)\n\\(O(n!)\\)\n\n\n\\(\\leq 20\\)\nعادة \\(O(2^n)\\) مقبول\n\n\n\\(\\leq 1000\\)\nعادة \\(O(n^2)\\) مقبول\n\n\n\\(\\leq 10^5\\)\n\\(O(n \\log n)\\) أو أفضل\n\n\n\\(\\leq 10^7\\)\n\\(O(n)\\) أو أفضل\n\n\n\\(\\geq 10^9\\)\nفقط \\(O(1)\\) أو \\(O(\\log n)\\)\n\n\n\nهذا يساعدك على تخمين نوع الحل المناسب لحجم مدخلات معين.",
    "crumbs": [
      "المرحلة 2",
      "التعقيد الزمني (Time Complexity)"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#تحسين-الحلول",
    "href": "b1/time-complexity.html#تحسين-الحلول",
    "title": "التعقيد الزمني (Time Complexity)",
    "section": "",
    "text": "أحيانًا ليس واضحًا، لكن يمكنك جعل البرنامج أسرع بالتفكير في حلول أذكى.",
    "crumbs": [
      "المرحلة 2",
      "التعقيد الزمني (Time Complexity)"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#المجموع-البسيط",
    "href": "b1/time-complexity.html#المجموع-البسيط",
    "title": "التعقيد الزمني (Time Complexity)",
    "section": "",
    "text": "المجموع البسيط\n\n\n\n\n\nمعطى لك رقم \\(n\\). أوجد مجموع: \\(-n + (-n+1) + (-n+2) + ... + -1 + 0 + 1 + ... + (n-2) + (n-1) + n\\).",
    "crumbs": [
      "المرحلة 2",
      "التعقيد الزمني (Time Complexity)"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#التعقيد-المكاني-space-complexity",
    "href": "b1/time-complexity.html#التعقيد-المكاني-space-complexity",
    "title": "التعقيد الزمني (Time Complexity)",
    "section": "",
    "text": "أحيانًا نهتم أيضًا بـ كمية الذاكرة التي يستخدمها البرنامج. هذا ما يسمى التعقيد المكاني. الفكرة نفسها: كيف تنمو استخدام الذاكرة مع زيادة حجم المدخلات.\nمثال:\n\nint arr[n];  // مساحة O(n)\nint x;       // مساحة O(1)",
    "crumbs": [
      "المرحلة 2",
      "التعقيد الزمني (Time Complexity)"
    ]
  },
  {
    "objectID": "b1/problems/modular-exponentiation.html",
    "href": "b1/problems/modular-exponentiation.html",
    "title": "",
    "section": "",
    "text": "Modular Exponentiation\n\nCodeforces\neasy\n\n\n\nلديك رقمان \\(n\\) و \\(m\\)، اطبع \\(m \\bmod 2 ^ n\\).\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nبالنسبة لرقمين x و y حيث y &gt; x، فإن x % y == x.\n\n\n\n\nSolution\n\nيمكن أن تؤدي عملية حساب \\(2^n\\) مباشرة إلى تجاوز حدود النوع int . لتجنب ذلك، نستخدم متغيرًا power مهيأً بقيمة مبدئية تساوي 1 ونضربه في 2 بشكل متكرر في حلقة تتكرر \\(n\\) مرة.\nأثناء كل تكرار، إذا أصبح power أكبر من m، يمكننا على الفور استنتاج أن الناتج يجب أن يكون m. إذا اكتملت الحلقة دون أن يتجاوز power قيمة m، يمكننا استنتاج أن لا تجاوز حصل لحدود النوع int ، ويمكن حساب الناتج كـ m % power.\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    int power = 1;\n\n    for (int i = 0; i &lt; n; i++) {\n        power *= 2;\n\n        if (power &gt; m) {\n            cout &lt;&lt; m &lt;&lt; endl;\n            break;\n        }\n    }\n\n    if (power &lt;= m) {\n        cout &lt;&lt; m % power &lt;&lt; endl;\n    }\n}",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Modular Exponentiation"
    ]
  },
  {
    "objectID": "b1/problems/modular-exponentiation.html#modular-exponentiation",
    "href": "b1/problems/modular-exponentiation.html#modular-exponentiation",
    "title": "",
    "section": "",
    "text": "Modular Exponentiation\n\nCodeforces\neasy\n\n\n\nلديك رقمان \\(n\\) و \\(m\\)، اطبع \\(m \\bmod 2 ^ n\\).",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Modular Exponentiation"
    ]
  },
  {
    "objectID": "b1/problems/vanya-and-lanterns.html",
    "href": "b1/problems/vanya-and-lanterns.html",
    "title": "",
    "section": "",
    "text": "Vanya and Lanterns\n\nCodeforces\nmedium\n\n\n\nلديك خط طوله \\(l\\) وعليه \\(n\\) نقطة في المواقع \\(a_1, a_2, \\dots, a_n\\). كل نقطة يمكنها “تغطية” مسافة \\(d\\) إلى اليسار و \\(d\\) إلى اليمين. ابحث عن أصغر \\(d\\) بحيث يتم تغطية كل نقطة على الخط من \\(0\\) إلى \\(l\\) بواسطة على الأقل واحدة من هذه النقاط.\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nلطباعة متغير من نوع double باسم x بصيغة عشرية, يمكنك استخدام: cout &lt;&lt; fixed &lt;&lt; x;\n\n\n\n\nSolution\n\nأولاً، نقوم بترتيب النقاط من اليسار إلى اليمين بحيث يطابق ترتيبها في المصفوفة مواقعها على الخط.\nلضمان تغطية الخط بالكامل، يجب أن تغطي كل نقطة على الأقل نصف المسافة إلى جارتها، والتي هي \\((a_{i+1} - a_i)/2\\) لكل \\(1 \\le i \\le n - 1\\).\nالنقطة الأولى \\(a_1\\) يجب أن تغطي أيضًا المسافة من بداية الخط (0) إلى نفسها، \\(a_1 - 0\\)، والنقطة الأخيرة \\(a_n\\) يجب أن تغطي المسافة من نفسها إلى نهاية الخط، \\(l - a_n\\).\nأصغر \\(d\\) الذي يضمن تغطية الخط بالكامل هو أكبر هذه المسافات كلها.\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    int n, l;\n    cin &gt;&gt; n &gt;&gt; l;\n\n    int a[n];\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; a[i];\n    }\n\n    sort(a, a + n);\n\n    double d = max(a[0] - 0, l - a[n - 1]);\n\n    for (int i = 0; i &lt; n - 1; i++) {\n        d = max(d, (a[i + 1] - a[i]) / 2.0);\n    }\n\n    cout &lt;&lt; fixed &lt;&lt; d &lt;&lt; \"\\n\";\n}",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Vanya and Lanterns"
    ]
  },
  {
    "objectID": "b1/problems/vanya-and-lanterns.html#vanya-and-lanterns",
    "href": "b1/problems/vanya-and-lanterns.html#vanya-and-lanterns",
    "title": "",
    "section": "",
    "text": "Vanya and Lanterns\n\nCodeforces\nmedium\n\n\n\nلديك خط طوله \\(l\\) وعليه \\(n\\) نقطة في المواقع \\(a_1, a_2, \\dots, a_n\\). كل نقطة يمكنها “تغطية” مسافة \\(d\\) إلى اليسار و \\(d\\) إلى اليمين. ابحث عن أصغر \\(d\\) بحيث يتم تغطية كل نقطة على الخط من \\(0\\) إلى \\(l\\) بواسطة على الأقل واحدة من هذه النقاط.",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Vanya and Lanterns"
    ]
  },
  {
    "objectID": "b1/problems/sum-of-two-values.html",
    "href": "b1/problems/sum-of-two-values.html",
    "title": "",
    "section": "",
    "text": "Sum of Two Values\n\nCSES\neasy\n\n\n\nيُعطى لك مصفوفة من \\(n\\) أعداد صحيحة، ومهمتك هي إيجاد موقعين مختلفين \\(i \\ne j\\) بحيث:\n\n\\(a_i + a_j = x\\).\n\nإذا وُجدت عدة أزواج صالحة، يمكنك إخراج أي زوج منها. إذا لم يوجد أي زوج يحقق الشرط، فاطبع IMPOSSIBLE.\nالقيود:\n\n\\(1 \\le n \\le 2 \\cdot 10^5\\)\n\\(1 \\le x, a_i \\le 10^9\\)\n\nالإدخال:\n\nالسطر الأول: عددان صحيحان \\(n\\) و \\(x\\) — حجم المصفوفة والمجموع المطلوب.\nالسطر الثاني: \\(n\\) عددًا \\(a_1, a_2, \\dots, a_n\\) — قيم المصفوفة.\n\nالمخرجات:\n\nإمّا موقعان (1-based) بشكل i j بحيث \\(a_i + a_j = x\\) و \\(i \\ne j\\)،\nأو IMPOSSIBLE إذا لم يوجد أي زوج يحقق الشرط.\n\nمثال:\nالإدخال:\n4 8\n2 7 5 1\nالمخرجات:\n2 4\n(أحد الأزواج الصحيحة هو \\(7 + 1 = 8\\))\n\n\n\n\n\nSolution\n\nنريد إيجاد عددين مجموعهما \\(x\\) في زمن يقارب \\(O(n \\log n)\\).\nطريقة مباشرة هي استخدام خريطة (map) لتسجيل القيم التي رأيناها حتى الآن:\n\nنمر على عناصر المصفوفة من اليسار إلى اليمين.\nعند القيمة الحالية \\(a_i\\):\n\nالمتمّم المطلوب هو \\(y = x - a_i\\).\nإذا كنا قد رأينا قيمة تساوي y من قبل، يمكننا إخراج الزوج فورًا.\nوإلا نخزّن القيمة الحالية مع موقعها في الخريطة، ونكمل.\n\n\nبما أن كل عنصر يُعالج مرة واحدة، وكل عملية على الخريطة تكلف تقريبًا \\(O(\\log n)\\)، فإن الخوارزمية كلها تعمل في زمن \\(O(n \\log n)\\).\nإذا انتهت الحلقة دون إيجاد أي زوج، فالجواب هو IMPOSSIBLE.\n\n\n\n\n\n\nNoteفكرة الخريطة (الاقتران أثناء المرور)\n\n\n\nلكل موقع \\(i\\) من \\(1\\) إلى \\(n\\):\n\nنعرّف need = x - a[i].\nإذا كانت need موجودة في الخريطة مع موقع ما j، عندها:\n\nوجدنا حلًا: a[i] + a[j] = x.\n\nوإلّا نخزّن a[i] مع موقعه i في الخريطة ونواصل.\n\nيجب أن نحتفظ بالمواقع الأصلية ونطبعها كنظام ترقيم يبدأ من 1.\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    long long x;\n    cin &gt;&gt; n &gt;&gt; x;\n\n    vector&lt;long long&gt; a(n);\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; a[i];\n    }\n\n    // value -&gt; index (1-based)\n    map&lt;long long, int&gt; pos;\n\n    for (int i = 0; i &lt; n; i++) {\n        long long need = x - a[i];\n\n        auto it = pos.find(need);\n        if (it != pos.end()) {\n            // found a pair: a[i] + need = x\n            cout &lt;&lt; it-&gt;second &lt;&lt; \" \" &lt;&lt; (i + 1) &lt;&lt; \"\\n\";\n            return 0;\n        }\n\n        // store current value with its 1-based index\n        pos[a[i]] = i + 1;\n    }\n\n    cout &lt;&lt; \"IMPOSSIBLE\\n\";\n    return 0;\n}\n\n\n\n\n\n\n\n\nCautionنقاط يجب الانتباه لها\n\n\n\n\nمواقع مختلفة: استخدام خريطة للقيم السابقة فقط يضمن تلقائيًا أن \\(i \\ne j\\).\nالمؤشرات ابتداءً من 1: منصة CSES تتوقع مواقع بدءًا من 1، لذا علينا طباعة i + 1.\nإذا تكررت القيم، فستحتفظ الخريطة بآخر موقع مُسجَّل لتلك القيمة، وهذا لا يسبب مشكلة لأن أي زوج صالح مقبول.",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Sum Of Two Values"
    ]
  },
  {
    "objectID": "b1/problems/sum-of-two-values.html#sum-of-two-values",
    "href": "b1/problems/sum-of-two-values.html#sum-of-two-values",
    "title": "",
    "section": "",
    "text": "Sum of Two Values\n\nCSES\neasy\n\n\n\nيُعطى لك مصفوفة من \\(n\\) أعداد صحيحة، ومهمتك هي إيجاد موقعين مختلفين \\(i \\ne j\\) بحيث:\n\n\\(a_i + a_j = x\\).\n\nإذا وُجدت عدة أزواج صالحة، يمكنك إخراج أي زوج منها. إذا لم يوجد أي زوج يحقق الشرط، فاطبع IMPOSSIBLE.\nالقيود:\n\n\\(1 \\le n \\le 2 \\cdot 10^5\\)\n\\(1 \\le x, a_i \\le 10^9\\)\n\nالإدخال:\n\nالسطر الأول: عددان صحيحان \\(n\\) و \\(x\\) — حجم المصفوفة والمجموع المطلوب.\nالسطر الثاني: \\(n\\) عددًا \\(a_1, a_2, \\dots, a_n\\) — قيم المصفوفة.\n\nالمخرجات:\n\nإمّا موقعان (1-based) بشكل i j بحيث \\(a_i + a_j = x\\) و \\(i \\ne j\\)،\nأو IMPOSSIBLE إذا لم يوجد أي زوج يحقق الشرط.\n\nمثال:\nالإدخال:\n4 8\n2 7 5 1\nالمخرجات:\n2 4\n(أحد الأزواج الصحيحة هو \\(7 + 1 = 8\\))",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Sum Of Two Values"
    ]
  },
  {
    "objectID": "b1/problems/stick-lengths.html",
    "href": "b1/problems/stick-lengths.html",
    "title": "",
    "section": "",
    "text": "Stick Lengths\n\nCSES\nmedium\n\n\n\nيُعطى لك \\(n\\) من العصي بأطوال \\(p_1, p_2, \\dots, p_n\\). تريد جعل كل العصي بنفس الطول.\nيمكنك زيادة أو إنقاص طول كل عصا. تغيير طول عصا من \\(a\\) إلى \\(b\\) يكلّف \\(|a-b|\\).\nالمطلوب: إيجاد أقل كلفة كلية ممكنة لجعل جميع العصي بنفس الطول.\nالقيود:\n\n\\(1 \\le n \\le 2 \\cdot 10^5\\)\n\\(1 \\le p_i \\le 10^9\\)\n\nالإدخال:\n\nالسطر الأول: عدد صحيح \\(n\\) — عدد العصي.\nالسطر الثاني: \\(n\\) عددًا \\(p_1, p_2, \\dots, p_n\\) — أطوال العصي.\n\nالمخرجات:\n\nعدد صحيح واحد — أقل كلفة كلية ممكنة.\n\nمثال:\nالإدخال:\n5\n2 3 1 5 2\nالمخرجات:\n5",
    "crumbs": [
      "المرحلة 2",
      "Practice Problems",
      "Stick Lengths"
    ]
  },
  {
    "objectID": "b1/problems/stick-lengths.html#stick-lengths",
    "href": "b1/problems/stick-lengths.html#stick-lengths",
    "title": "",
    "section": "",
    "text": "Stick Lengths\n\nCSES\nmedium\n\n\n\nيُعطى لك \\(n\\) من العصي بأطوال \\(p_1, p_2, \\dots, p_n\\). تريد جعل كل العصي بنفس الطول.\nيمكنك زيادة أو إنقاص طول كل عصا. تغيير طول عصا من \\(a\\) إلى \\(b\\) يكلّف \\(|a-b|\\).\nالمطلوب: إيجاد أقل كلفة كلية ممكنة لجعل جميع العصي بنفس الطول.\nالقيود:\n\n\\(1 \\le n \\le 2 \\cdot 10^5\\)\n\\(1 \\le p_i \\le 10^9\\)\n\nالإدخال:\n\nالسطر الأول: عدد صحيح \\(n\\) — عدد العصي.\nالسطر الثاني: \\(n\\) عددًا \\(p_1, p_2, \\dots, p_n\\) — أطوال العصي.\n\nالمخرجات:\n\nعدد صحيح واحد — أقل كلفة كلية ممكنة.\n\nمثال:\nالإدخال:\n5\n2 3 1 5 2\nالمخرجات:\n5",
    "crumbs": [
      "المرحلة 2",
      "Practice Problems",
      "Stick Lengths"
    ]
  },
  {
    "objectID": "b1/problems/bit-strings.html",
    "href": "b1/problems/bit-strings.html",
    "title": "",
    "section": "",
    "text": "Bit Strings\n\nCSES\neasy\n\n\n\nمهمتك هي حساب عدد سلاسل البت بطول \\(n\\).\nسلسلة البت هي تسلسل بطول \\(n\\) ، كل واحد منها إما 0 أو 1.\nعلى سبيل المثال، إذا كان \\(n = 3\\)، فإن سلاسل البت هي [000, 001, 010, 011, 100, 101, 110, 111]، أي أن عددها \\(8\\).\nالإدخال:\n\nعدد صحيح واحد \\(n\\).\n\nالمخرجات:\n\nاطبع العدد الكلي لسلاسل البت بطول \\(n\\)، بتطبيق باقي القسمة على \\(10^9 + 7\\).\n\nالقيود:\n\n\\(1 \\le n \\le 10^6\\)\n\nمثال:\nالإدخال:\n3\nالمخرجات:\n8\n\n\n\n\n\nSolution\n\nكل خانة من خانات السلسلة ذات الطول \\(n\\) لديها خياران مستقلان: 0 أو 1. لذلك، حسب قاعدة الضرب، يكون عدد سلاسل البت مساويًا لـ \\(2^n\\). علينا طباعة هذه القيمة بتطبيق باقي القسمة على \\(M = 10^9 + 7\\).\nيمكننا حساب \\(2^n \\bmod M\\) تدريجيًا باستخدام حلقة بسيطة:\n\nنبدأ بـ ans = 1.\nنكرر العملية \\(n\\) مرة:\n\\(\\text{ans} = (2 \\cdot \\text{ans}) \\bmod M.\\)\n\nبعد \\(n\\) تكرارات، ستكون قيمة ans مساوية لـ \\(2^n \\bmod M\\).\nتعمل هذه الطريقة في زمن \\(O(n)\\). وبما أن \\(n \\le 10^6\\)، فإن حلقة بعدد تكرارات يصل إلى \\(10^6\\) مقبولة ضمن حدود الزمن.\nفكرة متسلسلة:\n\nInitialize ans = 1\nfor i = 1 to n:\n    ans = (ans * 2) % M\n    output ans\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nconst long long MOD = 1000000007LL;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    long long n;\n    cin &gt;&gt; n;\n\n    long long ans = 1;\n    for (long long i = 0; i &lt; n; ++i) {\n        ans = (ans * 2) % MOD;\n    }\n\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n    return 0;\n}\n\n\n\n\n\n\n\n\nCautionملاحظة حول الأسّيات المعيارية (خيار بديل)\n\n\n\nفي هذه المسألة، حلقة بزمن \\(O(n)\\) كافية وسريعة بما أن \\(n\\) ليس كبيرًا جدًا.\nفي مسائل أخرى حيث يمكن أن تكون قيمة \\(n\\) كبيرة جدًا (مثلًا حتى \\(10^{18}\\))، لا يمكننا تكرار الحلقة \\(n\\) مرة.\nفي تلك الحالات، ينبغي استخدام خوارزمية الأسّ السريع (الأسّ الثنائي) لحساب \\(2^n \\bmod M\\) بزمن \\(O(\\log n)\\) بدلًا من \\(O(n)\\).",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Bit Strings"
    ]
  },
  {
    "objectID": "b1/problems/bit-strings.html#bit-strings",
    "href": "b1/problems/bit-strings.html#bit-strings",
    "title": "",
    "section": "",
    "text": "Bit Strings\n\nCSES\neasy\n\n\n\nمهمتك هي حساب عدد سلاسل البت بطول \\(n\\).\nسلسلة البت هي تسلسل بطول \\(n\\) ، كل واحد منها إما 0 أو 1.\nعلى سبيل المثال، إذا كان \\(n = 3\\)، فإن سلاسل البت هي [000, 001, 010, 011, 100, 101, 110, 111]، أي أن عددها \\(8\\).\nالإدخال:\n\nعدد صحيح واحد \\(n\\).\n\nالمخرجات:\n\nاطبع العدد الكلي لسلاسل البت بطول \\(n\\)، بتطبيق باقي القسمة على \\(10^9 + 7\\).\n\nالقيود:\n\n\\(1 \\le n \\le 10^6\\)\n\nمثال:\nالإدخال:\n3\nالمخرجات:\n8",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Bit Strings"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html",
    "href": "b1/cpp/sets.html",
    "title": "المجموعات (Sets)",
    "section": "",
    "text": "set في C++ هو حاوية لعناصر من نفس النوع ويحقق الخصائص التالية:\n\nيحتوي على عناصر فريدة فقط\nيكون دائمًا مرتبًا\nيسمح بالإدراج والحذف والاستعلام بكفاءة\n\n\n\n\n\n\n\nCaution\n\n\n\nيمكن أن يحتوي set فقط على أنواع يمكن مقارنتها باستخدام معامل &lt;.\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main () {\n\n    set&lt;int&gt; my_int_set;\n\n    set&lt;double&gt; my_double_set;\n\n    set&lt;string&gt; my_string_set = {\"abc\", \"def\", \"ghi\"};\n\n}\n\n\n\n\nتعيد الدالة size عدد العناصر في الحاوية.\n\nset&lt;double&gt; s = {1, 2, 3.2, 32.0 / 10.0};\n\ncout &lt;&lt; s.size(); // الناتج 3 لأن 3.1 = 31.0/10.0\n\n\n\n\nتضيف الدالة insert عنصرًا إلى الحاوية فقط إذا لم يكن موجودًا مسبقًا وتحافظ على ترتيب العناصر في المجموعة.\n\nset&lt;int&gt; s = {1, 3};\n\ns.insert(2); // الآن s = {1, 2, 3} // ليس {1, 3, 2}\n\ns.insert(3); // لا يتغير s\n\n\n\n\nتزيل الدالة erase عنصرًا من الحاوية فقط إذا كان موجودًا مسبقًا.\n\nset&lt;string&gt; s = {\"abc\", \"def\"};\n\ns.erase(\"xyz\"); // لا يتغير s لأنه لا يحتوي على \"xyz\"\n\ns.erase(\"abc def\"); // لا يتغير s لنفس السبب\n\ns.erase(\"abc\"); // الآن s = {\"def\"}\n\n\n\n\n\n\n\nNoneتحدي (Challenge)\n\n\n\nباستخدام الدوال المذكورة أعلاه فقط، هل يمكنك التحقق مما إذا كانت المجموعة تحتوي على قيمة محددة؟\n\n\n\n\n\n\n\n\nTipالحل (Solution)\n\n\n\n\n\nأولًا، سنتحقق من حجم المجموعة، لنسمه \\(S_1\\). بعد ذلك، سندرج هذه القيمة في المجموعة ونتحقق من الحجم مرة أخرى، لنسم الحجم الجديد \\(S_2\\). إذا كان \\(S_1 = S_2\\) فهذا يعني أن المجموعة تحتوي على القيمة، وإلا فهي لم تحتوي عليها ويجب إزالتها.\n\n\n\n\n\n\nتعيد الدالة count عدد مرات ظهور القيمة في الحاوية. بما أن جميع العناصر مميزة فإنها تعيد 1 إذا كانت موجودة و 0 إذا لم تكن موجودة.\n\nset&lt;int&gt; s = {1, 2, 3};\n\ncout &lt;&lt; s.count(2) &lt;&lt; '\\n'; // الناتج: 1\ns.insert(2);\ncout &lt;&lt; s.count(2) &lt;&lt; '\\n'; // الناتج: 1 // لأن المجموعات لا تحتوي على تكرارات\ns.erase(2);\ncout &lt;&lt; s.count(2) &lt;&lt; '\\n'; // الناتج: 0\n\n\n\n\n\n\n\nWarning\n\n\n\nعلى الرغم من أن set له ترتيب محدد، لا يمكننا الوصول إلى عنصر محدد باستخدام معامل [].\nتابع القراءة لمعرفة كيفية الوصول إلى العناصر في set.\n\n\n\n\n\nللتكرار على قيم set نستخدم حلقة for بنطاق (range-based for loop) كما يلي:\n\nset&lt;string&gt; my_string_set = {\"abc\", \"def\", \"ghi\"};\n\nfor (string s : my_string_set) {\n    cout &lt;&lt; s &lt;&lt; '\\n';\n}\n\n\nالناتج:\nabc\ndef\nghi\n\n\n\n\n\n\n\nNoneتحدي (Challenge)\n\n\n\nما هو ناتج البرنامج التالي:\n\nset&lt;int&gt; s = {3, 2, 1};\n\nfor (int i : s) {\n    cout &lt;&lt; i &lt;&lt; ' ';\n}\n\n\n\n\n\n\n\n\n\nTipالحل (Solution)\n\n\n\n\n\nالناتج هو 1 2 3 لأن sets تكون دائمًا مرتبة.",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "المجموعات (Sets)"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html#الإعلان",
    "href": "b1/cpp/sets.html#الإعلان",
    "title": "المجموعات (Sets)",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main () {\n\n    set&lt;int&gt; my_int_set;\n\n    set&lt;double&gt; my_double_set;\n\n    set&lt;string&gt; my_string_set = {\"abc\", \"def\", \"ghi\"};\n\n}",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "المجموعات (Sets)"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html#الحجم-size",
    "href": "b1/cpp/sets.html#الحجم-size",
    "title": "المجموعات (Sets)",
    "section": "",
    "text": "تعيد الدالة size عدد العناصر في الحاوية.\n\nset&lt;double&gt; s = {1, 2, 3.2, 32.0 / 10.0};\n\ncout &lt;&lt; s.size(); // الناتج 3 لأن 3.1 = 31.0/10.0",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "المجموعات (Sets)"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html#الإدراج-insert",
    "href": "b1/cpp/sets.html#الإدراج-insert",
    "title": "المجموعات (Sets)",
    "section": "",
    "text": "تضيف الدالة insert عنصرًا إلى الحاوية فقط إذا لم يكن موجودًا مسبقًا وتحافظ على ترتيب العناصر في المجموعة.\n\nset&lt;int&gt; s = {1, 3};\n\ns.insert(2); // الآن s = {1, 2, 3} // ليس {1, 3, 2}\n\ns.insert(3); // لا يتغير s",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "المجموعات (Sets)"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html#الحذف-erase",
    "href": "b1/cpp/sets.html#الحذف-erase",
    "title": "المجموعات (Sets)",
    "section": "",
    "text": "تزيل الدالة erase عنصرًا من الحاوية فقط إذا كان موجودًا مسبقًا.\n\nset&lt;string&gt; s = {\"abc\", \"def\"};\n\ns.erase(\"xyz\"); // لا يتغير s لأنه لا يحتوي على \"xyz\"\n\ns.erase(\"abc def\"); // لا يتغير s لنفس السبب\n\ns.erase(\"abc\"); // الآن s = {\"def\"}\n\n\n\n\n\n\n\nNoneتحدي (Challenge)\n\n\n\nباستخدام الدوال المذكورة أعلاه فقط، هل يمكنك التحقق مما إذا كانت المجموعة تحتوي على قيمة محددة؟\n\n\n\n\n\n\n\n\nTipالحل (Solution)\n\n\n\n\n\nأولًا، سنتحقق من حجم المجموعة، لنسمه \\(S_1\\). بعد ذلك، سندرج هذه القيمة في المجموعة ونتحقق من الحجم مرة أخرى، لنسم الحجم الجديد \\(S_2\\). إذا كان \\(S_1 = S_2\\) فهذا يعني أن المجموعة تحتوي على القيمة، وإلا فهي لم تحتوي عليها ويجب إزالتها.",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "المجموعات (Sets)"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html#العد-count",
    "href": "b1/cpp/sets.html#العد-count",
    "title": "المجموعات (Sets)",
    "section": "",
    "text": "تعيد الدالة count عدد مرات ظهور القيمة في الحاوية. بما أن جميع العناصر مميزة فإنها تعيد 1 إذا كانت موجودة و 0 إذا لم تكن موجودة.\n\nset&lt;int&gt; s = {1, 2, 3};\n\ncout &lt;&lt; s.count(2) &lt;&lt; '\\n'; // الناتج: 1\ns.insert(2);\ncout &lt;&lt; s.count(2) &lt;&lt; '\\n'; // الناتج: 1 // لأن المجموعات لا تحتوي على تكرارات\ns.erase(2);\ncout &lt;&lt; s.count(2) &lt;&lt; '\\n'; // الناتج: 0\n\n\n\n\n\n\n\nWarning\n\n\n\nعلى الرغم من أن set له ترتيب محدد، لا يمكننا الوصول إلى عنصر محدد باستخدام معامل [].\nتابع القراءة لمعرفة كيفية الوصول إلى العناصر في set.",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "المجموعات (Sets)"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html#التكرار-looping",
    "href": "b1/cpp/sets.html#التكرار-looping",
    "title": "المجموعات (Sets)",
    "section": "",
    "text": "للتكرار على قيم set نستخدم حلقة for بنطاق (range-based for loop) كما يلي:\n\nset&lt;string&gt; my_string_set = {\"abc\", \"def\", \"ghi\"};\n\nfor (string s : my_string_set) {\n    cout &lt;&lt; s &lt;&lt; '\\n';\n}\n\n\nالناتج:\nabc\ndef\nghi\n\n\n\n\n\n\n\nNoneتحدي (Challenge)\n\n\n\nما هو ناتج البرنامج التالي:\n\nset&lt;int&gt; s = {3, 2, 1};\n\nfor (int i : s) {\n    cout &lt;&lt; i &lt;&lt; ' ';\n}\n\n\n\n\n\n\n\n\n\nTipالحل (Solution)\n\n\n\n\n\nالناتج هو 1 2 3 لأن sets تكون دائمًا مرتبة.",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "المجموعات (Sets)"
    ]
  },
  {
    "objectID": "b0/debugging/debugging.html",
    "href": "b0/debugging/debugging.html",
    "title": "تصحيح الأخطاء",
    "section": "",
    "text": "من الشائع جدًا أثناء حل المسائل البرمجية أن لا يعمل البرنامج كما هو متوقع تمامًا. تُعرف عملية اكتشاف سبب الخطأ وإصلاحه باسم تصحيح الأخطاء (debugging). لا توجد طريقة واحدة مثالية لتصحيح الأخطاء، ولكن هناك تقنيات تساعد في اكتشاف الخطأ بسرعة أكبر.\n\n\nكلما كانت البرنامج أنظف وأكثر تنظيمًا، قلَّ احتمال وقوع الأخطاء. تأكد من تسمية المتغيرات بشكل واضح حتى لا تخلط بينها. كما يُستحسن استخدام المسافات والهوامش (indentation) المناسبة لتحسين قابلية القراءة، خاصة أثناء تصحيح الأخطاء لاحقًا.\nبرنامج سيئ:\n\n#include&lt;iostream&gt;\n#include&lt;cmath&gt;\n#include&lt;cassert&gt;\n#include&lt;iomanip&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint main () {\nint a,b;\ncin&gt;&gt;a&gt;&gt;b;\nint n[a];\nfor(int m=a-1;m&gt;-1;m-=1){\ncin&gt;&gt;n[m];\n}\n   cout &lt;&lt; n[b];}\n\nبرنامج جيد:\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n, m;                       \n    cin &gt;&gt; n &gt;&gt; m;\n\n    int a[n];\n\n    for (int i = n - 1 ; i &gt;= 0 ; i--) { // إدخال المصفوفة من اليمين إلى اليسار\n        cin &gt;&gt; a[i];                \n    }\n\n    cout &lt;&lt; a[m];\n}                   \n\n\nأضف المكتبات اللازمة فقط، وتجنب استخدام القوالب الضخمة.\nاستخدم n و m للأحجام أو العدّادات — فهذا هو العُرف الشائع في المسائل البرمجية مما يجعل البرنامج أكثر وضوحًا.\nاستخدم i و j و k كمتغيرات تكرار — وهي الأسماء القياسية في الحلقات التكرارية.\nاستخدم هوامش موحّدة: كل مستوى من التداخل يُزاد بمقدار تبويب واحد (أو 4 مسافات).\nأزل الهوامش عند إغلاق الكتل البرمجية — فهذا يساعدك بصريًا على معرفة مكان انتهاء الحلقات أو الشروط.\nأضف التعليقات عند الحاجة لتوضيح الهدف من البرنامج ومقارنتها بما فعليًا يحدث أثناء التنفيذ.\n\n\n\n\nالفكرة هي استخدام cout لتتبّع قيم المتغيرات. فإذا لاحظنا أن متغيرًا يحمل قيمة غير متوقعة، فقد يعطينا ذلك موقعًا على سبب المشكلة.\nافترض أننا نحاول طباعة مصفوفة بالعكس:\n\nint a[5] = {1, 2, 3, 4, 5};\n\nfor (int i = 4 ; i &gt;= 0 ; i++) {\n    cout &lt;&lt; a[i] &lt;&lt; ' ';\n}\n\nبعد تشغيل البرنامج نحصل على شيء مثل:\n\nOutput:\n5 0 -1150222592 1577706123 1165962832 32767 126...\n\nوهذا لا يبدو صحيحًا…\nلنطبع قيمة i قبل كل عملية طباعة لمعرفة أي موقع يتم طباعته فعليًا.\n\nint a[5] = {1, 2, 3, 4, 5};\n\nfor (int i = 4 ; i &gt;= 0 ; i++) {\n    cout &lt;&lt; \"index 'i' is: \" &lt;&lt; i &lt;&lt; '\\n';\n    cout &lt;&lt; a[i] &lt;&lt; '\\n'; // غيّرنا إلى \\n لتصبح المخرجات أكثر وضوحًا\n}\n\n\nOutput:\nindex 'i' is: 4\n5\nindex 'i' is: 5\n0\nindex 'i' is: 6\n1781710592\nindex 'i' is: 7\n1056066187...\n\nكنا نتوقع أن تكون قيم i هي 4, 3, 2, 1, 0، لكنها بدلاً من ذلك تزداد. السبب أن تعبير التحديث في حلقة for يحتوي على زيادة (i++) بدلًا من نقصان (i--)، وهو الخطأ البرمجي.\n\nint a[5] = {1, 2, 3, 4, 5};\n\nfor (int i = 4 ; i &gt;= 0 ; i--) {\n    cout &lt;&lt; a[i] &lt;&lt; ' ';\n}\n\n\nOutput:\n5 4 3 2 1\n\n\n\n\nتستقبل الدالة assert تعبيرًا منطقيًا (boolean expression) كوسيط، فإذا كانت نتيجته false ينتهي البرنامج مباشرة. وفي معظم المنصات البرمجية يظهر حكم Runtime Error عند هذا النوع من الإنهاء. تُستخدم هذه الدالة عادةً عند وجود عدة فروع في البرنامج ويصدر البرنامج حكمًا آخر غير متوقع.\nلاستخدام هذه الدالة يجب تضمين مكتبة cassert.\nعلى سبيل المثال، لدينا مسألة تنص على: أعط عددًا صحيحًا \\(N\\)، وقيّم مجموع \\(1 + 2 + ... + N\\).\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint fast (int n) {\n    return n * (n + 1) / 2;\n}\n\nint main () {\n    int n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; fast(n);\n}\n\nعند إرسال هذا البرنامج نحصل على Wrong Answer. قد يكون لدينا حل آخر نثق بصحته لكنه أبطأ، مثل الحل الذي يجمع القيم باستخدام حلقة.\nيمكننا عندها استخدام assert للتحقق مما إذا كان الناتج من slow وfast متطابقًا.\n\n#include&lt;iostream&gt;\n#include&lt;cassert&gt; \n\nusing namespace std;\n\nint slow (int n) {\n    int ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) ans += i;\n    return ans;\n}\n\nint fast (int n) {\n    return n * (n + 1) / 2;\n}\n\nint main () {\n    int n;\n    cin &gt;&gt; n;\n\n    assert(fast(n) == slow(n));\n\n    cout &lt;&lt; fast(n);\n}\n\nلذلك هناك احتمالان فقط: إما نحصل على Time Limit Exceeded مما يعني أننا نجحنا في الاختبارات الصغيرة، أو نحصل على Runtime Error مما يعني أن النتيجتين مختلفتان.\nإذا حصلنا على Runtime Error يمكننا مراجعة الصيغة والتأكد من صحتها، أما إذا حصلنا على Time Limit Exceeded فيمكننا استنتاج أن الصيغة تفشل عند الأعداد الكبيرة — وهو ما قد يدل على مشكلة تجاوز (overflow).\n\n\n\n\n\n\nتأكد أن تنسيق المخرجات يطابق تمامًا نص المسألة (بدون مسافات أو أسطر إضافية).\nاحذف جميع طباعات التصحيح قبل تسليم الحل.\n\n\n\n\n\nتعامل مع جميع الحالات الحدّية مثل N = 0, N = 1, الإدخال الفارغ، وأكبر القيم الممكنة.\nفي المسائل ذات عدة حالات اختبار، أعد تهيئة جميع المتغيرات والهياكل بين كل حالة وأخرى.\n\nالأخطاء غالبًا تظهر عندما تتبع حالة صغيرة حالة اختبار كبيرة.\n\n\n\n\n\n\nأعد قراءة نص المسألة بعناية.\nأعد قراءة شيفرتك — من الأخطاء الشائعة الخلط بين N و M أو بين i و j.\nراقب وجود متغيرات مظللة (shadowed) أو غير مستخدمة أو غير مهيّأة.\n\n\n\n\n\nالمتغيرات غير المهيّأة.\nالوصول إلى مصفوفة أو متّجه خارج النطاق.\nغياب جملة return في دوال غير void.\nتجاوز السعة للأعداد الموقعة (استخدم long long).\nإزاحة البتات (bit-shifting) بمقدار ≥ 32 على أعداد 32-بت.\n\n\n\n\n\nتحقق من وجود NaN (مثل ناتج sqrt لعدد سالب).\nاستخدم long double عند الحاجة إلى دقة أعلى.\nطابق عدد الخانات المطلوبة في المخرجات باستخدام setprecision().\n\n\n\n\n\nنفّذ اختبارات يدوية على أمثلة بسيطة.\nاختبر التحمل (stress test) بمقارنة ناتج الحل السريع مع حل بطيء يعتمد على القوة الغاشمة (brute-force).\n\n\n\n\n\nهل هناك سلوك غير معرّف؟\nهل هناك استدعاء لـ assert قد يفشل؟\nهل هناك قسمة على الصفر (أو باقي قسمة على صفر)؟\nهل توجد استدعاءات دالّية لا نهائية (recursion)؟\nهل هناك موقعات أو مكرّرات (iterators) غير صالحة؟\nهل البرنامج يستهلك ذاكرة زائدة عن الحد؟\n\n\n\n\n\nهل توجد حلقات لا نهائية؟\nما تعقيد خوارزميتك؟\nهل أزلت جميع طباعات التصحيح قبل التسليم (مثل الطباعة الزائدة إلى المخرجات)؟\nهل هناك نسخ غير ضروري للبيانات؟ فكّر في تمرير المتغيرات بالإشارة (by reference).\nجرّب استبدال المتّجهات بالمصفوفات إن أمكن.\n\n\n\n\n\nأعد كتابة الحل من البداية.\nاحفظ نسخة من الحل الأصلي، فقد تُدخل أخطاء جديدة أثناء إعادة الكتابة."
  },
  {
    "objectID": "b0/debugging/debugging.html#أسلوب-كتابة-برنامج",
    "href": "b0/debugging/debugging.html#أسلوب-كتابة-برنامج",
    "title": "تصحيح الأخطاء",
    "section": "",
    "text": "كلما كانت البرنامج أنظف وأكثر تنظيمًا، قلَّ احتمال وقوع الأخطاء. تأكد من تسمية المتغيرات بشكل واضح حتى لا تخلط بينها. كما يُستحسن استخدام المسافات والهوامش (indentation) المناسبة لتحسين قابلية القراءة، خاصة أثناء تصحيح الأخطاء لاحقًا.\nبرنامج سيئ:\n\n#include&lt;iostream&gt;\n#include&lt;cmath&gt;\n#include&lt;cassert&gt;\n#include&lt;iomanip&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint main () {\nint a,b;\ncin&gt;&gt;a&gt;&gt;b;\nint n[a];\nfor(int m=a-1;m&gt;-1;m-=1){\ncin&gt;&gt;n[m];\n}\n   cout &lt;&lt; n[b];}\n\nبرنامج جيد:\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n, m;                       \n    cin &gt;&gt; n &gt;&gt; m;\n\n    int a[n];\n\n    for (int i = n - 1 ; i &gt;= 0 ; i--) { // إدخال المصفوفة من اليمين إلى اليسار\n        cin &gt;&gt; a[i];                \n    }\n\n    cout &lt;&lt; a[m];\n}                   \n\n\nأضف المكتبات اللازمة فقط، وتجنب استخدام القوالب الضخمة.\nاستخدم n و m للأحجام أو العدّادات — فهذا هو العُرف الشائع في المسائل البرمجية مما يجعل البرنامج أكثر وضوحًا.\nاستخدم i و j و k كمتغيرات تكرار — وهي الأسماء القياسية في الحلقات التكرارية.\nاستخدم هوامش موحّدة: كل مستوى من التداخل يُزاد بمقدار تبويب واحد (أو 4 مسافات).\nأزل الهوامش عند إغلاق الكتل البرمجية — فهذا يساعدك بصريًا على معرفة مكان انتهاء الحلقات أو الشروط.\nأضف التعليقات عند الحاجة لتوضيح الهدف من البرنامج ومقارنتها بما فعليًا يحدث أثناء التنفيذ."
  },
  {
    "objectID": "b0/debugging/debugging.html#الطباعة",
    "href": "b0/debugging/debugging.html#الطباعة",
    "title": "تصحيح الأخطاء",
    "section": "",
    "text": "الفكرة هي استخدام cout لتتبّع قيم المتغيرات. فإذا لاحظنا أن متغيرًا يحمل قيمة غير متوقعة، فقد يعطينا ذلك موقعًا على سبب المشكلة.\nافترض أننا نحاول طباعة مصفوفة بالعكس:\n\nint a[5] = {1, 2, 3, 4, 5};\n\nfor (int i = 4 ; i &gt;= 0 ; i++) {\n    cout &lt;&lt; a[i] &lt;&lt; ' ';\n}\n\nبعد تشغيل البرنامج نحصل على شيء مثل:\n\nOutput:\n5 0 -1150222592 1577706123 1165962832 32767 126...\n\nوهذا لا يبدو صحيحًا…\nلنطبع قيمة i قبل كل عملية طباعة لمعرفة أي موقع يتم طباعته فعليًا.\n\nint a[5] = {1, 2, 3, 4, 5};\n\nfor (int i = 4 ; i &gt;= 0 ; i++) {\n    cout &lt;&lt; \"index 'i' is: \" &lt;&lt; i &lt;&lt; '\\n';\n    cout &lt;&lt; a[i] &lt;&lt; '\\n'; // غيّرنا إلى \\n لتصبح المخرجات أكثر وضوحًا\n}\n\n\nOutput:\nindex 'i' is: 4\n5\nindex 'i' is: 5\n0\nindex 'i' is: 6\n1781710592\nindex 'i' is: 7\n1056066187...\n\nكنا نتوقع أن تكون قيم i هي 4, 3, 2, 1, 0، لكنها بدلاً من ذلك تزداد. السبب أن تعبير التحديث في حلقة for يحتوي على زيادة (i++) بدلًا من نقصان (i--)، وهو الخطأ البرمجي.\n\nint a[5] = {1, 2, 3, 4, 5};\n\nfor (int i = 4 ; i &gt;= 0 ; i--) {\n    cout &lt;&lt; a[i] &lt;&lt; ' ';\n}\n\n\nOutput:\n5 4 3 2 1"
  },
  {
    "objectID": "b0/debugging/debugging.html#الدالة-assert",
    "href": "b0/debugging/debugging.html#الدالة-assert",
    "title": "تصحيح الأخطاء",
    "section": "",
    "text": "تستقبل الدالة assert تعبيرًا منطقيًا (boolean expression) كوسيط، فإذا كانت نتيجته false ينتهي البرنامج مباشرة. وفي معظم المنصات البرمجية يظهر حكم Runtime Error عند هذا النوع من الإنهاء. تُستخدم هذه الدالة عادةً عند وجود عدة فروع في البرنامج ويصدر البرنامج حكمًا آخر غير متوقع.\nلاستخدام هذه الدالة يجب تضمين مكتبة cassert.\nعلى سبيل المثال، لدينا مسألة تنص على: أعط عددًا صحيحًا \\(N\\)، وقيّم مجموع \\(1 + 2 + ... + N\\).\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint fast (int n) {\n    return n * (n + 1) / 2;\n}\n\nint main () {\n    int n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; fast(n);\n}\n\nعند إرسال هذا البرنامج نحصل على Wrong Answer. قد يكون لدينا حل آخر نثق بصحته لكنه أبطأ، مثل الحل الذي يجمع القيم باستخدام حلقة.\nيمكننا عندها استخدام assert للتحقق مما إذا كان الناتج من slow وfast متطابقًا.\n\n#include&lt;iostream&gt;\n#include&lt;cassert&gt; \n\nusing namespace std;\n\nint slow (int n) {\n    int ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) ans += i;\n    return ans;\n}\n\nint fast (int n) {\n    return n * (n + 1) / 2;\n}\n\nint main () {\n    int n;\n    cin &gt;&gt; n;\n\n    assert(fast(n) == slow(n));\n\n    cout &lt;&lt; fast(n);\n}\n\nلذلك هناك احتمالان فقط: إما نحصل على Time Limit Exceeded مما يعني أننا نجحنا في الاختبارات الصغيرة، أو نحصل على Runtime Error مما يعني أن النتيجتين مختلفتان.\nإذا حصلنا على Runtime Error يمكننا مراجعة الصيغة والتأكد من صحتها، أما إذا حصلنا على Time Limit Exceeded فيمكننا استنتاج أن الصيغة تفشل عند الأعداد الكبيرة — وهو ما قد يدل على مشكلة تجاوز (overflow)."
  },
  {
    "objectID": "b0/debugging/debugging.html#نصائح-أخرى",
    "href": "b0/debugging/debugging.html#نصائح-أخرى",
    "title": "تصحيح الأخطاء",
    "section": "",
    "text": "تأكد أن تنسيق المخرجات يطابق تمامًا نص المسألة (بدون مسافات أو أسطر إضافية).\nاحذف جميع طباعات التصحيح قبل تسليم الحل.\n\n\n\n\n\nتعامل مع جميع الحالات الحدّية مثل N = 0, N = 1, الإدخال الفارغ، وأكبر القيم الممكنة.\nفي المسائل ذات عدة حالات اختبار، أعد تهيئة جميع المتغيرات والهياكل بين كل حالة وأخرى.\n\nالأخطاء غالبًا تظهر عندما تتبع حالة صغيرة حالة اختبار كبيرة.\n\n\n\n\n\n\nأعد قراءة نص المسألة بعناية.\nأعد قراءة شيفرتك — من الأخطاء الشائعة الخلط بين N و M أو بين i و j.\nراقب وجود متغيرات مظللة (shadowed) أو غير مستخدمة أو غير مهيّأة.\n\n\n\n\n\nالمتغيرات غير المهيّأة.\nالوصول إلى مصفوفة أو متّجه خارج النطاق.\nغياب جملة return في دوال غير void.\nتجاوز السعة للأعداد الموقعة (استخدم long long).\nإزاحة البتات (bit-shifting) بمقدار ≥ 32 على أعداد 32-بت.\n\n\n\n\n\nتحقق من وجود NaN (مثل ناتج sqrt لعدد سالب).\nاستخدم long double عند الحاجة إلى دقة أعلى.\nطابق عدد الخانات المطلوبة في المخرجات باستخدام setprecision().\n\n\n\n\n\nنفّذ اختبارات يدوية على أمثلة بسيطة.\nاختبر التحمل (stress test) بمقارنة ناتج الحل السريع مع حل بطيء يعتمد على القوة الغاشمة (brute-force).\n\n\n\n\n\nهل هناك سلوك غير معرّف؟\nهل هناك استدعاء لـ assert قد يفشل؟\nهل هناك قسمة على الصفر (أو باقي قسمة على صفر)؟\nهل توجد استدعاءات دالّية لا نهائية (recursion)؟\nهل هناك موقعات أو مكرّرات (iterators) غير صالحة؟\nهل البرنامج يستهلك ذاكرة زائدة عن الحد؟\n\n\n\n\n\nهل توجد حلقات لا نهائية؟\nما تعقيد خوارزميتك؟\nهل أزلت جميع طباعات التصحيح قبل التسليم (مثل الطباعة الزائدة إلى المخرجات)؟\nهل هناك نسخ غير ضروري للبيانات؟ فكّر في تمرير المتغيرات بالإشارة (by reference).\nجرّب استبدال المتّجهات بالمصفوفات إن أمكن.\n\n\n\n\n\nأعد كتابة الحل من البداية.\nاحفظ نسخة من الحل الأصلي، فقد تُدخل أخطاء جديدة أثناء إعادة الكتابة."
  },
  {
    "objectID": "b0/problems/equator.html",
    "href": "b0/problems/equator.html",
    "title": "",
    "section": "",
    "text": "Equator\n\nCodeforces\neasy\n\n\n\nيوجد مصفوفة \\(A\\) تحتوي على العدد \\(N\\) من الأعداد الصحيحة \\(A_1, A_2, \\dots, A_N\\).\nأوجد أول موقع \\(i\\) بحيث يكون المجموع \\(A_1 + A_2 + ... + A_i\\) على الأقل نصف مجموع المصفوفة الكاملة.\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nالمصفوفة \\(A\\) مرقمة بدءًا من \\(1\\) (أي أن الترقيم يبدأ من \\(1\\)).\n\n\n\n\n\n\n\n\nTipنصيحة\n\n\n\nعند مقارنة عددين صحيحين، إذا كان أحدهما يتضمن قسمة، يمكنك تجنب القسمة بضرب الطرف الآخر بدلًا منها.\nعلى سبيل المثال، بدلًا من كتابة:\n\nif (running_sum &gt;= total_sum / 2)\n\nيمكنك أن تكتب:\n\nif (running_sum * 2 &gt;= total_sum)\n\nهذا يتجنب مشاكل التقريب ويعمل بشكل صحيح مع الأعداد الصحيحة.\n\n\n\n\nSolution\n\nقم بحلقة تكرار على المصفوفة واحسب مجموعها الكامل ولنسمه total_sum.\n\nint n;\ncin &gt;&gt; n;\n\nint a[n];\nint total_sum = 0;\n\nfor (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; a[i];\n    total_sum += a[i];\n}\n\nبعد ذلك، ابدأ حلقة أخرى ابتداءً من العنصر الأول مع إضافة قيمة كل عنصر إلى running_sum. عند إضافة كل عنصر، تحقق مما إذا كان running_sum قد وصل إلى نصف total_sum. الجواب سيكون أول موقع يحدث فيه هذا الأمر.\n\nint running_sum = 0;\nint ans;\n\nfor (int i = 0; i &lt; n; i++) {\n    running_sum += a[i];\n\n    if (running_sum * 2 &gt;= total_sum) {\n        ans = i + 1;\n        break;\n    }\n}\n\ncout &lt;&lt; ans;",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Equator"
    ]
  },
  {
    "objectID": "b0/problems/equator.html#equator",
    "href": "b0/problems/equator.html#equator",
    "title": "",
    "section": "",
    "text": "Equator\n\nCodeforces\neasy\n\n\n\nيوجد مصفوفة \\(A\\) تحتوي على العدد \\(N\\) من الأعداد الصحيحة \\(A_1, A_2, \\dots, A_N\\).\nأوجد أول موقع \\(i\\) بحيث يكون المجموع \\(A_1 + A_2 + ... + A_i\\) على الأقل نصف مجموع المصفوفة الكاملة.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Equator"
    ]
  },
  {
    "objectID": "b0/problems/dislike-of-threes.html",
    "href": "b0/problems/dislike-of-threes.html",
    "title": "",
    "section": "",
    "text": "Dislike of Threes\n\nCodeforces\neasy\n\n\n\nيوجد \\(T\\) من حالات الاختبار. في كل حالة اختبار يُعطى عدد صحيح موجب \\(K\\). ولدينا سلسلة عددية موجبة بحيث كل قيمة فيها لا تقبل القسمة على \\(3\\) وآحاده لا تساوي \\(3\\) (\\(1, 2, 4, 5, 7, \\dots\\)). أوجد العنصر رقم \\(K\\) من هذه السلسلة. القيمة \\(K\\) يمكن أن تكون عددًا صحيحًا بين \\(1\\) و\\(1000\\).\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nالعنصر رقم \\(K\\) في مصفوفة أو vector V هو V[K-1].\n\n\n\n\nSolution\n\nيمكننا ملاحظة أن العدد x يجب استبعاده من السلسلة إذا كان يقبل القسمة على \\(3\\) (x % 3 == 0) أو إذا كانت آحاده \\(3\\) (x % 10 == 3).\nلحل المسألة، يمكننا إنشاء التسلسل كما يلي:\n\nأنشئ vector \\(V\\) لتخزين التسلسل.\n\n\nvector&lt;int&gt; v;\n\n\nابدأ حلقة عند \\(1\\) واستمر حتى يصبح حجم \\(V\\) يساوي \\(1000\\).\n\nفي كل دورة، أضف العدد الحالي إلى \\(V\\) فقط إذا لم يكن قابلاً للقسمة على \\(3\\) ولا ينتهي بـ \\(3\\).\n\n\nfor (int i = 1; v.size() &lt; 1000; i++) {\n    if (i % 3 != 0 && i % 10 != 3) {\n        v.push_back(i);\n    }\n}\n\nبعد إنشاء السلسلة، يمكننا قراءة كل قيمة \\(K\\) وطباعة العنصر رقم \\(K\\) من vector \\(V\\).\n\nint test_cases;\ncin &gt;&gt; test_cases;\n\nfor (int i = 0; i &lt; test_cases; i++) {\n    int k;\n    cin &gt;&gt; k;\n\n    cout &lt;&lt; v[k - 1] &lt;&lt; endl;\n}",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Dislike of Threes"
    ]
  },
  {
    "objectID": "b0/problems/dislike-of-threes.html#dislike-of-threes",
    "href": "b0/problems/dislike-of-threes.html#dislike-of-threes",
    "title": "",
    "section": "",
    "text": "Dislike of Threes\n\nCodeforces\neasy\n\n\n\nيوجد \\(T\\) من حالات الاختبار. في كل حالة اختبار يُعطى عدد صحيح موجب \\(K\\). ولدينا سلسلة عددية موجبة بحيث كل قيمة فيها لا تقبل القسمة على \\(3\\) وآحاده لا تساوي \\(3\\) (\\(1, 2, 4, 5, 7, \\dots\\)). أوجد العنصر رقم \\(K\\) من هذه السلسلة. القيمة \\(K\\) يمكن أن تكون عددًا صحيحًا بين \\(1\\) و\\(1000\\).",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Dislike of Threes"
    ]
  },
  {
    "objectID": "b0/problems/weird-algorithm.html",
    "href": "b0/problems/weird-algorithm.html",
    "title": "",
    "section": "",
    "text": "Weird Algorithm\n\nCSES\neasy\n\n\n\nعند إعطائك عددًا صحيحًا موجبًا \\(n\\)، كرّر العمليات التالية:\n\nإذا كان \\(n\\) زوجيًا، اجعل \\(n \\leftarrow n/2\\)؛\nإذا كان \\(n\\) فرديًا، اجعل \\(n \\leftarrow 3n+1\\).\n\nاطبع جميع قيم \\(n\\) ابتداءً من القيمة الأولية حتى يصل إلى \\(1\\).\n\n\n\n\n\nSolution\n\nنقوم بمحاكاة العملية بطريقة تكرارية. ابدأ بطباعة القيمة الأولية لـ \\(n\\)، ثم في كل خطوة حدّث \\(n\\) وفقًا لقاعدة الزوجي/الفردي واطبعها. من المفترض نظريًا أن تصل هذه السلسلة دائمًا إلى \\(1\\)، ويطلق عليها “مخمن كولاتز”؛ في هذه المسألة، نقوم فقط بمحاكاة العملية حتى يصبح \\(n=1\\).\n\n\n\n\n\n\nTipمحاكاة باستخدام حلقة\n\n\n\nحلقة while واحدة تكفي: اطبع، حدّث \\(n\\)، وتوقف عند الوصول إلى \\(n=1\\).\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    long long n;\n    cin &gt;&gt; n;\n\n    cout &lt;&lt; n;\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3*n + 1;\n        }\n        cout &lt;&lt; ' ' &lt;&lt; n;\n    }\n}\n\n\n\n\n\n\n\n\nCautionتجاوز السعة (Overflow)\n\n\n\nعلى الرغم من أن الإدخال يحقق \\(1 \\le n \\le 10^6\\)، فإن القيم الوسيطة في السلسلة يمكن أن تتجاوز \\(10^9\\). استخدم long long لتجنب تجاوز السعة أثناء حساب \\(3*n+1\\).",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Weird Algorithm"
    ]
  },
  {
    "objectID": "b0/problems/weird-algorithm.html#weird-algorithm",
    "href": "b0/problems/weird-algorithm.html#weird-algorithm",
    "title": "",
    "section": "",
    "text": "Weird Algorithm\n\nCSES\neasy\n\n\n\nعند إعطائك عددًا صحيحًا موجبًا \\(n\\)، كرّر العمليات التالية:\n\nإذا كان \\(n\\) زوجيًا، اجعل \\(n \\leftarrow n/2\\)؛\nإذا كان \\(n\\) فرديًا، اجعل \\(n \\leftarrow 3n+1\\).\n\nاطبع جميع قيم \\(n\\) ابتداءً من القيمة الأولية حتى يصل إلى \\(1\\).",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Weird Algorithm"
    ]
  },
  {
    "objectID": "b0/problems/team.html",
    "href": "b0/problems/team.html",
    "title": "",
    "section": "",
    "text": "Team\n\nCodeforces\neasy\n\n\n\nيوجد ثلاثة أصدقاء و \\(N\\) من المسائل. يمكن حل المسألة إذا وفقط إذا كان اثنان أو أكثر من الأصدقاء يعرفون حلها.\nلكل مسألة من المسائل \\(N\\)، تُعطى لك معلومة عمّا إذا كان كل صديق يعرف الحل أم لا، ومهمتك هي حساب عدد المسائل التي يمكن حلها.\n\n\n\n\n\nSolution\n\nسنقوم ببساطة بالتكرار على جميع المسائل، وعدّ عدد الأصدقاء الذين يعرفون حل كل مسألة. إذا كان العدد على الأقل \\(2\\)، نزيد عدّادًا صحيحًا يمثل الناتج النهائي.\n\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n;\n    cin &gt;&gt; n;\n\n    int ans = 0;\n\n    for (int i = 0 ; i &lt; n ; i++) {\n        int f1, f2, f3;\n        cin &gt;&gt; f1 &gt;&gt; f2 &gt;&gt; f3;\n\n        if (f1 + f2 + f3 &gt;= 2) ans++;\n    }\n\n    cout &lt;&lt; ans;\n}",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Team"
    ]
  },
  {
    "objectID": "b0/problems/team.html#team",
    "href": "b0/problems/team.html#team",
    "title": "",
    "section": "",
    "text": "Team\n\nCodeforces\neasy\n\n\n\nيوجد ثلاثة أصدقاء و \\(N\\) من المسائل. يمكن حل المسألة إذا وفقط إذا كان اثنان أو أكثر من الأصدقاء يعرفون حلها.\nلكل مسألة من المسائل \\(N\\)، تُعطى لك معلومة عمّا إذا كان كل صديق يعرف الحل أم لا، ومهمتك هي حساب عدد المسائل التي يمكن حلها.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Team"
    ]
  },
  {
    "objectID": "b0/problems/static-range-sum-queries.html",
    "href": "b0/problems/static-range-sum-queries.html",
    "title": "",
    "section": "",
    "text": "Static Range Sum Queries\n\nCSES\nmedium\n\n\n\nتم إعطاؤك مصفوفة من \\(n\\) أعداد صحيحة و \\(q\\) استفسارات. كل استفسار يطلب مجموع القيم في النطاق الشامل \\([a,b]\\). اطبع الإجابة لكل استفسار.\n\n\n\n\n\nSolution\n\nقم بحساب المجاميع التراكمية (prefix sums) مسبقًا بحيث يمكن الإجابة عن أي استعلام نطاق في زمن \\(O(1)\\).\nلتكن \\(S[0]=0\\) ولـ \\(i\\ge1\\)، يكون \\(S[i]=S[i-1]+x_i\\).\nبعد ذلك، لأي استعلام \\([a,b]\\) (مؤشرات تبدأ من 1)، يكون المجموع:\n\n\\[\n\\text{sum}(a,b)=S[b]-S[a-1].\n\\]\n\nبناء \\(S\\) يستغرق \\(O(n)\\)؛ والإجابة عن جميع الاستفسارات تستغرق \\(O(q)\\).\n\n\n\n\n\n\nNoteالمجاميع التراكمية (مؤشرات تبدأ من 1)\n\n\n\n\nيتم البناء مرة واحدة: \\(S[i] = S[i-1] + x_i\\) لكل \\(i = 1..n\\)\nالاستعلام: \\(S[b] - S[a-1]\\)\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n\n    vector&lt;long long&gt; pref(n + 1, 0); // pref[0] = 0\n    for (int i = 1; i &lt;= n; i++) {\n        long long x;\n        cin &gt;&gt; x;\n        pref[i] = pref[i - 1] + x;\n    }\n\n    while (q--) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;          // نطاقات تبدأ من 1\n        cout &lt;&lt; (pref[b] - pref[a - 1]) &lt;&lt; '\\n';\n    }\n}\n\n\n\n\n\n\n\n\nCautionالمجاميع 64-بت\n\n\n\nيمكن أن تصل القيم إلى \\(2\\cdot10^5 \\times 10^9 = 2\\cdot10^{14}\\)، لذلك احفظ المجاميع التراكمية والنتائج في long long.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Static Range Sum Queries"
    ]
  },
  {
    "objectID": "b0/problems/static-range-sum-queries.html#static-range-sum-queries",
    "href": "b0/problems/static-range-sum-queries.html#static-range-sum-queries",
    "title": "",
    "section": "",
    "text": "Static Range Sum Queries\n\nCSES\nmedium\n\n\n\nتم إعطاؤك مصفوفة من \\(n\\) أعداد صحيحة و \\(q\\) استفسارات. كل استفسار يطلب مجموع القيم في النطاق الشامل \\([a,b]\\). اطبع الإجابة لكل استفسار.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Static Range Sum Queries"
    ]
  },
  {
    "objectID": "b0/problems/min-operations.html",
    "href": "b0/problems/min-operations.html",
    "title": "",
    "section": "",
    "text": "Min Operations\n\n\nhard\n\n\n\nتم إعطاء عددين طبيعيين \\(A\\) و \\(B\\)، لكل منهما نفس عدد الخانات. في كل خطوة، يُسمح إما بتغيير قيمة أي خانة من خانات \\(A\\)، أو عكس ترتيب الخانات \\(A\\). العملية الأولى تكلف \\(X\\) ريالات، والثانية تكلف \\(Y\\) ريالات. ما أقل مبلغ من المال مطلوب لتحويل العدد \\(A\\) إلى العدد \\(B\\)؟\nالأعداد \\(A\\) و \\(B\\) لا تتجاوز \\(10^{18}\\)، والأعداد \\(X\\) و \\(Y\\) لا تتجاوز \\(1000\\).\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nإذا كان هذا يبدو صعبًا جدًا، يمكنك أولًا محاولة حل المسألة بافتراض أن \\(X = 1\\) و \\(Y = 1000\\).",
    "crumbs": [
      "المرحلة 1",
      "مسائل تدريبية",
      "Min Operations"
    ]
  },
  {
    "objectID": "b0/problems/min-operations.html#min-operations",
    "href": "b0/problems/min-operations.html#min-operations",
    "title": "",
    "section": "",
    "text": "Min Operations\n\n\nhard\n\n\n\nتم إعطاء عددين طبيعيين \\(A\\) و \\(B\\)، لكل منهما نفس عدد الخانات. في كل خطوة، يُسمح إما بتغيير قيمة أي خانة من خانات \\(A\\)، أو عكس ترتيب الخانات \\(A\\). العملية الأولى تكلف \\(X\\) ريالات، والثانية تكلف \\(Y\\) ريالات. ما أقل مبلغ من المال مطلوب لتحويل العدد \\(A\\) إلى العدد \\(B\\)؟\nالأعداد \\(A\\) و \\(B\\) لا تتجاوز \\(10^{18}\\)، والأعداد \\(X\\) و \\(Y\\) لا تتجاوز \\(1000\\).",
    "crumbs": [
      "المرحلة 1",
      "مسائل تدريبية",
      "Min Operations"
    ]
  },
  {
    "objectID": "b0/problems/leap-year.html",
    "href": "b0/problems/leap-year.html",
    "title": "",
    "section": "",
    "text": "Leap Year\n\n\neasy\n\n\n\nاكتب برنامجًا يقرأ سنة من الإدخال، ثم يطبع ما إذا كانت هذه السنة كبيسة أم لا.\nيُفترض بك أن تبحث بنفسك عن القاعدة التي تحدد ما إذا كانت السنة كبيسة أم لا.",
    "crumbs": [
      "المرحلة 1",
      "مسائل تدريبية",
      "Leap Year"
    ]
  },
  {
    "objectID": "b0/problems/leap-year.html#leap-year",
    "href": "b0/problems/leap-year.html#leap-year",
    "title": "",
    "section": "",
    "text": "Leap Year\n\n\neasy\n\n\n\nاكتب برنامجًا يقرأ سنة من الإدخال، ثم يطبع ما إذا كانت هذه السنة كبيسة أم لا.",
    "crumbs": [
      "المرحلة 1",
      "مسائل تدريبية",
      "Leap Year"
    ]
  },
  {
    "objectID": "b0/problems/domino-piling.html",
    "href": "b0/problems/domino-piling.html",
    "title": "",
    "section": "",
    "text": "Domino Piling\n\nCodeforces\neasy\n\n\n\nتم إعطاؤك لوحة بحجم \\(M \\times N\\) ودومينو \\(2\\times1\\) غير محدود (يمكن تدويره). ضع أكبر عدد ممكن من الدومينو بحيث تقع بالكامل ضمن اللوحة ولا تتداخل مع بعضها. اطبع الحد الأقصى لعدد الدومينو.\n\n\n\n\n\nSolution\n\nكل دومينو يغطي خانتين بالضبط، لذا لا يمكن لأي ترتيب أن يستخدم أكثر من \\(\\left\\lfloor \\dfrac{MN}{2} \\right\\rfloor\\) دومينو.\nبرهان باستخدام رقعة الشطرنج (الحد الأعلى). لون اللوحة \\(M\\times N\\) مثل رقعة الشطرنج، ولتكن \\(B\\) و \\(W\\) مجموعات الخانات السوداء والبيضاء. كل دومينو \\(2\\times1\\) يغطي دائمًا خانة سوداء وأخرى بيضاء، لذا أي ترتيب يستخدم على الأكثر \\(\\min\\bigl(\\lvert B\\rvert,\\lvert W\\rvert\\bigr)\\). إذا كان \\(MN\\) زوجيًا، فإن \\(\\lvert B\\rvert=\\lvert W\\rvert=MN/2\\)؛ وإذا كان \\(MN\\) فرديًا، يختلفان بمقدار 1. لذلك: \\(\\max \\text{ دومينو } \\le \\left\\lfloor \\dfrac{MN}{2} \\right\\rfloor\\).\nإمكانية التنفيذ (بناء صريح).\n\nإذا كان أحد \\(M\\) أو \\(N\\) زوجيًا: غطّ اللوحة بالكامل (تحصل على \\(MN/2\\) دومينو).\nإذا كان كلا \\(M\\) و \\(N\\) فرديًا: املأ كل الخانات ما عدا واحدة، فتحصل على \\(\\dfrac{MN-1}{2}\\) دومينو.\n\nلذلك، في جميع الحالات الحد الأقصى يساوي \\(\\left\\lfloor \\dfrac{MN}{2} \\right\\rfloor\\).\n\n\n\n\n\n\nTipتقريب لأسفل نصف حاصل الضرب\n\n\n\nبالنسبة للأعداد الصحيحة، \\(\\left\\lfloor \\dfrac{MN}{2}\\right\\rfloor\\) يمكن كتابته ببساطة كـ (M*N)/2 باستخدام القسمة الصحيحة.\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    long long M, N;\n    cin &gt;&gt; M &gt;&gt; N;\n\n    cout &lt;&lt; (M * N) / 2;  // floor(M*N/2)\n}\n\n\n\n\n\n\n\n\nCautionنوع المتغير\n\n\n\nعلى الرغم من أن \\(1 \\le M \\le N \\le 16\\)، لذا استخدام int آمن، إلا أن استخدام long long (كما في الأعلى) عادة جيدة لمشاكل مماثلة لتجنب تجاوز السعة عند زيادة حاصل الضرب.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Domino Piling"
    ]
  },
  {
    "objectID": "b0/problems/domino-piling.html#domino-piling",
    "href": "b0/problems/domino-piling.html#domino-piling",
    "title": "",
    "section": "",
    "text": "Domino Piling\n\nCodeforces\neasy\n\n\n\nتم إعطاؤك لوحة بحجم \\(M \\times N\\) ودومينو \\(2\\times1\\) غير محدود (يمكن تدويره). ضع أكبر عدد ممكن من الدومينو بحيث تقع بالكامل ضمن اللوحة ولا تتداخل مع بعضها. اطبع الحد الأقصى لعدد الدومينو.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Domino Piling"
    ]
  },
  {
    "objectID": "b0/problems/beautiful-year.html",
    "href": "b0/problems/beautiful-year.html",
    "title": "",
    "section": "",
    "text": "Beautiful Year\n\nCodeforces\neasy\n\n\n\nتم إعطاؤك سنة. جد أصغر سنة تكون أكبر من السنة المعطاة مباشرة وتحتوي على خانات مختلفة تمامًا.\nيمكنك افتراض أن السنة على الأقل 1000 وعلى الأكثر 9000.\n\n\n\nعلى سبيل المثال، إذا كانت السنة 1987، فإن السنة التالية التي تحقق الشرط هي 2013.\n\n\nSolution\n\nيمكننا البدء بزيادة السنة بمقدار واحد حتى نحصل على سنة تحتوي جميع خاناتها مختلفة.\n\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int year;\n    cin &gt;&gt; year;\n\n    year += 1;\n    while (allDifferentDigits(year) == false) {\n        year += 1;\n    }\n\n    cout &lt;&lt; year &lt;&lt; '\\n';\n}\n\n\nالآن، كيف نتحقق من أن السنة تحتوي على جميع خانات مختلفة؟ لاحظ أن عدد خانات السنة هو أربعة. هذا يعني أنه يمكننا أخذ الخانة الأخيرة كباقي القسمة على 10، ثم طرحها وتقسيم الناتج على 10، ونكرر العملية ثلاث مرات أخرى لنحصل على الأربع خانات ونقارنها.\n\n\nbool allDifferentDigits(int year) {\n    int digit1 = year % 10;\n    year = (year - digit1) / 10;\n\n    int digit2 = year % 10;\n    year = (year - digit2) / 10;\n\n    int digit3 = year % 10;\n    year = (year - digit3) / 10;\n\n    int digit4 = year % 10;\n\n    if (digit1 != digit2 && digit1 != digit3 && digit1 != digit4\n    && digit2 != digit3 && digit2 != digit4 && digit3 != digit4) {\n        return true;\n    } else {\n        return false;\n    }\n}",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Beautiful Year"
    ]
  },
  {
    "objectID": "b0/problems/beautiful-year.html#beautiful-year",
    "href": "b0/problems/beautiful-year.html#beautiful-year",
    "title": "",
    "section": "",
    "text": "Beautiful Year\n\nCodeforces\neasy\n\n\n\nتم إعطاؤك سنة. جد أصغر سنة تكون أكبر من السنة المعطاة مباشرة وتحتوي على خانات مختلفة تمامًا.\nيمكنك افتراض أن السنة على الأقل 1000 وعلى الأكثر 9000.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Beautiful Year"
    ]
  },
  {
    "objectID": "b0/problems/alternate.html",
    "href": "b0/problems/alternate.html",
    "title": "",
    "section": "",
    "text": "Alternate\n\n\neasy\n\n\n\nتم إعطاؤك عددًا طبيعيًا \\(n\\). احسب قيمة التعبير:\n\n\\[\n1 \\cdot n + 2 \\cdot (n - 1) - 3 \\cdot (n - 2) + 4 \\cdot (n - 3) + 5 \\cdot (n - 4) - 6 \\cdot (n - 5) + \\ldots \\pm n \\cdot 1\n\\]\n\nيمكنك افتراض أن \\(1 \\leq n \\leq 1000000\\).\n\n\n\nيمكن حل هذا باستخدام الحلقات، بينما يُدعى محبو الرياضيات لتجربة الحل بدون حلقات.",
    "crumbs": [
      "المرحلة 1",
      "مسائل تدريبية",
      "Alternate"
    ]
  },
  {
    "objectID": "b0/problems/alternate.html#alternate",
    "href": "b0/problems/alternate.html#alternate",
    "title": "",
    "section": "",
    "text": "Alternate\n\n\neasy\n\n\n\nتم إعطاؤك عددًا طبيعيًا \\(n\\). احسب قيمة التعبير:\n\n\\[\n1 \\cdot n + 2 \\cdot (n - 1) - 3 \\cdot (n - 2) + 4 \\cdot (n - 3) + 5 \\cdot (n - 4) - 6 \\cdot (n - 5) + \\ldots \\pm n \\cdot 1\n\\]\n\nيمكنك افتراض أن \\(1 \\leq n \\leq 1000000\\).",
    "crumbs": [
      "المرحلة 1",
      "مسائل تدريبية",
      "Alternate"
    ]
  },
  {
    "objectID": "b0/cpp/name-visibility.html",
    "href": "b0/cpp/name-visibility.html",
    "title": "مرئية الأسماء",
    "section": "",
    "text": "في C++، الموضع الذي يتم فيه تعريف المتغير يؤثر على الأماكن التي يمكن استخدامه فيها.\n\n\nالنطاق هو الجزء من البرنامج الذي يمكن تعريف المتغير فيه والوصول إليه مباشرة باستخدام اسمه. إذا تم تعريف متغير في نطاق معين فإننا نقول أن الاسم مرئي في هذا النطاق. أغلب النطاقات هي المناطق المحاطة بالأقواس المعقوفة {}. المنطقة خارج أي نطاق تُسمى النطاق العام، وأي منطقة أخرى تُسمى نطاق محلي.\n\n#include&lt;iostream&gt;\nusing namespace std;\n\n// نطاق عام\nint x = 5;\n\nint main() {\n    // نطاق محلي 1\n    int y = 4\n    \n    for (int i = 0 ; i &lt; 5 ; i++) {\n        // نطاق محلي 2\n        int z = 20;\n        if (i % 2 == 0) {\n            // نطاق محلي 4\n            cout &lt;&lt; z + x &lt;&lt; ' ' &lt;&lt; z + y &lt;&lt; endl;\n        }\n        else {\n            // نطاق محلي 4\n            cout &lt;&lt; z - y &lt;&lt; ' ' &lt;&lt; z - x &lt;&lt; endl;\n        }\n    }\n}\n\nفي هذا المثال لدينا نطاق عام و أربعة نطاقات محلية. لاحظ أن النطاق 1 يمتد خلال الدالة main() بأكملها، والنطاق 2 هو المنطقة داخل حلقة for، والنطاقان 3 و4 هما المنطقتان داخل كل من if و else.\n\n\n\nالمتغيرات المعرفة بشكل عام (وتُسمى أيضًا متغيرات عامة) تكون مرئية ويمكن استخدامها في جميع النطاقات بعد تعريفها. المتغيرات المعرفة محليًا (وتُسمى أيضًا متغيرات محلية) تكون مرئية فقط داخل النطاق الذي تم تعريفها فيه، ويشمل ذلك النطاقات الداخلية.\nبالنظر إلى المثال السابق، هذه هي مرئية كل من x و y و i و z:\n\n\n\nاسم المتغير\nالنطاق المعرف فيه\nالنطاقات القادرة على رؤية المتغير\n\n\n\n\nx\nالنطاق العام\nجميع النطاقات\n\n\ny\nالنطاق 1 (داخل ()main)\nجميع النطاقات المحلية\n\n\ni\nحلقة for التي تبدأ النطاق 2\nالنطاقات 2 و3 و4\n\n\nz\nالنطاق 2 (داخل for)\nالنطاقات 2 و3 و4\n\n\n\nلاحظ أن المتغيرات التي تم تعريفها داخل حلقة for تنتمي إلى نطاق الحلقة نفسه، حتى لو كان التعريف قبل الأقواس المعقوفة.\n\n\n\n\n\n\nWarning\n\n\n\nاستخدام متغير خارج نطاقه يؤدي إلى خطأ في الترجمة (compilation error).\n\n\n\n\n\nفي النطاق الواحد يمكن للاسم أن يمثل متغيرًا واحدًا فقط.\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x = 5;\n    string x = \"Hello world\"; // تم تعريفه مرتين في النطاق نفسه x لأن (compilation error) خطأ في الترجمة\n}\n\nعلى الرغم من أننا ذكرنا أن الاسم يمكن أن يمثل متغيرًا واحدًا فقط، إلا أنه يمكننا تعريف متغير في نطاق ثم تعريف متغير آخر بالاسم نفسه في نطاق داخلي. في هذه الحالة، عند استخدام هذا الاسم سيستخدم المتغير الداخلي.\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint x = 5;\n\nint main() {\n    int x;                        // لا مشكلة. لأننا في نطاق داخلي\n    cin &gt;&gt; x;\n    \n    if (x == 5) {\n        string x = \"Hello world\"; //  أيضا مسموح لأننا في نطاق داخلي أيضا\n        cout &lt;&lt; x &lt;&lt; endl;\n    }\n    else {\n        cout &lt;&lt; x &lt;&lt; endl;\n    }\n}",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "مرئية الأسماء"
    ]
  },
  {
    "objectID": "b0/cpp/name-visibility.html#النطاقات",
    "href": "b0/cpp/name-visibility.html#النطاقات",
    "title": "مرئية الأسماء",
    "section": "",
    "text": "النطاق هو الجزء من البرنامج الذي يمكن تعريف المتغير فيه والوصول إليه مباشرة باستخدام اسمه. إذا تم تعريف متغير في نطاق معين فإننا نقول أن الاسم مرئي في هذا النطاق. أغلب النطاقات هي المناطق المحاطة بالأقواس المعقوفة {}. المنطقة خارج أي نطاق تُسمى النطاق العام، وأي منطقة أخرى تُسمى نطاق محلي.\n\n#include&lt;iostream&gt;\nusing namespace std;\n\n// نطاق عام\nint x = 5;\n\nint main() {\n    // نطاق محلي 1\n    int y = 4\n    \n    for (int i = 0 ; i &lt; 5 ; i++) {\n        // نطاق محلي 2\n        int z = 20;\n        if (i % 2 == 0) {\n            // نطاق محلي 4\n            cout &lt;&lt; z + x &lt;&lt; ' ' &lt;&lt; z + y &lt;&lt; endl;\n        }\n        else {\n            // نطاق محلي 4\n            cout &lt;&lt; z - y &lt;&lt; ' ' &lt;&lt; z - x &lt;&lt; endl;\n        }\n    }\n}\n\nفي هذا المثال لدينا نطاق عام و أربعة نطاقات محلية. لاحظ أن النطاق 1 يمتد خلال الدالة main() بأكملها، والنطاق 2 هو المنطقة داخل حلقة for، والنطاقان 3 و4 هما المنطقتان داخل كل من if و else.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "مرئية الأسماء"
    ]
  },
  {
    "objectID": "b0/cpp/name-visibility.html#أين-يكون-المتغير-مرئيا",
    "href": "b0/cpp/name-visibility.html#أين-يكون-المتغير-مرئيا",
    "title": "مرئية الأسماء",
    "section": "",
    "text": "المتغيرات المعرفة بشكل عام (وتُسمى أيضًا متغيرات عامة) تكون مرئية ويمكن استخدامها في جميع النطاقات بعد تعريفها. المتغيرات المعرفة محليًا (وتُسمى أيضًا متغيرات محلية) تكون مرئية فقط داخل النطاق الذي تم تعريفها فيه، ويشمل ذلك النطاقات الداخلية.\nبالنظر إلى المثال السابق، هذه هي مرئية كل من x و y و i و z:\n\n\n\nاسم المتغير\nالنطاق المعرف فيه\nالنطاقات القادرة على رؤية المتغير\n\n\n\n\nx\nالنطاق العام\nجميع النطاقات\n\n\ny\nالنطاق 1 (داخل ()main)\nجميع النطاقات المحلية\n\n\ni\nحلقة for التي تبدأ النطاق 2\nالنطاقات 2 و3 و4\n\n\nz\nالنطاق 2 (داخل for)\nالنطاقات 2 و3 و4\n\n\n\nلاحظ أن المتغيرات التي تم تعريفها داخل حلقة for تنتمي إلى نطاق الحلقة نفسه، حتى لو كان التعريف قبل الأقواس المعقوفة.\n\n\n\n\n\n\nWarning\n\n\n\nاستخدام متغير خارج نطاقه يؤدي إلى خطأ في الترجمة (compilation error).",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "مرئية الأسماء"
    ]
  },
  {
    "objectID": "b0/cpp/name-visibility.html#التسمية-داخل-النطاق",
    "href": "b0/cpp/name-visibility.html#التسمية-داخل-النطاق",
    "title": "مرئية الأسماء",
    "section": "",
    "text": "في النطاق الواحد يمكن للاسم أن يمثل متغيرًا واحدًا فقط.\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x = 5;\n    string x = \"Hello world\"; // تم تعريفه مرتين في النطاق نفسه x لأن (compilation error) خطأ في الترجمة\n}\n\nعلى الرغم من أننا ذكرنا أن الاسم يمكن أن يمثل متغيرًا واحدًا فقط، إلا أنه يمكننا تعريف متغير في نطاق ثم تعريف متغير آخر بالاسم نفسه في نطاق داخلي. في هذه الحالة، عند استخدام هذا الاسم سيستخدم المتغير الداخلي.\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint x = 5;\n\nint main() {\n    int x;                        // لا مشكلة. لأننا في نطاق داخلي\n    cin &gt;&gt; x;\n    \n    if (x == 5) {\n        string x = \"Hello world\"; //  أيضا مسموح لأننا في نطاق داخلي أيضا\n        cout &lt;&lt; x &lt;&lt; endl;\n    }\n    else {\n        cout &lt;&lt; x &lt;&lt; endl;\n    }\n}",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "مرئية الأسماء"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html",
    "href": "b0/cpp/arrays.html",
    "title": "المصفوفات",
    "section": "",
    "text": "عندما يحتاج البرنامج إلى عدد كبير من المتغيرات، فإن تعريف كل متغير على حدة قد تكون عملية طويلة وتجعل البرنامج غير منظم. لحل هذه المشكلة، يمكننا استخدام المصفوفات (arrays)، والتي تتيح لنا تجميع البيانات ذات العلاقة معًا بطريقة مرتبة.\n\n\nالمصفوفة هي عدد ثابت من المتغيرات التي تكون من نفس النوع، يتم تخزينها في الذاكرة بشكل متتابع وتشترك في اسم واحد. تُسمى المتغيرات داخل المصفوفة عناصر (elements).\nللتفريق بين العناصر داخل المصفوفة، يتم إعطاء كل عنصر رقم مميز يُعرف باسم الموقع (index).\nعندما تحتوي المصفوفة على n عنصرًا، يتم ترقيم هذه العناصر بشكل متتابع من 0 إلى n - 1.\n\n\n\nلتعريف مصفوفة في لغة C++ نستخدم الصيغة التالية:\n\ntype name[size];\n\n\n\n\n\n\n\n\nالعنصر\nالشرح\n\n\n\n\ntype\nنوع جميع العناصر داخل المصفوفة (مثل int أو double).\n\n\nname\nالاسم الذي سنستخدمه للوصول إلى المصفوفة.\n\n\nsize\nعدد العناصر التي تحتويها المصفوفة.\n\n\n\nعلى سبيل المثال:\n\nint a[4];\n\nهذا التعريف يُنشئ مصفوفة اسمها a[] تتكون من 4 عناصر.\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nحجم المصفوفة ثابت ولا يمكن تغييره بعد إنشائها.\n\n\nمن الممكن أن لا يكون حجم المصفوفة رقمًا صريحا بل يمكن أن يكون تعبيرًا يُحسب أثناء تنفيذ البرنامج، مما يمكننا من تحديد حجم المصفوفة بناءً على حالة البرنامج أثناء التنفيذ:\n\nint n;\ncin &gt;&gt; n;\nint a[n + 1]; // n + 1 تنشئ مصفوفة بحجم\n\n\n\n\nعند تعريف مصفوفة محليًا، فإن جميع عناصرها لا تحتوي على قيم محددة، أي أن قيمها غير معروفة.\nلتحديد قيم المصفوفة فإننا نعطيها قيم ابتدائية، على سبيل المثال نكتب:\n\nint a[4] = {2, 4, 5, 0};\n\nهذا الأمر ينشئ مصفوفة تحتوي على القيم 2، 4، 5، و0.\nيمكننا تمثيلها كما في الصورة التالية، حيث تمثل الخلايا عناصر المصفوفة، والأرقام الموجودة تحتها هي المواقع:\n\nإذا أردنا تعريف مصفوفة محليا وجعل جميع عناصرها تبدأ بالقيمة 0، يمكننا كتابة:\n\nint a[2000] = {};\n\nهذا السطر البرجي ينشئ مصفوفة تحتوي على 2000 عنصرًا، كل عنصر فيها يساوي 0.\n\n\n\nيمكن الوصول إلى أي عنصر داخل المصفوفة باستخدام الموقع الخاص به، عبر الصيغة التالية:\n\nname[index];\n\n\n\n\n\n\n\n\nالعنصر\nالشرح\n\n\n\n\nname\nاسم المصفوفة.\n\n\nindex\nالموقع الخاص بالعنصر المراد الوصول إليه.\n\n\n\nالعناصر داخل المصفوفة تتصرف مثل أي متغير عادي. المثال التالي يوضح كيفية التعامل مع عناصر المصفوفة:\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int a[5] = {1, 2, 3, 4, 5}; // a[0] القيمة 1 عينت للعنصر\n    int x = a[0];               // ب1 x ستصبح قيمة\n    a[0]++;                     // ب2 a[0] ستصبح قيمة\n    cout &lt;&lt; x &lt;&lt; endl;          // طباعة 1\n    cout &lt;&lt; a[0] &lt;&lt; endl;       // طباعة 2\n}\n\nالبرنامج أعلاه يوضح أن عناصر المصفوفة يمكن قراءتها أو تعديلها بسهولة كما هو الحال مع أي متغير.\n\n\n\n\n\nيمكننا استخدام حلقات للتكرار عبر جميع عناصر المصفوفة بالتكرار عبر مواقعها (من 0 إلى حجم المصفوفة - 1).\nعلى سبيل المثال، إذا أردنا حساب مجموع جميع عناصر لمصفوفة، يمكننا كتابة:\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n;\n    cin &gt;&gt; n;                    // يدخل حجم المصفوفة\n    \n    int a[n];                    // n تعريف مصفوفة بحجم\n    for(int i = 0; i &lt; n; i++) { // n - 1 التكرار عبر الرقام من 0 إلي \n        cin &gt;&gt; a[i];             // a[i] سندخل قيمة ،i لكل موقع\n    }\n\n    int sum = 0;\n    for (int i = 0 ; i &lt; n ; i++) {\n        sum += a[i];            // sum للمتغير  a[i] سنضيف قيمة ،i لكل موقع\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n}\n\nفي هذا المثال: ندخل عدد العناصر n من المستخدم. ثم ننشئ مصفوفة a بحجم n. ونستخدم حلقة لإدخال قيم المصفوفة. ثم نستخدم حلقة أخرى لحساب المجموع الكلي للعناصر وطباعة النتيجة.\n\n\n\n\nالمصفوفات متعددة الأبعاد هي مصفوفات تحتوي على مصفوفات أخرى داخلها، أي أن كل عنصر يمكن أن يكون بدوره مصفوفة.\nيُطلق على كل مستوى من هذه المستويات اسم بُعد.\nانظر إلى المثال التالي:\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n  int a[5];\n  int b[5][4];\n}\n\nفي هذا البرنامج:\n\n\n\n\n\n\n\nالعنصر\nالشرح\n\n\n\n\na\nمصفوفة أحادية الأبعاد تحتوي على 5 أعداد صحيحة.\n\n\nb\nمصفوفة ثنائية الأبعاد، تتكون من 5 مصفوفات، تحتوي كل مصفوفة على 4 أعداد صحيحة.\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\na[0] تمثل عددًا صحيحًا، بينما b[0] تمثل مصفوفة من أربعة أعداد صحيحة.\n\n\nللوصول إلى عنصر داخل مصفوفة متعددة الأبعاد، يجب تحديد الموقع في كل بُعد:\nعلى سبيل المثال، للوصول إلى عنصر في a نكتب a[i]،\nأما للوصول إلى عنصر في b فنكتب b[i][j].\nإذا قمنا بتعبئة المصفوفة b ببعض القيم، يمكننا تمثيلها كما في الشكل التالي:\n\nفي هذا التمثيل: - b[0] هي مصفوفة من أربعة أعداد صحيحة. - b[2][1] هو العنصر الذي يحمل القيمة 14.\nعدد الخلايا الكلي في المصفوفة متعددة الأبعاد يساوي حاصل ضرب أطوال جميع الأبعاد.\nفي مثالنا السابق، تحتوي b على 5 * 4 = 20 عنصرًا.\nيمكن أن تحتوي المصفوفة على أكثر من بعدين، بل ويمكن أن تكون ذات سبعة أبعاد أو أكثر.\nعلى سبيل المثال، المصفوفة التالية تحتوي على سبعة أبعاد:\n\nint c[4][6][7][54][32][2][7];",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المصفوفات"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html#ما-هي-المصفوفة",
    "href": "b0/cpp/arrays.html#ما-هي-المصفوفة",
    "title": "المصفوفات",
    "section": "",
    "text": "المصفوفة هي عدد ثابت من المتغيرات التي تكون من نفس النوع، يتم تخزينها في الذاكرة بشكل متتابع وتشترك في اسم واحد. تُسمى المتغيرات داخل المصفوفة عناصر (elements).\nللتفريق بين العناصر داخل المصفوفة، يتم إعطاء كل عنصر رقم مميز يُعرف باسم الموقع (index).\nعندما تحتوي المصفوفة على n عنصرًا، يتم ترقيم هذه العناصر بشكل متتابع من 0 إلى n - 1.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المصفوفات"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html#تعريف-المصفوفات",
    "href": "b0/cpp/arrays.html#تعريف-المصفوفات",
    "title": "المصفوفات",
    "section": "",
    "text": "لتعريف مصفوفة في لغة C++ نستخدم الصيغة التالية:\n\ntype name[size];\n\n\n\n\n\n\n\n\nالعنصر\nالشرح\n\n\n\n\ntype\nنوع جميع العناصر داخل المصفوفة (مثل int أو double).\n\n\nname\nالاسم الذي سنستخدمه للوصول إلى المصفوفة.\n\n\nsize\nعدد العناصر التي تحتويها المصفوفة.\n\n\n\nعلى سبيل المثال:\n\nint a[4];\n\nهذا التعريف يُنشئ مصفوفة اسمها a[] تتكون من 4 عناصر.\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nحجم المصفوفة ثابت ولا يمكن تغييره بعد إنشائها.\n\n\nمن الممكن أن لا يكون حجم المصفوفة رقمًا صريحا بل يمكن أن يكون تعبيرًا يُحسب أثناء تنفيذ البرنامج، مما يمكننا من تحديد حجم المصفوفة بناءً على حالة البرنامج أثناء التنفيذ:\n\nint n;\ncin &gt;&gt; n;\nint a[n + 1]; // n + 1 تنشئ مصفوفة بحجم",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المصفوفات"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html#تحديد-قيم-المصفوفة",
    "href": "b0/cpp/arrays.html#تحديد-قيم-المصفوفة",
    "title": "المصفوفات",
    "section": "",
    "text": "عند تعريف مصفوفة محليًا، فإن جميع عناصرها لا تحتوي على قيم محددة، أي أن قيمها غير معروفة.\nلتحديد قيم المصفوفة فإننا نعطيها قيم ابتدائية، على سبيل المثال نكتب:\n\nint a[4] = {2, 4, 5, 0};\n\nهذا الأمر ينشئ مصفوفة تحتوي على القيم 2، 4، 5، و0.\nيمكننا تمثيلها كما في الصورة التالية، حيث تمثل الخلايا عناصر المصفوفة، والأرقام الموجودة تحتها هي المواقع:\n\nإذا أردنا تعريف مصفوفة محليا وجعل جميع عناصرها تبدأ بالقيمة 0، يمكننا كتابة:\n\nint a[2000] = {};\n\nهذا السطر البرجي ينشئ مصفوفة تحتوي على 2000 عنصرًا، كل عنصر فيها يساوي 0.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المصفوفات"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html#الوصول-إلى-العناصر",
    "href": "b0/cpp/arrays.html#الوصول-إلى-العناصر",
    "title": "المصفوفات",
    "section": "",
    "text": "يمكن الوصول إلى أي عنصر داخل المصفوفة باستخدام الموقع الخاص به، عبر الصيغة التالية:\n\nname[index];\n\n\n\n\n\n\n\n\nالعنصر\nالشرح\n\n\n\n\nname\nاسم المصفوفة.\n\n\nindex\nالموقع الخاص بالعنصر المراد الوصول إليه.\n\n\n\nالعناصر داخل المصفوفة تتصرف مثل أي متغير عادي. المثال التالي يوضح كيفية التعامل مع عناصر المصفوفة:\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int a[5] = {1, 2, 3, 4, 5}; // a[0] القيمة 1 عينت للعنصر\n    int x = a[0];               // ب1 x ستصبح قيمة\n    a[0]++;                     // ب2 a[0] ستصبح قيمة\n    cout &lt;&lt; x &lt;&lt; endl;          // طباعة 1\n    cout &lt;&lt; a[0] &lt;&lt; endl;       // طباعة 2\n}\n\nالبرنامج أعلاه يوضح أن عناصر المصفوفة يمكن قراءتها أو تعديلها بسهولة كما هو الحال مع أي متغير.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المصفوفات"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html#أمثلة-على-استخدام-المصفوفات",
    "href": "b0/cpp/arrays.html#أمثلة-على-استخدام-المصفوفات",
    "title": "المصفوفات",
    "section": "",
    "text": "يمكننا استخدام حلقات للتكرار عبر جميع عناصر المصفوفة بالتكرار عبر مواقعها (من 0 إلى حجم المصفوفة - 1).\nعلى سبيل المثال، إذا أردنا حساب مجموع جميع عناصر لمصفوفة، يمكننا كتابة:\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n;\n    cin &gt;&gt; n;                    // يدخل حجم المصفوفة\n    \n    int a[n];                    // n تعريف مصفوفة بحجم\n    for(int i = 0; i &lt; n; i++) { // n - 1 التكرار عبر الرقام من 0 إلي \n        cin &gt;&gt; a[i];             // a[i] سندخل قيمة ،i لكل موقع\n    }\n\n    int sum = 0;\n    for (int i = 0 ; i &lt; n ; i++) {\n        sum += a[i];            // sum للمتغير  a[i] سنضيف قيمة ،i لكل موقع\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n}\n\nفي هذا المثال: ندخل عدد العناصر n من المستخدم. ثم ننشئ مصفوفة a بحجم n. ونستخدم حلقة لإدخال قيم المصفوفة. ثم نستخدم حلقة أخرى لحساب المجموع الكلي للعناصر وطباعة النتيجة.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المصفوفات"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html#المصفوفات-متعددة-الأبعاد",
    "href": "b0/cpp/arrays.html#المصفوفات-متعددة-الأبعاد",
    "title": "المصفوفات",
    "section": "",
    "text": "المصفوفات متعددة الأبعاد هي مصفوفات تحتوي على مصفوفات أخرى داخلها، أي أن كل عنصر يمكن أن يكون بدوره مصفوفة.\nيُطلق على كل مستوى من هذه المستويات اسم بُعد.\nانظر إلى المثال التالي:\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n  int a[5];\n  int b[5][4];\n}\n\nفي هذا البرنامج:\n\n\n\n\n\n\n\nالعنصر\nالشرح\n\n\n\n\na\nمصفوفة أحادية الأبعاد تحتوي على 5 أعداد صحيحة.\n\n\nb\nمصفوفة ثنائية الأبعاد، تتكون من 5 مصفوفات، تحتوي كل مصفوفة على 4 أعداد صحيحة.\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\na[0] تمثل عددًا صحيحًا، بينما b[0] تمثل مصفوفة من أربعة أعداد صحيحة.\n\n\nللوصول إلى عنصر داخل مصفوفة متعددة الأبعاد، يجب تحديد الموقع في كل بُعد:\nعلى سبيل المثال، للوصول إلى عنصر في a نكتب a[i]،\nأما للوصول إلى عنصر في b فنكتب b[i][j].\nإذا قمنا بتعبئة المصفوفة b ببعض القيم، يمكننا تمثيلها كما في الشكل التالي:\n\nفي هذا التمثيل: - b[0] هي مصفوفة من أربعة أعداد صحيحة. - b[2][1] هو العنصر الذي يحمل القيمة 14.\nعدد الخلايا الكلي في المصفوفة متعددة الأبعاد يساوي حاصل ضرب أطوال جميع الأبعاد.\nفي مثالنا السابق، تحتوي b على 5 * 4 = 20 عنصرًا.\nيمكن أن تحتوي المصفوفة على أكثر من بعدين، بل ويمكن أن تكون ذات سبعة أبعاد أو أكثر.\nعلى سبيل المثال، المصفوفة التالية تحتوي على سبعة أبعاد:\n\nint c[4][6][7][54][32][2][7];",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المصفوفات"
    ]
  },
  {
    "objectID": "b0/cpp/switch.html",
    "href": "b0/cpp/switch.html",
    "title": "عبارة switch",
    "section": "",
    "text": "تُستخدم عبارة switch لاختبار تعبير واحد مقابل عدّة قيم ثابتة.\nوهي تشبه سلاسل if-else، ولكنها أوضح وأنسب عند التعامل مع عدد كبير من الحالات الثابتة.\n\n\n\n\nswitch (expression) {\n    case constant1:\n        // statements\n        break;\n    case constant2:\n        // statements\n        break;\n    default:\n        // statements\n}\n\n\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x = 2;\n    switch (x) {\n        case 1:\n            cout &lt;&lt; \"x is 1\";\n            break;\n        case 2:\n            cout &lt;&lt; \"x is 2\";\n            break;\n        default:\n            cout &lt;&lt; \"value of x unknown\";\n    }\n}\n\nالناتج:\n\nx is 2\n\n\n\n\n\n\nتقوم عبارة switch بتقييم التعبير expression.\nتُقارن قيمته بكل حالة case على التوالي.\nعند تطابق القيمة مع إحدى الحالات، تُنفَّذ الاوامر في تلك الحالة حتى الوصول إلى عبارة break.\nإذا لم يحدث أي تطابق، تُنفَّذ حالة default (إن وُجدت).\n\n\n\n\n\nإذا لم تُكتب عبارة break بعد حالة معيّنة، يستمر التنفيذ إلى الحالة التالية:\n\nswitch (x) {\n    case 1:\n    case 2:\n    case 3:\n        cout &lt;&lt; \"x is 1, 2 or 3\";\n        break;\n    default:\n        cout &lt;&lt; \"x is not 1, 2 nor 3\";\n}\n\nفي هذا المثال، إذا كانت قيمة x هي 1 أو 2 أو 3، فستُنفَّذ نفس مجموعة الاوامر.\n\n\n\n\n\nعناوين الحالات case يجب أن تكون تعابير ثابتة (لا يمكن استخدام متغيّرات عادية).\nتُعد عبارة switch مناسبة عند مقارنة قيمة واحدة بعدّة خيارات ثابتة.\nفي المقارنات التي تتضمن نطاقات أو شروط معقّدة، يُفضَّل استخدام if وelse if."
  },
  {
    "objectID": "b0/cpp/switch.html#الصياغة-syntax",
    "href": "b0/cpp/switch.html#الصياغة-syntax",
    "title": "عبارة switch",
    "section": "",
    "text": "switch (expression) {\n    case constant1:\n        // statements\n        break;\n    case constant2:\n        // statements\n        break;\n    default:\n        // statements\n}"
  },
  {
    "objectID": "b0/cpp/switch.html#مثال",
    "href": "b0/cpp/switch.html#مثال",
    "title": "عبارة switch",
    "section": "",
    "text": "#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x = 2;\n    switch (x) {\n        case 1:\n            cout &lt;&lt; \"x is 1\";\n            break;\n        case 2:\n            cout &lt;&lt; \"x is 2\";\n            break;\n        default:\n            cout &lt;&lt; \"value of x unknown\";\n    }\n}\n\nالناتج:\n\nx is 2"
  },
  {
    "objectID": "b0/cpp/switch.html#كيف-تعمل",
    "href": "b0/cpp/switch.html#كيف-تعمل",
    "title": "عبارة switch",
    "section": "",
    "text": "تقوم عبارة switch بتقييم التعبير expression.\nتُقارن قيمته بكل حالة case على التوالي.\nعند تطابق القيمة مع إحدى الحالات، تُنفَّذ الاوامر في تلك الحالة حتى الوصول إلى عبارة break.\nإذا لم يحدث أي تطابق، تُنفَّذ حالة default (إن وُجدت)."
  },
  {
    "objectID": "b0/cpp/switch.html#سلوك-الانتقال-fallthrough",
    "href": "b0/cpp/switch.html#سلوك-الانتقال-fallthrough",
    "title": "عبارة switch",
    "section": "",
    "text": "إذا لم تُكتب عبارة break بعد حالة معيّنة، يستمر التنفيذ إلى الحالة التالية:\n\nswitch (x) {\n    case 1:\n    case 2:\n    case 3:\n        cout &lt;&lt; \"x is 1, 2 or 3\";\n        break;\n    default:\n        cout &lt;&lt; \"x is not 1, 2 nor 3\";\n}\n\nفي هذا المثال، إذا كانت قيمة x هي 1 أو 2 أو 3، فستُنفَّذ نفس مجموعة الاوامر."
  },
  {
    "objectID": "b0/cpp/switch.html#ملاحظات",
    "href": "b0/cpp/switch.html#ملاحظات",
    "title": "عبارة switch",
    "section": "",
    "text": "عناوين الحالات case يجب أن تكون تعابير ثابتة (لا يمكن استخدام متغيّرات عادية).\nتُعد عبارة switch مناسبة عند مقارنة قيمة واحدة بعدّة خيارات ثابتة.\nفي المقارنات التي تتضمن نطاقات أو شروط معقّدة، يُفضَّل استخدام if وelse if."
  },
  {
    "objectID": "b0/cpp/statements.html",
    "href": "b0/cpp/statements.html",
    "title": "العبارات والتحكم في المسار (Flow Control)",
    "section": "",
    "text": "التعليمة (statement) البسيطة في C++ هي واحدة من الأوامر الفردية في البرنامج — مثل تعريف متغيّر أو عبارة (expression).\nكل تعليمة بسيطة تنتهي بفاصلة منقوطة (；) وتُنفَّذ بالترتيب الذي تظهر به في الكود.\n\nint x = 5;\nx = x + 2;\ncout &lt;&lt; x;\n\nفي المثال أعلاه، كل سطر هو تعليمة بسيطة تنتهي بـ ; ويتم تنفيذها بالتسلسل من الأعلى إلى الأسفل.\n\n\nالبرامج لا تقتصر على تسلسل خطي من التعليمات فقط. في الواقع، قد يقوم البرنامج بـ:\n\nتكرار جزء معيّن من الكود (حلقات تكرار loops).\nاتخاذ قرارات لتنفيذ مسار مختلف من الكود (شروط conditionals).\n\nلتحقيق ذلك، توفّر C++ عبارات التحكم في المسار (flow control) — وهي أدوات تخبر البرنامج: ماذا يفعل، ومتى يفعله، وتحت أي شروط.\nأمثلة على ذلك:\n\nif / else (تفرّع شرطي)\nswitch (اختيار بين عدّة حالات)\nwhile، for، وdo-while (حلقات تكرار)\n\n\n\n\nالعبارة المركّبة هي مجموعة من التعليمات محصورة بين أقواس معقوفة {}، وتُعامل هذه المجموعة كأنها كتلة واحدة (block).\nتبدو العبارة المركّبة بهذا الشكل:\n\n{\n    statement1;\n    statement2;\n    statement3;\n}\n\nكل تعليمة داخل الكتلة تنتهي بفاصلة منقوطة خاصة بها، بينما تُعتبر الكتلة كاملة بمثابة تعليمة واحدة في سياق التحكم في المسار.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "العبارات والتحكم في المسار (Flow Control)"
    ]
  },
  {
    "objectID": "b0/cpp/statements.html#ما-بعد-التنفيذ-الخطي",
    "href": "b0/cpp/statements.html#ما-بعد-التنفيذ-الخطي",
    "title": "العبارات والتحكم في المسار (Flow Control)",
    "section": "",
    "text": "البرامج لا تقتصر على تسلسل خطي من التعليمات فقط. في الواقع، قد يقوم البرنامج بـ:\n\nتكرار جزء معيّن من الكود (حلقات تكرار loops).\nاتخاذ قرارات لتنفيذ مسار مختلف من الكود (شروط conditionals).\n\nلتحقيق ذلك، توفّر C++ عبارات التحكم في المسار (flow control) — وهي أدوات تخبر البرنامج: ماذا يفعل، ومتى يفعله، وتحت أي شروط.\nأمثلة على ذلك:\n\nif / else (تفرّع شرطي)\nswitch (اختيار بين عدّة حالات)\nwhile، for، وdo-while (حلقات تكرار)",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "العبارات والتحكم في المسار (Flow Control)"
    ]
  },
  {
    "objectID": "b0/cpp/statements.html#العبارات-المركبة-compound-statements",
    "href": "b0/cpp/statements.html#العبارات-المركبة-compound-statements",
    "title": "العبارات والتحكم في المسار (Flow Control)",
    "section": "",
    "text": "العبارة المركّبة هي مجموعة من التعليمات محصورة بين أقواس معقوفة {}، وتُعامل هذه المجموعة كأنها كتلة واحدة (block).\nتبدو العبارة المركّبة بهذا الشكل:\n\n{\n    statement1;\n    statement2;\n    statement3;\n}\n\nكل تعليمة داخل الكتلة تنتهي بفاصلة منقوطة خاصة بها، بينما تُعتبر الكتلة كاملة بمثابة تعليمة واحدة في سياق التحكم في المسار.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "العبارات والتحكم في المسار (Flow Control)"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html",
    "href": "b0/cpp/hello-world.html",
    "title": "!Hello World",
    "section": "",
    "text": "لنبدأ بتشغيل أوّل برنامج لك بلغة C++.\nلا داعي للقلق بشأن فهم البرنامج في هذه المرحلة؛ الهدف الآن هو التأكّد من أنّ كل شيء يعمل بشكل صحيح.\nأوّل ما تحتاج إليه هو تثبيت بيئة تطوير متكاملة (IDE)، وهي برنامج يُستخدم لكتابة البرنامج المصدرية وتشغيلها وإدارتها. توجد العديد من البيئات المختلفة، وسنشرح هنا استخدام Code::Blocks، ويمكنك لاحقًا تجربة أي بيئة أخرى تناسبك.\n\n\n\n\n\nتوجّه إلى صفحة تحميل Code::Blocks:\n\n\nCode::Blocks downloads page\n\n\nقم بتحميل ملف التثبيت:\n\n\ncodeblocks-25.03mingw-setup.exe\n\n(قد تجد إصدارًا أحدث يحمل رقمًا مختلفًا بدل 25.03؛ اختر الإصدار الذي يحتوي على MinGW.)\n\nهذا الإصدار يتضمّن مترجم MinGW، لذلك لا حاجة لتثبيت مترجم منفصل.\n\n\nشغّل ملف التثبيت واترك الخيارات الافتراضية كما هي.\n\n\n\n\nإصدار Code::Blocks الخاص بنظام macOS أقدم، ولا يتضمّن مترجمًا. لا يزال مناسبًا للمشروعات البسيطة، لكن يجب تثبيت المترجم أولًا.\n\nقم بتثبيت أدوات سطر الأوامر من Apple (توفّر المترجم clang):\n\n\nxcode-select --install\n\n\nقم بتحميل الملف:\n\n\nCodeBlocks-25.03_macOS-11.7_x64-wx3.2.6.dmg\n\nمن صفحة التحميل، ثم ثبّته (قد تجد إصدارًا أحدث برقم مختلف).\n\nإذا لم يستطع Code::Blocks العثور على المترجم عند التشغيل لأول مرة:\n\nاذهب إلى Settings → Compiler\nواختر Clang إذا كان متاحًا.\n\n\n\n\n\n\n\n\nTip\n\n\n\nإذا بدا لك Code::Blocks غير مريح (خصوصًا على macOS)، يمكنك استخدام CLion أو VS Code أو أي بيئة تطوير أخرى. توجد ملاحظات إضافية عن هذه الأدوات في نهاية هذا الفصل.\n\n\n\n\n\n\n\nافتح برنامج Code::Blocks.\nمن القائمة الرئيسية اختر: File → New → Project → Console application.\nاختر C++ ثم اضغط Next.\nأدخِل اسمًا للمشروع، مثلًا:\n\n\nHelloWorld\n\n\nاختر مجلدًا لحفظ المشروع، ثم اضغط Finish.\n\nسيقوم Code::Blocks بإنشاء مشروع يحتوي على ملف باسم:\n\nmain.cpp\n\n\n\n\nافتح الملف main.cpp واستبدل محتواه بالكامل بالبرنامج التالية:\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\";\n    return 0;\n}\n\n\n\n\n\nاضغط على Build and run (الزر ذو المثلث الأخضر) أو على الزر F9.\nينبغي أن يظهر لديك الإخراج التالي:\n\n\nHello, World!\n\nأحسنت، لقد شغّلت أول برنامج لك بلغة C++.\n\n\n\nعند الضغط على Build، يقوم Code::Blocks باستدعاء المترجم (MinGW على Windows أو Clang على macOS).\nيقوم المترجم بتحويل البرنامج المصدرية إلى ملف تنفيذي (Binary) يمكن لنظام التشغيل تشغيله مباشرة. في نظام Windows يكون امتداد الملف عادة:\n\n.exe\n\nلاحقًا ستتعرّف بمزيد من التفصيل على المترجم (Compiler)، والـ Linker، وإعدادات البناء (Build Settings). في هذه المرحلة، يكفي فهم الفكرة العامة.\n\n\n\nتوجد بيئات تطوير وأدوات تحرير أخرى تدعم C++، من بينها:\n\nCLion\nVS Code\n\nهذه الأدوات قد تحتاج إلى بعض الإعدادات الإضافية، لكنها غالبًا أكثر قوة ومرونة.\n\nعلى نظامي Windows وmacOS ستحتاج إلى تثبيت مترجم (مثل MinGW أو Clang).\nفي نظام Linux غالبًا يكون المترجم GCC متوفرًا مسبقًا.\nإذا استخدمت VS Code، فاحرص على تثبيت إضافة C/C++.\n\nكما توجد منصات برمجية عبر المتصفح (Online IDEs)، وهي مفيدة للبدء بسرعة، ولكنها ليست الخيار الأمثل للاستخدام الطويل أو المشاريع الكبيرة.\nفي الوقت الحالي، يُعد Code::Blocks نقطة بداية بسيطة ومباشرة.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "!Hello World"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html#الخطوة-1-تثبيت-codeblocks",
    "href": "b0/cpp/hello-world.html#الخطوة-1-تثبيت-codeblocks",
    "title": "!Hello World",
    "section": "",
    "text": "توجّه إلى صفحة تحميل Code::Blocks:\n\n\nCode::Blocks downloads page\n\n\nقم بتحميل ملف التثبيت:\n\n\ncodeblocks-25.03mingw-setup.exe\n\n(قد تجد إصدارًا أحدث يحمل رقمًا مختلفًا بدل 25.03؛ اختر الإصدار الذي يحتوي على MinGW.)\n\nهذا الإصدار يتضمّن مترجم MinGW، لذلك لا حاجة لتثبيت مترجم منفصل.\n\n\nشغّل ملف التثبيت واترك الخيارات الافتراضية كما هي.\n\n\n\n\nإصدار Code::Blocks الخاص بنظام macOS أقدم، ولا يتضمّن مترجمًا. لا يزال مناسبًا للمشروعات البسيطة، لكن يجب تثبيت المترجم أولًا.\n\nقم بتثبيت أدوات سطر الأوامر من Apple (توفّر المترجم clang):\n\n\nxcode-select --install\n\n\nقم بتحميل الملف:\n\n\nCodeBlocks-25.03_macOS-11.7_x64-wx3.2.6.dmg\n\nمن صفحة التحميل، ثم ثبّته (قد تجد إصدارًا أحدث برقم مختلف).\n\nإذا لم يستطع Code::Blocks العثور على المترجم عند التشغيل لأول مرة:\n\nاذهب إلى Settings → Compiler\nواختر Clang إذا كان متاحًا.\n\n\n\n\n\n\n\n\nTip\n\n\n\nإذا بدا لك Code::Blocks غير مريح (خصوصًا على macOS)، يمكنك استخدام CLion أو VS Code أو أي بيئة تطوير أخرى. توجد ملاحظات إضافية عن هذه الأدوات في نهاية هذا الفصل.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "!Hello World"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html#الخطوة-2-إنشاء-مشروع-جديد",
    "href": "b0/cpp/hello-world.html#الخطوة-2-إنشاء-مشروع-جديد",
    "title": "!Hello World",
    "section": "",
    "text": "افتح برنامج Code::Blocks.\nمن القائمة الرئيسية اختر: File → New → Project → Console application.\nاختر C++ ثم اضغط Next.\nأدخِل اسمًا للمشروع، مثلًا:\n\n\nHelloWorld\n\n\nاختر مجلدًا لحفظ المشروع، ثم اضغط Finish.\n\nسيقوم Code::Blocks بإنشاء مشروع يحتوي على ملف باسم:\n\nmain.cpp",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "!Hello World"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html#الخطوة-3-كتابة-أول-برنامج",
    "href": "b0/cpp/hello-world.html#الخطوة-3-كتابة-أول-برنامج",
    "title": "!Hello World",
    "section": "",
    "text": "افتح الملف main.cpp واستبدل محتواه بالكامل بالبرنامج التالية:\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\";\n    return 0;\n}",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "!Hello World"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html#الخطوة-4-البناء-والتشغيل",
    "href": "b0/cpp/hello-world.html#الخطوة-4-البناء-والتشغيل",
    "title": "!Hello World",
    "section": "",
    "text": "اضغط على Build and run (الزر ذو المثلث الأخضر) أو على الزر F9.\nينبغي أن يظهر لديك الإخراج التالي:\n\n\nHello, World!\n\nأحسنت، لقد شغّلت أول برنامج لك بلغة C++.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "!Hello World"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html#ما-الذي-حدث-فعليا-باختصار",
    "href": "b0/cpp/hello-world.html#ما-الذي-حدث-فعليا-باختصار",
    "title": "!Hello World",
    "section": "",
    "text": "عند الضغط على Build، يقوم Code::Blocks باستدعاء المترجم (MinGW على Windows أو Clang على macOS).\nيقوم المترجم بتحويل البرنامج المصدرية إلى ملف تنفيذي (Binary) يمكن لنظام التشغيل تشغيله مباشرة. في نظام Windows يكون امتداد الملف عادة:\n\n.exe\n\nلاحقًا ستتعرّف بمزيد من التفصيل على المترجم (Compiler)، والـ Linker، وإعدادات البناء (Build Settings). في هذه المرحلة، يكفي فهم الفكرة العامة.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "!Hello World"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html#بيئات-تطوير-أخرى-مقترحة",
    "href": "b0/cpp/hello-world.html#بيئات-تطوير-أخرى-مقترحة",
    "title": "!Hello World",
    "section": "",
    "text": "توجد بيئات تطوير وأدوات تحرير أخرى تدعم C++، من بينها:\n\nCLion\nVS Code\n\nهذه الأدوات قد تحتاج إلى بعض الإعدادات الإضافية، لكنها غالبًا أكثر قوة ومرونة.\n\nعلى نظامي Windows وmacOS ستحتاج إلى تثبيت مترجم (مثل MinGW أو Clang).\nفي نظام Linux غالبًا يكون المترجم GCC متوفرًا مسبقًا.\nإذا استخدمت VS Code، فاحرص على تثبيت إضافة C/C++.\n\nكما توجد منصات برمجية عبر المتصفح (Online IDEs)، وهي مفيدة للبدء بسرعة، ولكنها ليست الخيار الأمثل للاستخدام الطويل أو المشاريع الكبيرة.\nفي الوقت الحالي، يُعد Code::Blocks نقطة بداية بسيطة ومباشرة.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "!Hello World"
    ]
  },
  {
    "objectID": "b0/cpp/do.html",
    "href": "b0/cpp/do.html",
    "title": "🔁 حلقة do-while",
    "section": "",
    "text": "حلقة do-while تشبه حلقة while،\nلكنها تنفّذ الكتلة مرة واحدة على الأقل لأن الشرط يتم فحصه بعد التنفيذ.\n\n\n\n\ndo\n    statement;\nwhile (condition);\n\n\nفيما يلي نسخة أبسط وأسهل فهمًا من مثال آلة الصدى (Echo Machine) — باستخدام الأعداد بدل السلاسل النصية، حتى يركّز المبتدئون على كيفية تكرار الحلقة وتوقّفها.\n\n\n\n\n\n// number repeater using do-while\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int number;\n    do {\n        cout &lt;&lt; \"Enter a number (0 to stop): \";\n        cin &gt;&gt; number;\n        cout &lt;&lt; \"You entered: \" &lt;&lt; number &lt;&lt; endl;\n    } while (number != 0);\n\n    cout &lt;&lt; \"Loop ended because you entered 0.\" &lt;&lt; endl;\n}\n\n\n\n\n\nEnter a number (0 to stop): 5\nYou entered: 5\nEnter a number (0 to stop): 8\nYou entered: 8\nEnter a number (0 to stop): 0\nYou entered: 0\nLoop ended because you entered 0.\n\n\n\n\n\n\nيطلب البرنامج إدخال عدد ثم يقوم بطباعته.\nبعد الطباعة، يتم فحص الشرط:\n\nإذا كان العدد لا يساوي 0، تتكرّر الحلقة.\nإذا كان العدد يساوي 0، تتوقّف الحلقة.\n\nتظهر الرسالة \"Loop ended because you entered 0.\" بعد انتهاء الحلقة.\n\nالفكرة الأساسية: حلقة do-while تُنفَّذ دائمًا مرة واحدة على الأقل، حتى لو أدخل المستخدم 0 من أوّل مرة، لأن فحص الشرط يحدث بعد تنفيذ الكتلة الأولى."
  },
  {
    "objectID": "b0/cpp/do.html#الصياغة-syntax",
    "href": "b0/cpp/do.html#الصياغة-syntax",
    "title": "🔁 حلقة do-while",
    "section": "",
    "text": "do\n    statement;\nwhile (condition);\n\n\nفيما يلي نسخة أبسط وأسهل فهمًا من مثال آلة الصدى (Echo Machine) — باستخدام الأعداد بدل السلاسل النصية، حتى يركّز المبتدئون على كيفية تكرار الحلقة وتوقّفها."
  },
  {
    "objectID": "b0/cpp/do.html#مثال-مكرر-الأعداد-البسيط",
    "href": "b0/cpp/do.html#مثال-مكرر-الأعداد-البسيط",
    "title": "🔁 حلقة do-while",
    "section": "",
    "text": "// number repeater using do-while\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int number;\n    do {\n        cout &lt;&lt; \"Enter a number (0 to stop): \";\n        cin &gt;&gt; number;\n        cout &lt;&lt; \"You entered: \" &lt;&lt; number &lt;&lt; endl;\n    } while (number != 0);\n\n    cout &lt;&lt; \"Loop ended because you entered 0.\" &lt;&lt; endl;\n}\n\n\n\n\n\nEnter a number (0 to stop): 5\nYou entered: 5\nEnter a number (0 to stop): 8\nYou entered: 8\nEnter a number (0 to stop): 0\nYou entered: 0\nLoop ended because you entered 0.\n\n\n\n\n\n\nيطلب البرنامج إدخال عدد ثم يقوم بطباعته.\nبعد الطباعة، يتم فحص الشرط:\n\nإذا كان العدد لا يساوي 0، تتكرّر الحلقة.\nإذا كان العدد يساوي 0، تتوقّف الحلقة.\n\nتظهر الرسالة \"Loop ended because you entered 0.\" بعد انتهاء الحلقة.\n\nالفكرة الأساسية: حلقة do-while تُنفَّذ دائمًا مرة واحدة على الأقل، حتى لو أدخل المستخدم 0 من أوّل مرة، لأن فحص الشرط يحدث بعد تنفيذ الكتلة الأولى."
  },
  {
    "objectID": "b0/cpp/operators.html",
    "href": "b0/cpp/operators.html",
    "title": "العوامل (Operators)",
    "section": "",
    "text": "تُستخدم العوامل في إجراء العمليات الحسابية أو تعديل القيم المخزّنة في المتغيّرات. وفيما يلي قائمة بأهم العوامل الأساسية في لغة C++.\n\n\n\nيُستخدم عامل الإسناد لتعيين قيمة محدّدة إلى متغيّر.\n\nint x;\nx = 5; // here we set the value of the variable 'x' to 5\n\nفي المثال السابق، تم إسناد القيمة 5 (العامل الأيمن) إلى المتغيّر x (العامل الأيسر). يتم التقييم من اليمين إلى اليسار (سيتم توضيح ذلك بمزيد من الأمثلة لاحقًا).\n\n\n\n\n\n\n\nالعامل\nالمعنى\n\n\n\n\n*\nالضرب\n\n\n/\nالقسمة\n\n\n%\nباقي القسمة (modulo)\n\n\n+\nالجمع\n\n\n-\nالطرح\n\n\n\nجميع هذه العوامل هي ثنائية، أي تتطلّب عاملين (operands). على سبيل المثال:\n\n5 * 3\n1 + 1\n6 / 2\n\nيعيد عامل باقي القسمة (%) الباقي الناتج من قسمة العامل الأيسر على العامل الأيمن. أما العمليات الأخرى فتُنفَّذ تمامًا كما في الرياضيات العادية.\n\n\n\n\nالقيمة المسندة إلى متغيّر ليست بالضرورة ثابتة أو متغيّرًا آخر؛ إذ يمكن أن تكون تعبيرًا حسابيًا يحتوي على عوامل رياضية.\n\nint x, y;\nx = 5;\ny = 3 + 2 * x;\n// since '*' comes before '+' in operator precedence, y will be 13 not 25\n\n\n\n\n\nإذا كان لدينا المتغيّر x ونرغب في إضافة أو ضرب أو تعديل قيمته ثم إسناد النتيجة إلى نفسه، يمكننا استخدام الصيغ المركّبة بدلًا من الكتابة الطويلة.\n\n\n\n\n\n\n\nالتعبير العادي\nباستخدام الإسناد المركّب\n\n\n\n\nx = x + y\nx += y\n\n\nx = x - 5\nx -= 5\n\n\nx = x / y\nx /= y\n\n\nprice = price * (units + 1)\nprice *= units + 1\n\n\n\nتُعد هذه الطريقة أكثر اختصارًا ووضوحًا.\n\n\n\n\nعند إضافة 1 إلى متغيّر ما، يمكننا استخدام x += 1، ولكن توجد طريقة أقصر عند التعامل مع الزيادة أو النقصان بمقدار واحد فقط.\n\nint x;\nx = 0;\nx++; // after this line is executed x is 1\nx--; // after this line is executed x is 0\n\nيوجد فرق دقيق بين ++ و += 1، إذ يمكن كتابة ++ أو -- قبل المتغيّر (prefix) أو بعده (suffix)، ولكل موضع معنى مختلف. على سبيل المثال:\n\nint x, y;\nx = 1;\ny = ++x;\n\nفي هذا المثال ستكون قيمة y هي 2 لأن الزيادة تحدث قبل استخدام القيمة.\n\nint x, y;\nx = 1;\ny = x++;\n\nبينما هنا ستكون قيمة y هي 1 لأن الزيادة تتم بعد استخدام القيمة.\n\n\n\n\n==, !=, &gt;, &lt;, &gt;=, &lt;=\nتشبه هذه العوامل العوامل الحسابية من حيث أنها ثنائية، ولكن بدلاً من إجراء عمليات رياضية، تقوم بالمقارنة بين العاملين وتُرجع نتيجة من نوع منطقي (boolean).\nتذكير: القيم المنطقية (Booleans) هي نوع بيانات يُخزّن قيمة إمّا true أو false.\n\n\n\nالعامل\nالوصف\n\n\n\n\n==\nيساوي\n\n\n!=\nلا يساوي\n\n\n&lt;\nأصغر من\n\n\n&gt;\nأكبر من\n\n\n&lt;=\nأصغر من أو يساوي\n\n\n&gt;=\nأكبر من أو يساوي\n\n\n\n\nint x = 1, y = 2; \nbool same = (x==y); // since x and y are not equal (x==y) will be 'false'\nbool x_less_than_y = (x &lt; y); // since x &lt; y the expression will be 'true'\n\nيمكن أيضًا مقارنة تعابير كاملة وليس متغيّرات فقط:\n\nint x = 5;\nbool even = (x % 2 == 0);\n// a number is even if it can be divided by 2 with no remainder\n// in this case 'false' will be assigned to the variable 'even'\n\n\n\n\n\nالعامل ! (NOT) هو أحادي (unary)، أي يعمل على عامل واحد من نوع منطقي. إذا كانت قيمة العامل true يُنتِج false، والعكس صحيح.\n\nbool a = (5 &gt; 7);  // false\nbool b = !a;       // true\nbool c = !(7 &gt; 5); // false\n\nأما العاملان && (AND) و || (OR) فهما ثنائيان، ويُستخدمان لدمج قيمتين منطقيتين.\nالعامل && يُرجع true فقط إذا كانت كلتا القيمتين true.\n\nbool a = (5 % 2 == 0); // false, 5 is odd\nbool b = (3 &gt; 2); // true\nbool c = a && b; // false because a is false\nbool d = (!c) && b; // true because (!c) is true and b is true\n\nأما العامل || فيُرجع true إذا كانت إحدى القيمتين أو كلتاهما true.\n\nbool a = (5 &lt; 2); // false\nbool b = (4 % 2 == 0); // true, 4 is even\nbool c = a && b; // false, because a is false\nbool d = b || c; //  true, because b is true\n\n\n\nتتميّز العوامل && و || بخاصية التقييم القصير. على سبيل المثال، في التعبير A && B، إذا كانت A تساوي false، فلن يتم تقييم B لأن النتيجة معروفة مسبقًا (false).\n\nint x = 0;\nbool b = (5 % 2 == 0) && (x++ == 0); \n\nبما أن 5 % 2 == 0 تُعيد false، فلن يُنفَّذ الجزء الثاني (x++ == 0)، ولذلك لن تتغيّر قيمة x. وبالمثل، في حالة العامل ||، إذا كان العامل الأيسر true، فلن يتم تقييم العامل الأيمن.\n\n\n\n\n\nيُعد هذا العامل ثلاثيًّا (ternary) لأنه يقبل ثلاثة عوامل: شرطًا، وتعبيرًا عند تحقق الشرط، وآخر عند عدم تحققه. وصيغته العامة كالتالي:\n\ncondition ? expression_t : expression_f\n\nإذا كان الشرط صحيحًا (true)، تُعاد القيمة expression_t، وإلا تُعاد expression_f.\n\nint x = 5;\nint y = (x % 2 == 0 ? x : x + 1); // if x is even then y = x, otherwise y = x + 1\n                                  // since 5 is odd then y = x + 1 = 6\n\nوإذا كان لدينا عددان a و b ونرغب في معرفة الأكبر بينهما:\n\nint max = (a &gt; b ? a : b);\n\n\n\n\n\nعند وجود عدّة عوامل في تعبير واحد، فإن C++ تتّبع ترتيبًا محددًا لتنفيذها. على سبيل المثال: التعبير 5 + 7 % 2 يُقيَّم إلى 6 لأن % يُنفّذ قبل +. أما إذا كتبنا (5 + 7) % 2 فستكون النتيجة 0.\nالجدول التالي يوضّح ترتيب الأولوية من الأعلى إلى الأدنى:\n\n\n\n\n\n\n\n\n\n\n\n\nالمستوى\nمجموعة الأولوية\nالعامل\nالوصف\nاتجاه التنفيذ\n\n\n\n\n\n\n1\nلاحقة (أحادية)\n++ --\nزيادة/نقصان بعدية\nمن اليسار إلى اليمين\n\n\n\n\n2\nسابقة (أحادية)\n++ -- !\nزيادة/نقصان سابقة، نفي منطقي\nمن اليمين إلى اليسار\n\n\n\n\n3\nحسابية: الضرب والقسمة\n* / %\nالضرب، القسمة، باقي القسمة\nمن اليسار إلى اليمين\n\n\n\n\n4\nحسابية: الجمع والطرح\n+ -\nالجمع والطرح\nمن اليسار إلى اليمين\n\n\n\n\n5\nعلاقية\n&lt; &gt; &lt;= &gt;=\nالمقارنة بين القيم\nمن اليسار إلى اليمين\n\n\n\n\n6\nالمساواة\n== !=\nالتساوي وعدم التساوي\nمن اليسار إلى اليمين\n\n\n\n\n7\nاقتران منطقي (AND)\n&&\nمنطق AND\nمن اليسار إلى اليمين\n\n\n\n\n8\nاقتران منطقي (OR)\n|                               |\nمنطق OR\nمن اليسار إلى اليمين\n\n\n\n\n9\nالإسناد والتعبيرات الشرطية\n= *= /= %= += -= ?:\nإسناد، إسناد مركّب، عامل شرطي\nمن اليمين إلى اليسار\n\n\n\n\n\n\nباختصار، معرفة ترتيب أولوية العوامل أمر ضروري لتفسير سلوك التعابير الحسابية والمنطقية بشكلٍ صحيح في C++.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "العوامل (Operators)"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#عامل-الإسناد",
    "href": "b0/cpp/operators.html#عامل-الإسناد",
    "title": "العوامل (Operators)",
    "section": "",
    "text": "يُستخدم عامل الإسناد لتعيين قيمة محدّدة إلى متغيّر.\n\nint x;\nx = 5; // here we set the value of the variable 'x' to 5\n\nفي المثال السابق، تم إسناد القيمة 5 (العامل الأيمن) إلى المتغيّر x (العامل الأيسر). يتم التقييم من اليمين إلى اليسار (سيتم توضيح ذلك بمزيد من الأمثلة لاحقًا).",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "العوامل (Operators)"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#العوامل-الحسابية--",
    "href": "b0/cpp/operators.html#العوامل-الحسابية--",
    "title": "العوامل (Operators)",
    "section": "",
    "text": "العامل\nالمعنى\n\n\n\n\n*\nالضرب\n\n\n/\nالقسمة\n\n\n%\nباقي القسمة (modulo)\n\n\n+\nالجمع\n\n\n-\nالطرح\n\n\n\nجميع هذه العوامل هي ثنائية، أي تتطلّب عاملين (operands). على سبيل المثال:\n\n5 * 3\n1 + 1\n6 / 2\n\nيعيد عامل باقي القسمة (%) الباقي الناتج من قسمة العامل الأيسر على العامل الأيمن. أما العمليات الأخرى فتُنفَّذ تمامًا كما في الرياضيات العادية.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "العوامل (Operators)"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#إسناد-التعابير-assigning-expressions",
    "href": "b0/cpp/operators.html#إسناد-التعابير-assigning-expressions",
    "title": "العوامل (Operators)",
    "section": "",
    "text": "القيمة المسندة إلى متغيّر ليست بالضرورة ثابتة أو متغيّرًا آخر؛ إذ يمكن أن تكون تعبيرًا حسابيًا يحتوي على عوامل رياضية.\n\nint x, y;\nx = 5;\ny = 3 + 2 * x;\n// since '*' comes before '+' in operator precedence, y will be 13 not 25",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "العوامل (Operators)"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#الإسناد-المركب--",
    "href": "b0/cpp/operators.html#الإسناد-المركب--",
    "title": "العوامل (Operators)",
    "section": "",
    "text": "إذا كان لدينا المتغيّر x ونرغب في إضافة أو ضرب أو تعديل قيمته ثم إسناد النتيجة إلى نفسه، يمكننا استخدام الصيغ المركّبة بدلًا من الكتابة الطويلة.\n\n\n\n\n\n\n\nالتعبير العادي\nباستخدام الإسناد المركّب\n\n\n\n\nx = x + y\nx += y\n\n\nx = x - 5\nx -= 5\n\n\nx = x / y\nx /= y\n\n\nprice = price * (units + 1)\nprice *= units + 1\n\n\n\nتُعد هذه الطريقة أكثر اختصارًا ووضوحًا.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "العوامل (Operators)"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#الزيادة-والنقصان---",
    "href": "b0/cpp/operators.html#الزيادة-والنقصان---",
    "title": "العوامل (Operators)",
    "section": "",
    "text": "عند إضافة 1 إلى متغيّر ما، يمكننا استخدام x += 1، ولكن توجد طريقة أقصر عند التعامل مع الزيادة أو النقصان بمقدار واحد فقط.\n\nint x;\nx = 0;\nx++; // after this line is executed x is 1\nx--; // after this line is executed x is 0\n\nيوجد فرق دقيق بين ++ و += 1، إذ يمكن كتابة ++ أو -- قبل المتغيّر (prefix) أو بعده (suffix)، ولكل موضع معنى مختلف. على سبيل المثال:\n\nint x, y;\nx = 1;\ny = ++x;\n\nفي هذا المثال ستكون قيمة y هي 2 لأن الزيادة تحدث قبل استخدام القيمة.\n\nint x, y;\nx = 1;\ny = x++;\n\nبينما هنا ستكون قيمة y هي 1 لأن الزيادة تتم بعد استخدام القيمة.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "العوامل (Operators)"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#العوامل-العلاقية-relational-والمقارنة-comparison",
    "href": "b0/cpp/operators.html#العوامل-العلاقية-relational-والمقارنة-comparison",
    "title": "العوامل (Operators)",
    "section": "",
    "text": "==, !=, &gt;, &lt;, &gt;=, &lt;=\nتشبه هذه العوامل العوامل الحسابية من حيث أنها ثنائية، ولكن بدلاً من إجراء عمليات رياضية، تقوم بالمقارنة بين العاملين وتُرجع نتيجة من نوع منطقي (boolean).\nتذكير: القيم المنطقية (Booleans) هي نوع بيانات يُخزّن قيمة إمّا true أو false.\n\n\n\nالعامل\nالوصف\n\n\n\n\n==\nيساوي\n\n\n!=\nلا يساوي\n\n\n&lt;\nأصغر من\n\n\n&gt;\nأكبر من\n\n\n&lt;=\nأصغر من أو يساوي\n\n\n&gt;=\nأكبر من أو يساوي\n\n\n\n\nint x = 1, y = 2; \nbool same = (x==y); // since x and y are not equal (x==y) will be 'false'\nbool x_less_than_y = (x &lt; y); // since x &lt; y the expression will be 'true'\n\nيمكن أيضًا مقارنة تعابير كاملة وليس متغيّرات فقط:\n\nint x = 5;\nbool even = (x % 2 == 0);\n// a number is even if it can be divided by 2 with no remainder\n// in this case 'false' will be assigned to the variable 'even'",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "العوامل (Operators)"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#العوامل-المنطقية-logical-operators",
    "href": "b0/cpp/operators.html#العوامل-المنطقية-logical-operators",
    "title": "العوامل (Operators)",
    "section": "",
    "text": "العامل ! (NOT) هو أحادي (unary)، أي يعمل على عامل واحد من نوع منطقي. إذا كانت قيمة العامل true يُنتِج false، والعكس صحيح.\n\nbool a = (5 &gt; 7);  // false\nbool b = !a;       // true\nbool c = !(7 &gt; 5); // false\n\nأما العاملان && (AND) و || (OR) فهما ثنائيان، ويُستخدمان لدمج قيمتين منطقيتين.\nالعامل && يُرجع true فقط إذا كانت كلتا القيمتين true.\n\nbool a = (5 % 2 == 0); // false, 5 is odd\nbool b = (3 &gt; 2); // true\nbool c = a && b; // false because a is false\nbool d = (!c) && b; // true because (!c) is true and b is true\n\nأما العامل || فيُرجع true إذا كانت إحدى القيمتين أو كلتاهما true.\n\nbool a = (5 &lt; 2); // false\nbool b = (4 % 2 == 0); // true, 4 is even\nbool c = a && b; // false, because a is false\nbool d = b || c; //  true, because b is true\n\n\n\nتتميّز العوامل && و || بخاصية التقييم القصير. على سبيل المثال، في التعبير A && B، إذا كانت A تساوي false، فلن يتم تقييم B لأن النتيجة معروفة مسبقًا (false).\n\nint x = 0;\nbool b = (5 % 2 == 0) && (x++ == 0); \n\nبما أن 5 % 2 == 0 تُعيد false، فلن يُنفَّذ الجزء الثاني (x++ == 0)، ولذلك لن تتغيّر قيمة x. وبالمثل، في حالة العامل ||، إذا كان العامل الأيسر true، فلن يتم تقييم العامل الأيمن.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "العوامل (Operators)"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#العامل-الثلاثي-الشرطي-conditional-ternary-operator",
    "href": "b0/cpp/operators.html#العامل-الثلاثي-الشرطي-conditional-ternary-operator",
    "title": "العوامل (Operators)",
    "section": "",
    "text": "يُعد هذا العامل ثلاثيًّا (ternary) لأنه يقبل ثلاثة عوامل: شرطًا، وتعبيرًا عند تحقق الشرط، وآخر عند عدم تحققه. وصيغته العامة كالتالي:\n\ncondition ? expression_t : expression_f\n\nإذا كان الشرط صحيحًا (true)، تُعاد القيمة expression_t، وإلا تُعاد expression_f.\n\nint x = 5;\nint y = (x % 2 == 0 ? x : x + 1); // if x is even then y = x, otherwise y = x + 1\n                                  // since 5 is odd then y = x + 1 = 6\n\nوإذا كان لدينا عددان a و b ونرغب في معرفة الأكبر بينهما:\n\nint max = (a &gt; b ? a : b);",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "العوامل (Operators)"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#أولوية-تنفيذ-العوامل-precedence-of-operators",
    "href": "b0/cpp/operators.html#أولوية-تنفيذ-العوامل-precedence-of-operators",
    "title": "العوامل (Operators)",
    "section": "",
    "text": "عند وجود عدّة عوامل في تعبير واحد، فإن C++ تتّبع ترتيبًا محددًا لتنفيذها. على سبيل المثال: التعبير 5 + 7 % 2 يُقيَّم إلى 6 لأن % يُنفّذ قبل +. أما إذا كتبنا (5 + 7) % 2 فستكون النتيجة 0.\nالجدول التالي يوضّح ترتيب الأولوية من الأعلى إلى الأدنى:\n\n\n\n\n\n\n\n\n\n\n\n\nالمستوى\nمجموعة الأولوية\nالعامل\nالوصف\nاتجاه التنفيذ\n\n\n\n\n\n\n1\nلاحقة (أحادية)\n++ --\nزيادة/نقصان بعدية\nمن اليسار إلى اليمين\n\n\n\n\n2\nسابقة (أحادية)\n++ -- !\nزيادة/نقصان سابقة، نفي منطقي\nمن اليمين إلى اليسار\n\n\n\n\n3\nحسابية: الضرب والقسمة\n* / %\nالضرب، القسمة، باقي القسمة\nمن اليسار إلى اليمين\n\n\n\n\n4\nحسابية: الجمع والطرح\n+ -\nالجمع والطرح\nمن اليسار إلى اليمين\n\n\n\n\n5\nعلاقية\n&lt; &gt; &lt;= &gt;=\nالمقارنة بين القيم\nمن اليسار إلى اليمين\n\n\n\n\n6\nالمساواة\n== !=\nالتساوي وعدم التساوي\nمن اليسار إلى اليمين\n\n\n\n\n7\nاقتران منطقي (AND)\n&&\nمنطق AND\nمن اليسار إلى اليمين\n\n\n\n\n8\nاقتران منطقي (OR)\n|                               |\nمنطق OR\nمن اليسار إلى اليمين\n\n\n\n\n9\nالإسناد والتعبيرات الشرطية\n= *= /= %= += -= ?:\nإسناد، إسناد مركّب، عامل شرطي\nمن اليمين إلى اليسار\n\n\n\n\n\n\nباختصار، معرفة ترتيب أولوية العوامل أمر ضروري لتفسير سلوك التعابير الحسابية والمنطقية بشكلٍ صحيح في C++.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "العوامل (Operators)"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html",
    "href": "b0/cpp/constants.html",
    "title": "الثوابت (Constants)",
    "section": "",
    "text": "أحيانًا نحتاج إلى قيمة لا تتغيّر أثناء تشغيل البرنامج، وهذا بالضبط هو دور الثوابت (constants).\nتساعد الثوابت في منع الأخطاء (مثل تغيير رقمٍ بالخطأ) وتجعل الكود أسهل في الفهم.\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int age = 15;\n    age = 16; // we can change it\n\n    const double PI = 3.14159;\n    // PI = 3.14;  Error! cannot change a constant\n\n    cout &lt;&lt; \"PI is \" &lt;&lt; PI &lt;&lt; endl;\n    return 0;\n}\n\nالمخرجات:\n\nPI is 3.14159\n\n\n\n\n\nلحماية القيم المهمة من التغيير غير المقصود.\nلجعل الكود أوضح وأسهل قراءة — المتغيّر PI أكثر وضوحًا من الرقم 3.14159.\nلتسهيل التحديث — إذا تغيّرت قيمة PI (وإن كان ذلك غير محتمل)، يمكن تعديلها في مكانٍ واحد فقط.\n\n\n\n\nيتم إنشاء ثابت في C++ بإضافة الكلمة المفتاحية const قبل نوع البيانات:\n\nconst int DAYS_IN_WEEK = 7;\nconst double GRAVITY = 9.81;\nconst char GRADE = 'A';\n\nيجب أن تُعطى الثوابت قيمة لحظة تعريفها ولا يمكن تركها دون تهيئة.\n\n\n\nالثوابت الحرفية هي القيم التي تظهر مباشرةً في الكود، مثل:\n\nint x = 5;         // 5 is an integer literal\ndouble pi = 3.14;  // 3.14 is a double literal\nchar letter = 'A'; // 'A' is a character literal\nstring word = \"Hi\"; // \"Hi\" is a string literal\n\nهذه مجرّد قيم خام (raw values) تُكتب مباشرةً داخل الكود.\n\n\nيمكنك أن تخبر C++ بنوع القيمة العددية باستخدام اللواحق (suffixes) التالية:\n\n\n\n\n\n\n\n\nالقيمة الحرفية\nالنوع\nالمعنى\n\n\n\n\n5\nint\nعدد صحيح افتراضي\n\n\n5U\nunsigned int\nعدد صحيح غير سالب\n\n\n5L\nlong\nعدد صحيح طويل\n\n\n5LL\nlong long\nعدد صحيح كبير جدًا\n\n\n3.14f\nfloat\nعدد عشري بدقة مفردة\n\n\n3.14\ndouble\nالنوع الافتراضي للأعداد العشرية\n\n\n3.14L\nlong double\nعدد عشري بدقة عالية\n\n\n\nمثال:\n\nfloat a = 3.14f;\nlong long b = 10000000000LL;\nlong double c = 3.1415926535L;\n\nإذا لم تُضِف لاحقة، فإن C++ تفترض النوع int للأعداد الصحيحة وdouble للأعداد العشرية.\n\n\n\n\nقبل ظهور الكلمة المفتاحية const، كان المبرمجون يستخدمون #define لتعريف الثوابت:\n\n#define PI 3.14159\n#define GREETING \"Hello\"\n\nما زالت هذه الطريقة تعمل، ولكن const تُعَدّ أكثر أمانًا ومُفضّلة في C++ الحديثة.\n\n\n\n\n\n\n\n\n\n\n\n\nالطريقة\nالمثال\nهل يمكن التغيير؟\nمتى تُستخدم\n\n\n\n\nconst\nconst int x = 5;\nلا\nدائمًا مع القيم الثابتة\n\n\n#define\n#define Z 15\nلا\nأسلوب قديم، يُفضّل تجنّبه في C++ الحديثة\n\n\n\n\n\n\n\nاستخدم const مع القيم التي لا يجب أن تتغيّر.\nاستخدم اللواحق مثل LL أو f لاختيار النوع العددي المناسب.\nتجنّب #define للثوابت إلا عند قراءة كودٍ قديم.\n\nباستخدام الثوابت، يصبح الكود أكثر أمانًا، وأوضح، وأسهل في الصيانة.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الثوابت (Constants)"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#مثال-متغير-عادي-مقابل-ثابت",
    "href": "b0/cpp/constants.html#مثال-متغير-عادي-مقابل-ثابت",
    "title": "الثوابت (Constants)",
    "section": "",
    "text": "#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int age = 15;\n    age = 16; // we can change it\n\n    const double PI = 3.14159;\n    // PI = 3.14;  Error! cannot change a constant\n\n    cout &lt;&lt; \"PI is \" &lt;&lt; PI &lt;&lt; endl;\n    return 0;\n}\n\nالمخرجات:\n\nPI is 3.14159",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الثوابت (Constants)"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#لماذا-نستخدم-الثوابت",
    "href": "b0/cpp/constants.html#لماذا-نستخدم-الثوابت",
    "title": "الثوابت (Constants)",
    "section": "",
    "text": "لحماية القيم المهمة من التغيير غير المقصود.\nلجعل الكود أوضح وأسهل قراءة — المتغيّر PI أكثر وضوحًا من الرقم 3.14159.\nلتسهيل التحديث — إذا تغيّرت قيمة PI (وإن كان ذلك غير محتمل)، يمكن تعديلها في مكانٍ واحد فقط.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الثوابت (Constants)"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#تعريف-الثوابت",
    "href": "b0/cpp/constants.html#تعريف-الثوابت",
    "title": "الثوابت (Constants)",
    "section": "",
    "text": "يتم إنشاء ثابت في C++ بإضافة الكلمة المفتاحية const قبل نوع البيانات:\n\nconst int DAYS_IN_WEEK = 7;\nconst double GRAVITY = 9.81;\nconst char GRADE = 'A';\n\nيجب أن تُعطى الثوابت قيمة لحظة تعريفها ولا يمكن تركها دون تهيئة.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الثوابت (Constants)"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#الثوابت-الحرفية-literal-constants",
    "href": "b0/cpp/constants.html#الثوابت-الحرفية-literal-constants",
    "title": "الثوابت (Constants)",
    "section": "",
    "text": "الثوابت الحرفية هي القيم التي تظهر مباشرةً في الكود، مثل:\n\nint x = 5;         // 5 is an integer literal\ndouble pi = 3.14;  // 3.14 is a double literal\nchar letter = 'A'; // 'A' is a character literal\nstring word = \"Hi\"; // \"Hi\" is a string literal\n\nهذه مجرّد قيم خام (raw values) تُكتب مباشرةً داخل الكود.\n\n\nيمكنك أن تخبر C++ بنوع القيمة العددية باستخدام اللواحق (suffixes) التالية:\n\n\n\n\n\n\n\n\nالقيمة الحرفية\nالنوع\nالمعنى\n\n\n\n\n5\nint\nعدد صحيح افتراضي\n\n\n5U\nunsigned int\nعدد صحيح غير سالب\n\n\n5L\nlong\nعدد صحيح طويل\n\n\n5LL\nlong long\nعدد صحيح كبير جدًا\n\n\n3.14f\nfloat\nعدد عشري بدقة مفردة\n\n\n3.14\ndouble\nالنوع الافتراضي للأعداد العشرية\n\n\n3.14L\nlong double\nعدد عشري بدقة عالية\n\n\n\nمثال:\n\nfloat a = 3.14f;\nlong long b = 10000000000LL;\nlong double c = 3.1415926535L;\n\nإذا لم تُضِف لاحقة، فإن C++ تفترض النوع int للأعداد الصحيحة وdouble للأعداد العشرية.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الثوابت (Constants)"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#الثوابت-باستخدام-define-الطريقة-القديمة",
    "href": "b0/cpp/constants.html#الثوابت-باستخدام-define-الطريقة-القديمة",
    "title": "الثوابت (Constants)",
    "section": "",
    "text": "قبل ظهور الكلمة المفتاحية const، كان المبرمجون يستخدمون #define لتعريف الثوابت:\n\n#define PI 3.14159\n#define GREETING \"Hello\"\n\nما زالت هذه الطريقة تعمل، ولكن const تُعَدّ أكثر أمانًا ومُفضّلة في C++ الحديثة.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الثوابت (Constants)"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#جدول-المراجعة",
    "href": "b0/cpp/constants.html#جدول-المراجعة",
    "title": "الثوابت (Constants)",
    "section": "",
    "text": "الطريقة\nالمثال\nهل يمكن التغيير؟\nمتى تُستخدم\n\n\n\n\nconst\nconst int x = 5;\nلا\nدائمًا مع القيم الثابتة\n\n\n#define\n#define Z 15\nلا\nأسلوب قديم، يُفضّل تجنّبه في C++ الحديثة",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الثوابت (Constants)"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#خلاصة-سريعة",
    "href": "b0/cpp/constants.html#خلاصة-سريعة",
    "title": "الثوابت (Constants)",
    "section": "",
    "text": "استخدم const مع القيم التي لا يجب أن تتغيّر.\nاستخدم اللواحق مثل LL أو f لاختيار النوع العددي المناسب.\nتجنّب #define للثوابت إلا عند قراءة كودٍ قديم.\n\nباستخدام الثوابت، يصبح الكود أكثر أمانًا، وأوضح، وأسهل في الصيانة.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الثوابت (Constants)"
    ]
  },
  {
    "objectID": "b0/cp/contests-and-platforms.html",
    "href": "b0/cp/contests-and-platforms.html",
    "title": "المسابقات والمنصّات",
    "section": "",
    "text": "توجد العديد من المواقع الإلكترونية (تُعرف غالبًا باسم مقيم إلكتروني أو Online Judges) التي يمكنك من خلالها المشاركة في المسابقات أو حل المسائل لغرض التدريب فقط. تُعد منصة Codeforces المنصة الأشهر من بينها، إذ تستضيف مسابقات أسبوعية مناسبة لجميع المستويات، كما تحتوي على مكتبة ضخمة من المسائل يمكن استخدامها للممارسة.\nتوجد أيضًا منصّات أخرى مثل USACO التي تستضيف المسابقات كل شهرين تقريبًا، وتحتوي كذلك على مجموعة كبيرة من المسائل الموجهة للمنافسين ذوي الخبرة الأعلى. أما موقع CSES فهو لا يستضيف مسابقات، ولكنه يضم مكتبة ممتازة من المسائل مناسبة لتعلّم المواضيع المختلفة.\n\n\n\nفي هذا القسم سنناقش الخطوات التفصيلية لإنشاء حساب على منصة Codeforces وحل أوّل مسألة.\n\n\nبعد فتح موقع “codeforces.com”، اضغط على زر Register في الزاوية العلوية اليمنى من الصفحة.\n\n\n\nRegistration button\n\n\nاملأ البيانات المطلوبة واختر كلمة مرور قوية. اختر اسم مستخدم (handle) يُعبّر عن هويتك، علمًا أنك لن تتمكّن من تغييره إلا مرة واحدة في السنة. ملاحظة: يجب التسجيل باستخدام بريدك الإلكتروني الحقيقي، ولا يُنصح باستخدام بريد مؤقت، لأنك ستحتاج إلى التحقق من الحساب لاحقًا.\n\n\n\nبعد إتمام التسجيل، افتح بريدك الإلكتروني للتحقق من الحساب. بعد الانتهاء من هذه الخطوة، يمكنك تسجيل الدخول بنجاح.\n\n\n\nالآن يمكننا البدء بحل أول مسألة. في الشريط العلوي، يمكننا رؤية زر Problemset الذي يأخذنا إلى مكتبة المسائل الخاصة بـ Codeforces، حيث يمكننا عرض جميع المسائل التي ظهرت في المسابقات السابقة ومحاولة حلها.\n\n\n\nTopbar\n\n\nتمثّل آخر عمودين في جدول المسائل درجة الصعوبة وعدد الأشخاص الذين حلّوا المسألة.\n\n\n\nProblemset\n\n\nعند الضغط على أحد الرمزين في رأس الجدول، يمكنك ترتيب المسائل حسب تلك الخاصية. تُعبّر درجة الصعوبة عن رقم مضاعف لـ \\(100\\) ويتراوح ضمن المدى \\([800, 3500]\\).\nبعد ترتيب المسائل تصاعديًا حسب درجة الصعوبة، ستجد المسألة “Watermelon”.\n\n\n\nSorted Problemset\n\n\nمعلومة ممتعة: إنها أيضًا أكثر المسائل حلاً على المنصة.\n\n\nيصف هذا القسم المشكلة والمتطلبات. في الأعلى يظهر عنوان المسألة بالإضافة إلى حدود الزمن والذاكرة المسموح بها.\nتطلب المسألة كتابة برنامج يقرأ عددًا صحيحًا w من الإدخال، ويتحقق مما إذا كان يمكن تمثيل هذا العدد كمجموع لعددين صحيحين زوجيين موجبَين a وb، ثم يطبع “Yes” أو “No”.\n\n\n\nيوضّح هذا القسم كيفية إعطاء الإدخال بالضبط، وترتيبه، وأنواع البيانات المطلوبة. قد لا يُذكر صراحة أنك تحتاج إلى استخدام long long أو double، لكن يمكن استنتاج ذلك من مدى القيم الممكنة للمتغيّر.\nعلى سبيل المثال، إذا ورد في النص أنّ \\(-10^9 \\le x \\le 10^9\\) فإنّ نوع int يكفي، أما إذا ورد \\(-10^{18} \\le x \\le 10^{18}\\) فيجب استخدام long long.\n\n\n\nيوضح هذا القسم كيفية طباعة النتيجة. على سبيل المثال، ما إذا كانت الأحرف يجب أن تكون كبيرة أو صغيرة، أو ما إذا كان يجب الفصل بين المخرجات بمسافات أو أسطر جديدة، أو حتى عدد الأرقام العشرية المطلوب طباعتها عند التعامل مع الأعداد العشرية.\n\n\n\nإذا جرّبنا بعض الأعداد يدويًا، قد نلاحظ نمطًا معينًا؛ فعلى سبيل المثال، إذا كان w عددًا فرديًا، فمن المستحيل أن يكون مجموع a وb عددًا فرديًا لأنّ even + even = even.\nإذن، فكرتنا الأولى ستكون: إذا كان w فرديًا اطبع “No”، وإلا اطبع “Yes”.\nللأسف، هذه الفكرة غير صحيحة. المثال المضاد هو w = 2، إذ لا يمكن تمثيل العدد 2 كمجموع عددين زوجيين موجبين.\n\n\n\nبالنسبة لأي عدد أكبر من 2، يمكن ببساطة اختيار a = 2 و b = w - 2، وستعمل هذه الطريقة لأي عدد زوجي أكبر من 2. أما الأعداد الفردية فقد أثبتنا سابقًا استحالة تحقيق الشرط فيها.\n\n\n\nبعد الوصول إلى الحل الصحيح، يجب التعبير عنه بالكود. أولاً نقرأ الإدخال، ثم نطبّق المنطق، ثم نطبع الإخراج.\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int w;\n    cin &gt;&gt; w;\n\n    if (w == 2 || w % 2 == 1) cout &lt;&lt; \"No\";\n    else cout &lt;&lt; \"Yes\";\n}\n\n\n\n\nفي أعلى الصفحة، أسفل الشريط العلوي، سنجد الخيارات التالية:\n\n\n\nProblem Topbar\n\n\nعند الضغط على Submit، سيتم نقلك إلى الصفحة التالية:\n\n\n\nSubmission page\n\n\nأول ما يجب التأكد منه هو اختيار اللغة الصحيحة، وبما أننا نكتب بلغة C++ يجب تغيير خيار اللغة إلى نسخة صحيحة من C++. ملاحظة: الإعداد الافتراضي يكون عادةً على C مما يتسبب في حصول المبتدئين على compilation error في محاولتهم الأولى.\nبعد ذلك، انسخ الكود والصقه في خانة Source code، ثم اضغط على Submit.\nبعد الإرسال، سيتم تحويلك إلى صفحة Submissions التي ستُظهر نتيجة التقييم (verdict) الخاصة بإرسالك.\n\n\n\nSubmission status\n\n\nالنتائج المحتملة هي:\n\nAccepted – أي أن الحل اجتاز جميع الاختبارات بنجاح.\nWrong Answer – أي أن الحل طبع نتيجة خاطئة في أحد الاختبارات.\nTime Limit Exceeded – أي أن الحل استغرق وقتًا أطول من المسموح به.\nMemory Limit Exceeded – أي أن الحل استهلك ذاكرة أكبر من الحد المسموح.\nRuntime Error – أي أن هناك خطأ حدث أثناء تنفيذ البرنامج.\n\nعادةً لا يمكنك الاطلاع على الاختبار الذي فشل فيه برنامجك، فقد يكون كبيرًا جدًا أو محجوبًا من قِبل منظّمي المسابقة، وبالتالي يكون التحدي في اكتشاف الخطأ بنفسك.",
    "crumbs": [
      "المرحلة 1",
      "البرمجة التنافسية",
      "المسابقات والمنصّات"
    ]
  },
  {
    "objectID": "b0/cp/contests-and-platforms.html#المنصات-الإلكترونية",
    "href": "b0/cp/contests-and-platforms.html#المنصات-الإلكترونية",
    "title": "المسابقات والمنصّات",
    "section": "",
    "text": "توجد العديد من المواقع الإلكترونية (تُعرف غالبًا باسم مقيم إلكتروني أو Online Judges) التي يمكنك من خلالها المشاركة في المسابقات أو حل المسائل لغرض التدريب فقط. تُعد منصة Codeforces المنصة الأشهر من بينها، إذ تستضيف مسابقات أسبوعية مناسبة لجميع المستويات، كما تحتوي على مكتبة ضخمة من المسائل يمكن استخدامها للممارسة.\nتوجد أيضًا منصّات أخرى مثل USACO التي تستضيف المسابقات كل شهرين تقريبًا، وتحتوي كذلك على مجموعة كبيرة من المسائل الموجهة للمنافسين ذوي الخبرة الأعلى. أما موقع CSES فهو لا يستضيف مسابقات، ولكنه يضم مكتبة ممتازة من المسائل مناسبة لتعلّم المواضيع المختلفة.",
    "crumbs": [
      "المرحلة 1",
      "البرمجة التنافسية",
      "المسابقات والمنصّات"
    ]
  },
  {
    "objectID": "b0/cp/contests-and-platforms.html#البدء-باستخدام-codeforces",
    "href": "b0/cp/contests-and-platforms.html#البدء-باستخدام-codeforces",
    "title": "المسابقات والمنصّات",
    "section": "",
    "text": "في هذا القسم سنناقش الخطوات التفصيلية لإنشاء حساب على منصة Codeforces وحل أوّل مسألة.\n\n\nبعد فتح موقع “codeforces.com”، اضغط على زر Register في الزاوية العلوية اليمنى من الصفحة.\n\n\n\nRegistration button\n\n\nاملأ البيانات المطلوبة واختر كلمة مرور قوية. اختر اسم مستخدم (handle) يُعبّر عن هويتك، علمًا أنك لن تتمكّن من تغييره إلا مرة واحدة في السنة. ملاحظة: يجب التسجيل باستخدام بريدك الإلكتروني الحقيقي، ولا يُنصح باستخدام بريد مؤقت، لأنك ستحتاج إلى التحقق من الحساب لاحقًا.\n\n\n\nبعد إتمام التسجيل، افتح بريدك الإلكتروني للتحقق من الحساب. بعد الانتهاء من هذه الخطوة، يمكنك تسجيل الدخول بنجاح.\n\n\n\nالآن يمكننا البدء بحل أول مسألة. في الشريط العلوي، يمكننا رؤية زر Problemset الذي يأخذنا إلى مكتبة المسائل الخاصة بـ Codeforces، حيث يمكننا عرض جميع المسائل التي ظهرت في المسابقات السابقة ومحاولة حلها.\n\n\n\nTopbar\n\n\nتمثّل آخر عمودين في جدول المسائل درجة الصعوبة وعدد الأشخاص الذين حلّوا المسألة.\n\n\n\nProblemset\n\n\nعند الضغط على أحد الرمزين في رأس الجدول، يمكنك ترتيب المسائل حسب تلك الخاصية. تُعبّر درجة الصعوبة عن رقم مضاعف لـ \\(100\\) ويتراوح ضمن المدى \\([800, 3500]\\).\nبعد ترتيب المسائل تصاعديًا حسب درجة الصعوبة، ستجد المسألة “Watermelon”.\n\n\n\nSorted Problemset\n\n\nمعلومة ممتعة: إنها أيضًا أكثر المسائل حلاً على المنصة.\n\n\nيصف هذا القسم المشكلة والمتطلبات. في الأعلى يظهر عنوان المسألة بالإضافة إلى حدود الزمن والذاكرة المسموح بها.\nتطلب المسألة كتابة برنامج يقرأ عددًا صحيحًا w من الإدخال، ويتحقق مما إذا كان يمكن تمثيل هذا العدد كمجموع لعددين صحيحين زوجيين موجبَين a وb، ثم يطبع “Yes” أو “No”.\n\n\n\nيوضّح هذا القسم كيفية إعطاء الإدخال بالضبط، وترتيبه، وأنواع البيانات المطلوبة. قد لا يُذكر صراحة أنك تحتاج إلى استخدام long long أو double، لكن يمكن استنتاج ذلك من مدى القيم الممكنة للمتغيّر.\nعلى سبيل المثال، إذا ورد في النص أنّ \\(-10^9 \\le x \\le 10^9\\) فإنّ نوع int يكفي، أما إذا ورد \\(-10^{18} \\le x \\le 10^{18}\\) فيجب استخدام long long.\n\n\n\nيوضح هذا القسم كيفية طباعة النتيجة. على سبيل المثال، ما إذا كانت الأحرف يجب أن تكون كبيرة أو صغيرة، أو ما إذا كان يجب الفصل بين المخرجات بمسافات أو أسطر جديدة، أو حتى عدد الأرقام العشرية المطلوب طباعتها عند التعامل مع الأعداد العشرية.\n\n\n\nإذا جرّبنا بعض الأعداد يدويًا، قد نلاحظ نمطًا معينًا؛ فعلى سبيل المثال، إذا كان w عددًا فرديًا، فمن المستحيل أن يكون مجموع a وb عددًا فرديًا لأنّ even + even = even.\nإذن، فكرتنا الأولى ستكون: إذا كان w فرديًا اطبع “No”، وإلا اطبع “Yes”.\nللأسف، هذه الفكرة غير صحيحة. المثال المضاد هو w = 2، إذ لا يمكن تمثيل العدد 2 كمجموع عددين زوجيين موجبين.\n\n\n\nبالنسبة لأي عدد أكبر من 2، يمكن ببساطة اختيار a = 2 و b = w - 2، وستعمل هذه الطريقة لأي عدد زوجي أكبر من 2. أما الأعداد الفردية فقد أثبتنا سابقًا استحالة تحقيق الشرط فيها.\n\n\n\nبعد الوصول إلى الحل الصحيح، يجب التعبير عنه بالكود. أولاً نقرأ الإدخال، ثم نطبّق المنطق، ثم نطبع الإخراج.\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int w;\n    cin &gt;&gt; w;\n\n    if (w == 2 || w % 2 == 1) cout &lt;&lt; \"No\";\n    else cout &lt;&lt; \"Yes\";\n}\n\n\n\n\nفي أعلى الصفحة، أسفل الشريط العلوي، سنجد الخيارات التالية:\n\n\n\nProblem Topbar\n\n\nعند الضغط على Submit، سيتم نقلك إلى الصفحة التالية:\n\n\n\nSubmission page\n\n\nأول ما يجب التأكد منه هو اختيار اللغة الصحيحة، وبما أننا نكتب بلغة C++ يجب تغيير خيار اللغة إلى نسخة صحيحة من C++. ملاحظة: الإعداد الافتراضي يكون عادةً على C مما يتسبب في حصول المبتدئين على compilation error في محاولتهم الأولى.\nبعد ذلك، انسخ الكود والصقه في خانة Source code، ثم اضغط على Submit.\nبعد الإرسال، سيتم تحويلك إلى صفحة Submissions التي ستُظهر نتيجة التقييم (verdict) الخاصة بإرسالك.\n\n\n\nSubmission status\n\n\nالنتائج المحتملة هي:\n\nAccepted – أي أن الحل اجتاز جميع الاختبارات بنجاح.\nWrong Answer – أي أن الحل طبع نتيجة خاطئة في أحد الاختبارات.\nTime Limit Exceeded – أي أن الحل استغرق وقتًا أطول من المسموح به.\nMemory Limit Exceeded – أي أن الحل استهلك ذاكرة أكبر من الحد المسموح.\nRuntime Error – أي أن هناك خطأ حدث أثناء تنفيذ البرنامج.\n\nعادةً لا يمكنك الاطلاع على الاختبار الذي فشل فيه برنامجك، فقد يكون كبيرًا جدًا أو محجوبًا من قِبل منظّمي المسابقة، وبالتالي يكون التحدي في اكتشاف الخطأ بنفسك.",
    "crumbs": [
      "المرحلة 1",
      "البرمجة التنافسية",
      "المسابقات والمنصّات"
    ]
  },
  {
    "objectID": "b0/cp/problems-with-subproblems.html",
    "href": "b0/cp/problems-with-subproblems.html",
    "title": "المسائل ذات المسائل الفرعية",
    "section": "",
    "text": "في منصة Codeforces، تكون المسألة إما محلولة أو غير محلولة. أما في المنصّات الأخرى، فتُقسّم المسائل إلى مسائل فرعية (Subproblems) تختلف في القيود، ويُمنح المشارك نقاطًا بناءً على كل مسألة فرعية، بحيث يُظهر الحكم النهائي (verdict) الدرجة الإجمالية التي حصل عليها. هذا النمط شائع في المسابقات الكبرى مثل الأولمبيادات الوطنية والدولية.\n\n\n\n\nIso-celestial\n\nCodeforces\n\n\n\nيُعطى لك عدد من النقاط \\(N\\) على المستوى الإحداثي ثنائي الأبعاد، حيث \\(N \\leq 3000\\). المطلوب هو حساب عدد المجموعات الثلاثية من النقاط التي تُشكّل مثلثًا متساوي الساقين.\n\n\nتتكون المسألة من ثلاث مسائل فرعية تختلف فقط في القيود المفروضة على \\(N\\)، كما هو موضّح في الجدول التالي:\n\n\n\nالمسألة الفرعية\nالقيود\nالنقاط\n\n\n\n\n1\n\\(N = 3\\)\n33\n\n\n2\n\\(N \\leq 100\\)\n33\n\n\n3\n\n34\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nفي المسألة الفرعية الثالثة لا توجد قيود إضافية، أي أن القيود الوحيدة المطبّقة هي تلك الواردة في نص المسألة الأصلي. بالنسبة إلى \\(N\\)، يعني ذلك أنّ \\(1 \\leq N \\leq 3000\\).\n\n\n\n\n\n\n\n\nالحل للمسألة الفرعية 1\n\nفي هذه المسألة لدينا ثلاث نقاط فقط، وبالتالي إما أنّها تُشكّل مثلثًا متساوي الساقين أو لا. للتحقّق من ذلك، يمكننا فحص ما إذا كان هناك ضلعان متساويان في الطول:\n\n\n#include\"bits/stdc++.h\"\nusing namespace std;\n\nint n;\n\nlong long x[3001], y[3001];\n\nlong double dist(int i, int j) {\n    long double dy = y[i] - y[j];\n    long double dx = x[i] - x[j];\n\n    return sqrtl(dy * dy + dx * dx);\n}\n\nbool f(int a, int b, int c) {\n    long double ab = dist(a, b);\n    long double ac = dist(a, c);\n    long double bc = dist(b, c);\n\n    return (ab == ac || ab == bc || ac == bc);\n}\n\nint main() {\n    cin &gt;&gt; n;\n\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; x[i]&gt;&gt; y[i];\n    }\n\n    cout &lt;&lt; f(0, 1, 2);\n}\n\n\n\n\n\n\n\nالحل للمسألة الفرعية 2\n\nبما أن \\(N \\leq 100\\) في هذه المسألة الفرعية، يمكننا المرور على جميع المجموعات الثلاثية واختبار كل واحدة منها باستخدام الحل من المسألة السابقة. هذه الطريقة تُجري عددًا من الفحوصات قدره \\(O(N^3)\\)، وهي بطيئة جدًا بالنسبة للمسألة الكاملة التي يكون فيها \\(N \\leq 3000\\).\n\n\n#include\"bits/stdc++.h\"\nusing namespace std;\n\nint n;\n\nlong long x[3001], y[3001];\n\nlong double dist(int i, int j); // كما في السابق\nbool f(int a, int b, int c); // كما في السابق\n\nint main () {\n\n    cin &gt;&gt; n;\n\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; x[i]&gt;&gt; y[i];\n    }\n\n    int counter = 0;\n\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = i + 1 ; j &lt; n ; j++) {\n            for (int k = j + 1 ; k &lt; n ; k++) {\n                if (f(i, j, k)) counter++;\n            }\n        }\n    }\n\n    cout &lt;&lt; counter;\n}\n\n\n\n\n\n\n\nالحل للمسألة الفرعية 3 (الحل الكامل)\n\nفي هذه المرحلة، نحتاج إلى التفكير بطريقة مختلفة واستخدام الملاحظات للوصول إلى حل أسرع. لنفترض وجود نقطة واحدة \\(P\\)، ونحسب المسافة بينها وبين كل نقطة أخرى.\nيمكننا ملاحظة أنه إذا كانت هناك نقطتان \\(X\\) و\\(Y\\) على نفس المسافة من النقطة \\(P\\)، فإن المثلث \\((P, X, Y)\\) سيكون متساوي الساقين. وإذا وُجدت \\(K\\) نقاط جميعها على نفس المسافة من \\(P\\)، فإنّ أي زوج من هذه النقاط عند جمعه مع \\(P\\) يُشكّل مثلثًا متساوي الساقين.\nمن هذه الملاحظة، نحصل على خوارزمية تُجري \\(O(N^2)\\) عملية. لكل نقطة \\(P\\)، نمر على جميع النقاط الأخرى \\(Q\\) ونحصي عدد المرات التي تظهر فيها كل مسافة مميزة. بعد ذلك، نمر على جميع المسافات المميزة. ولنفرض أن عدد التكرارات لتلك المسافة هو \\(C\\)، فنضيف \\(\\displaystyle {C \\choose 2}\\) إلى الجواب.\n\n\n#include\"bits/stdc++.h\"\nusing namespace std;\n\nint n;\n\nlong long x[3001], y[3001];\n\nlong double dist (int i, int j); // كما في السابق\n\nint main () {\n\n    cin &gt;&gt; n;\n\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; x[i]&gt;&gt; y[i];\n    }\n\n    int counter = 0;\n\n    for (int i = 0 ; i &lt; n ; i++) {\n        long double all[n];\n\n        for (int j = 0 ; j &lt; n ; j++) {\n            all[j] = dist(i, j);\n        }\n\n        sort(all, all + n);\n\n        int cnt = 1;\n\n        for (int j = 1 ; j &lt; n ; j++) {\n            if (all[j] != all[j-1]) {\n                counter += cnt * (cnt - 1) / 2;\n                cnt = 0;\n            }\n            cnt++;\n        }\n\n        counter += cnt * (cnt - 1) / 2;\n    }\n\n    cout &lt;&lt; counter;\n}\n\n\nيتم تنفيذ عملية المرور على المسافات المختلفة بترتيبها بعد الفرز، ثم المرور عليها بترتيب تصاعدي، ولكن مع اتخاذ إجراء فقط عند تغيّر المسافة الحالية عن السابقة. ولتبسيط الكود، نستفيد من حقيقة أن المسافة بين النقطة ونفسها ستكون عند الفهرس \\(0\\) في المصفوفة المرتّبة، مما يسمح لنا ببدء الحلقة من الفهرس \\(1\\).",
    "crumbs": [
      "المرحلة 1",
      "البرمجة التنافسية",
      "المسائل ذات المسائل الفرعية"
    ]
  },
  {
    "objectID": "b0/cp/problems-with-subproblems.html#iso-celestial",
    "href": "b0/cp/problems-with-subproblems.html#iso-celestial",
    "title": "المسائل ذات المسائل الفرعية",
    "section": "",
    "text": "Iso-celestial\n\nCodeforces\n\n\n\nيُعطى لك عدد من النقاط \\(N\\) على المستوى الإحداثي ثنائي الأبعاد، حيث \\(N \\leq 3000\\). المطلوب هو حساب عدد المجموعات الثلاثية من النقاط التي تُشكّل مثلثًا متساوي الساقين.\n\n\nتتكون المسألة من ثلاث مسائل فرعية تختلف فقط في القيود المفروضة على \\(N\\)، كما هو موضّح في الجدول التالي:\n\n\n\nالمسألة الفرعية\nالقيود\nالنقاط\n\n\n\n\n1\n\\(N = 3\\)\n33\n\n\n2\n\\(N \\leq 100\\)\n33\n\n\n3\n\n34\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nفي المسألة الفرعية الثالثة لا توجد قيود إضافية، أي أن القيود الوحيدة المطبّقة هي تلك الواردة في نص المسألة الأصلي. بالنسبة إلى \\(N\\)، يعني ذلك أنّ \\(1 \\leq N \\leq 3000\\).",
    "crumbs": [
      "المرحلة 1",
      "البرمجة التنافسية",
      "المسائل ذات المسائل الفرعية"
    ]
  },
  {
    "objectID": "b0/cpp/input-output.html",
    "href": "b0/cpp/input-output.html",
    "title": "الإدخال/الإخراج",
    "section": "",
    "text": "عند تشغيل المستخدم لبرنامج ما، تظهر له شاشة تُسمّى الطرفية (terminal). من خلال هذه الشاشة يمكن للبرنامج عرض المعلومات أو استقبالها من المستخدم. نُطلق على عملية عرض المعلومات اسم الإخراج (output)، وعلى عملية استقبال المعلومات من المستخدم اسم الإدخال (input).\n\n\nيُنفَّذ الإدخال والإخراج في لغة ++C من خلال ما يُسمّى التيارات (streams). التيار هو نوع بيانات (datatype) يمكنه استقبال البيانات أو إرسالها (أو كليهما). تياران الرئيسيان المستخدمان في ++C هما cin للإدخال وcout للإخراج.\nللتعامل مع التيارات، نستخدم العاملين &lt;&lt; و &gt;&gt;، كما في الأمثلة التالية:\n\nstream &lt;&lt; variable; // تُغذي قيمة المتغير إلى التيار\nstream &gt;&gt; variable; // تأخذ البيانات من التيار وتخزنها في المتغير\n\nفي الحالة الأولى، لا يتغير المتغير، أما في الحالة الثانية فإن المتغير يحصل على قيمة جديدة.\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nيشير مصطلح “Stream” هنا إلى نوع (type)، بينما cin وcout هما متغيران من هذا النوع.\n\n\nولكي نتمكن من استخدام التيارات (cin و cout)، يجب أن نضيف السطر #include &lt;iostream&gt; في بداية البرنامج.\n\n\nافترض أنك كتبت البرنامج التالي:\n\nint x = 5;\n// add 1 if x is divisible by 3 and add 2 otherwise\nint y = x + (x % 3 == 0 ? 1 : 2);\n\nالمتغير y مخزَّن في الذاكرة، ولا توجد طريقة للمستخدم لمعرفة قيمته. إذا أردت أن تُظهر هذه القيمة للمستخدم، فعليك إخراجها إلى الطرفية.\n\ncout &lt;&lt; y;\n\nسيعرض هذا السطر قيمة المتغير y على الطرفية. وإذا أردنا طباعة نص عادي، نستخدم \"...\" كما يلي:\n\ncout &lt;&lt; \"The value of y is\";\ncout &lt;&lt; y;\n\nالنتيجة ستكون:\n\nThe value of y is7\n\nوهذا لا يبدو صحيحًا تمامًا، والسبب هو أن ++C لا تفهم ما يبدو مناسبًا أو غير مناسب بصريًا، فهي تنفذ التعليمات كما هي. وبما أننا لم نحدد وجود مسافة بعد كلمة “is”، لم يُضف البرنامج واحدة. لذا يجب أن نكتب:\n\ncout &lt;&lt; \"The value of y is \";\ncout &lt;&lt; y;\n\nويمكننا طباعة تعبيرات متعددة في السطر نفسه:\n\ncout &lt;&lt; \"The value of y is \" &lt;&lt; y;\n\nكما يمكننا طباعة رمز السطر الجديد '\\n' للانتقال إلى سطر جديد:\n\ncout &lt;&lt; \"Hello\" &lt;&lt; '\\n' &lt;&lt; \"World\";\n\nالناتج سيكون:\n\nHello\nWorld\n\n\n\n\nنعرف الآن كيفية كتابة برنامج يُعرّف البيانات ويتعامل معها ويطبعها. لكن المشكلة أن البرنامج يقوم بالعمليات نفسها في كل مرة يُشغَّل فيها. قد نرغب أحيانًا في كتابة برنامج يسمح للمستخدم بإدخال القيم في كل مرة. لهذا نستخدم cin.\n\nint x;\ncin &gt;&gt; x;\ncout &lt;&lt; \"You entered: \" &lt;&lt; x;\n\nفي هذا المثال، يتوقف تنفيذ البرنامج عند التعليمة cin &gt;&gt; x حتى يُدخل المستخدم قيمة في الطرفية ثم يضغط على Enter. بعد ذلك تُخزَّن القيمة في المتغير x.\nمثال على الإدخال:\n\n5\n\nالناتج المتوقع:\n\nYou entered: 5\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nلاحظ أن العاملين المستخدمين في cin وcout مختلفان: &gt;&gt; مع cin، و&lt;&lt; مع cout.\n\n\n\n\n\nعند استخدام cin، يقرأ التيار حتى يجد فراغًا أبيض أو نهاية الإدخال. أحيانًا قد نرغب في قراءة السطر كاملًا حتى لو احتوى على مسافات. لهذا نستخدم الدالة getline.\n\nstring s;\ngetline(cin, s);\n\ncout &lt;&lt; \"The line is: \" &lt;&lt; s;\n\nلاستخدام getline يجب تمرير معاملين: التيار الذي نريد القراءة منه، والمتغير الذي سنخزن فيه النتيجة.\n\n\n\n\n\n\nCautionحذر\n\n\n\nلا يُنصح باستخدام cin وgetline معًا في البرنامج نفسه.\n\n\n\n\n\n\n\n\nمسألة تدريبية\n\n\n\n\n\nاكتب برنامجًا يقرأ عددين صحيحين ويطبع أولًا الأصغر منهما ثم الأكبر، كل واحد في سطر منفصل.\n\n\n\n\n\nحل المسألة التدريبية\n\nخطوات حل المسألة كالتالي:\n\nتعريف متغيرين من نوع عدد صحيح لتخزين المدخلات.\nاستخدام cin لقراءة القيم.\nتعريف متغيرين إضافيين لتخزين الإجابات.\nاستخدام العامل الثلاثي (ternary operator) لتحديد الأصغر والأكبر.\nاستخدام cout لطباعة النتيجة.\n\n\nint a, b;\ncin &gt;&gt; a &gt;&gt; b; // يمكن قراءة عدة متغيرات في السطر نفسه\n\nint small = (a &lt; b ? a : b);\nint large = (a &gt; b ? a : b);\n\ncout &lt;&lt; small &lt;&lt; '\\n' &lt;&lt; large;\n\n\n\n\n\n\nعند استخدام cout، قد لا تُعرَض البيانات مباشرة على الشاشة، إذ تُخزَّن أحيانًا مؤقتًا (في ذاكرة مؤقتة buffer) لتسريع التنفيذ. بشكل افتراضي، كلما استُخدم cin، تُفرَّغ هذه الذاكرة، وهو ما قد يُبطئ الأداء أحيانًا.\nبالإضافة إلى ذلك، إذا كانت الذاكرة المؤقتة ممتلئة، فقد تُفرَّغ تلقائيًا أثناء التنفيذ. يمكننا فصل ارتباط cin بـ cout وجعل cout يفرّغ البيانات مرة واحدة فقط في نهاية التنفيذ بإضافة السطرين التاليين:\n\ncin.tie(0); // tie the cin stream to stream (0) i.e no stream\ncin.sync_with_stdio(0);\n\n\n\n\n\n\n\nImportantمهم\n\n\n\nفي المسابقات البرمجية، تُختبَر البرامج تلقائيًا، ولا يُدخل المستخدم القيم يدويًا، بل تُقرأ من ملف. وقد تكون هذه المدخلات كبيرة جدًا. لذا عندما تحتوي المسألة على كمية ضخمة من الإدخال (مئات الآلاف من الأرقام مثلًا)، من المهم وضع السطرين السابقين في بداية الكود لتجنّب بطء التنفيذ.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الإدخال/الإخراج"
    ]
  },
  {
    "objectID": "b0/cpp/input-output.html#التيارات-streams",
    "href": "b0/cpp/input-output.html#التيارات-streams",
    "title": "الإدخال/الإخراج",
    "section": "",
    "text": "يُنفَّذ الإدخال والإخراج في لغة ++C من خلال ما يُسمّى التيارات (streams). التيار هو نوع بيانات (datatype) يمكنه استقبال البيانات أو إرسالها (أو كليهما). تياران الرئيسيان المستخدمان في ++C هما cin للإدخال وcout للإخراج.\nللتعامل مع التيارات، نستخدم العاملين &lt;&lt; و &gt;&gt;، كما في الأمثلة التالية:\n\nstream &lt;&lt; variable; // تُغذي قيمة المتغير إلى التيار\nstream &gt;&gt; variable; // تأخذ البيانات من التيار وتخزنها في المتغير\n\nفي الحالة الأولى، لا يتغير المتغير، أما في الحالة الثانية فإن المتغير يحصل على قيمة جديدة.\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nيشير مصطلح “Stream” هنا إلى نوع (type)، بينما cin وcout هما متغيران من هذا النوع.\n\n\nولكي نتمكن من استخدام التيارات (cin و cout)، يجب أن نضيف السطر #include &lt;iostream&gt; في بداية البرنامج.\n\n\nافترض أنك كتبت البرنامج التالي:\n\nint x = 5;\n// add 1 if x is divisible by 3 and add 2 otherwise\nint y = x + (x % 3 == 0 ? 1 : 2);\n\nالمتغير y مخزَّن في الذاكرة، ولا توجد طريقة للمستخدم لمعرفة قيمته. إذا أردت أن تُظهر هذه القيمة للمستخدم، فعليك إخراجها إلى الطرفية.\n\ncout &lt;&lt; y;\n\nسيعرض هذا السطر قيمة المتغير y على الطرفية. وإذا أردنا طباعة نص عادي، نستخدم \"...\" كما يلي:\n\ncout &lt;&lt; \"The value of y is\";\ncout &lt;&lt; y;\n\nالنتيجة ستكون:\n\nThe value of y is7\n\nوهذا لا يبدو صحيحًا تمامًا، والسبب هو أن ++C لا تفهم ما يبدو مناسبًا أو غير مناسب بصريًا، فهي تنفذ التعليمات كما هي. وبما أننا لم نحدد وجود مسافة بعد كلمة “is”، لم يُضف البرنامج واحدة. لذا يجب أن نكتب:\n\ncout &lt;&lt; \"The value of y is \";\ncout &lt;&lt; y;\n\nويمكننا طباعة تعبيرات متعددة في السطر نفسه:\n\ncout &lt;&lt; \"The value of y is \" &lt;&lt; y;\n\nكما يمكننا طباعة رمز السطر الجديد '\\n' للانتقال إلى سطر جديد:\n\ncout &lt;&lt; \"Hello\" &lt;&lt; '\\n' &lt;&lt; \"World\";\n\nالناتج سيكون:\n\nHello\nWorld\n\n\n\n\nنعرف الآن كيفية كتابة برنامج يُعرّف البيانات ويتعامل معها ويطبعها. لكن المشكلة أن البرنامج يقوم بالعمليات نفسها في كل مرة يُشغَّل فيها. قد نرغب أحيانًا في كتابة برنامج يسمح للمستخدم بإدخال القيم في كل مرة. لهذا نستخدم cin.\n\nint x;\ncin &gt;&gt; x;\ncout &lt;&lt; \"You entered: \" &lt;&lt; x;\n\nفي هذا المثال، يتوقف تنفيذ البرنامج عند التعليمة cin &gt;&gt; x حتى يُدخل المستخدم قيمة في الطرفية ثم يضغط على Enter. بعد ذلك تُخزَّن القيمة في المتغير x.\nمثال على الإدخال:\n\n5\n\nالناتج المتوقع:\n\nYou entered: 5\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nلاحظ أن العاملين المستخدمين في cin وcout مختلفان: &gt;&gt; مع cin، و&lt;&lt; مع cout.\n\n\n\n\n\nعند استخدام cin، يقرأ التيار حتى يجد فراغًا أبيض أو نهاية الإدخال. أحيانًا قد نرغب في قراءة السطر كاملًا حتى لو احتوى على مسافات. لهذا نستخدم الدالة getline.\n\nstring s;\ngetline(cin, s);\n\ncout &lt;&lt; \"The line is: \" &lt;&lt; s;\n\nلاستخدام getline يجب تمرير معاملين: التيار الذي نريد القراءة منه، والمتغير الذي سنخزن فيه النتيجة.\n\n\n\n\n\n\nCautionحذر\n\n\n\nلا يُنصح باستخدام cin وgetline معًا في البرنامج نفسه.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الإدخال/الإخراج"
    ]
  },
  {
    "objectID": "b0/cpp/input-output.html#مسألة-تدريبية",
    "href": "b0/cpp/input-output.html#مسألة-تدريبية",
    "title": "الإدخال/الإخراج",
    "section": "",
    "text": "مسألة تدريبية\n\n\n\n\n\nاكتب برنامجًا يقرأ عددين صحيحين ويطبع أولًا الأصغر منهما ثم الأكبر، كل واحد في سطر منفصل.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الإدخال/الإخراج"
    ]
  },
  {
    "objectID": "b0/cpp/input-output.html#الإدخالالإخراج-السريع-fast-io",
    "href": "b0/cpp/input-output.html#الإدخالالإخراج-السريع-fast-io",
    "title": "الإدخال/الإخراج",
    "section": "",
    "text": "عند استخدام cout، قد لا تُعرَض البيانات مباشرة على الشاشة، إذ تُخزَّن أحيانًا مؤقتًا (في ذاكرة مؤقتة buffer) لتسريع التنفيذ. بشكل افتراضي، كلما استُخدم cin، تُفرَّغ هذه الذاكرة، وهو ما قد يُبطئ الأداء أحيانًا.\nبالإضافة إلى ذلك، إذا كانت الذاكرة المؤقتة ممتلئة، فقد تُفرَّغ تلقائيًا أثناء التنفيذ. يمكننا فصل ارتباط cin بـ cout وجعل cout يفرّغ البيانات مرة واحدة فقط في نهاية التنفيذ بإضافة السطرين التاليين:\n\ncin.tie(0); // tie the cin stream to stream (0) i.e no stream\ncin.sync_with_stdio(0);\n\n\n\n\n\n\n\nImportantمهم\n\n\n\nفي المسابقات البرمجية، تُختبَر البرامج تلقائيًا، ولا يُدخل المستخدم القيم يدويًا، بل تُقرأ من ملف. وقد تكون هذه المدخلات كبيرة جدًا. لذا عندما تحتوي المسألة على كمية ضخمة من الإدخال (مئات الآلاف من الأرقام مثلًا)، من المهم وضع السطرين السابقين في بداية الكود لتجنّب بطء التنفيذ.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الإدخال/الإخراج"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html",
    "href": "b0/cpp/variables-and-types.html",
    "title": "المتغيرات والأنواع",
    "section": "",
    "text": "لحل المشكلات البرمجية، نحتاج إلى تخزين البيانات والعمل عليها، مثل الأرقام أو الحروف أو الكلمات. نقوم بتخزين هذه البيانات داخل المتغيرات.\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int age = 15;\n    double height = 1.70;\n    char grade = 'A';\n    string name = \"Ali\";\n\n    cout &lt;&lt; name &lt;&lt; \" is \" &lt;&lt; age &lt;&lt; \" years old.\";\n    return 0;\n}\n\nالناتج:\n\nAli is 15 years old.\n\n\n\n\n\n\n\n\n\n\n\n\nالنوع\nالوصف\nأمثلة\n\n\n\n\nint\nللأعداد الصحيحة\n3, -7, 2025\n\n\ndouble\nللأعداد التي تحتوي على كسور عشرية\n3.14, -0.5\n\n\nchar\nلحرف أو رمز واحد\n'A', 'z', '?'\n\n\nstring\nللنصوص أو تسلسلات الحروف\n\"Hello\"\n\n\n\n\n\n\n\n\nعندما تصبح الأعداد كبيرة جدًا بحيث لا يمكن تخزينها في متغير من نوع int (على سبيل المثال عند التعامل مع المليارات أو التريليونات)، نستخدم النوع long long.\n\nlong long population = 8000000000; // 8 billion\n\nالسبب هو أن النوع int يمكنه عادة تخزين قيم تصل حتى حوالي 2 مليار (2,147,483,647). أما إذا احتجنا إلى أعداد أكبر، فنستخدم long long.\n\n\n\nكلا النوعين يخزنان الأعداد العشرية، ولكن يختلفان في الدقة (عدد الخانات العشرية التي يمكن تمثيلها بدقة).\n\n\n\n\n\n\n\n\nالنوع\nالدقة التقريبية\nالمثال\n\n\n\n\nfloat\nحوالي 6–7 خانات عشرية\n3.141593\n\n\ndouble\nحوالي 15–16 خانة عشرية\n3.141592653589793\n\n\n\n\n    float f = 1.61;\n    double d = 1.61;\n\n    cout &lt;&lt; setprecision(20); // عرض 20 خانة عشرية\n\n    cout &lt;&lt; f &lt;&lt; endl; // يطبع 1.6100000143051147461\n    cout &lt;&lt; d &lt;&lt; endl; // يطبع 1.6100000000000000977\n\n\n\n\n\n\n\nCaution\n\n\n\nكما تلاحظ في المثال، أغلب الأعداد الحقيقية لا يمكن تمثيلها بدقة تامة باستخدام float أو double. يجب أن تضع ذلك في اعتبارك دائمًا عند التعامل مع هذه الأنواع.\n\n\nفي الغالب، يستخدم المبرمجون النوع double لأنه أكثر دقة. ومع ذلك، فإن double يستهلك 8 بايت من الذاكرة، بينما float يستهلك 4 فقط. لذا استخدم float فقط إذا كنت بحاجة إلى تقليل استهلاك الذاكرة.\n\n\n\nالمتغير من نوع bool يمكن أن يأخذ قيمتين فقط: true أو false.\n\nbool isEven = true;\nbool isPrime = false;\n\nغالبًا ما نستخدمه في الشروط والمنطق داخل تعبيرات if:\n\nint x = 7;\nbool big = x &gt; 10;\ncout &lt;&lt; big; // يطبع 0 (false)\n\nالقيمة true تمثل داخليًا بالرقم 1، وfalse تمثل بالرقم 0.\n\n\n\n\n\nint x, y;\ncin &gt;&gt; x &gt;&gt; y;\ncout &lt;&lt; x + y;\n\nالإدخال:\n\n4 9\n\nالناتج:\n\n13\n\nهكذا تبدو معظم المسائل البسيطة في منصات مثل Codeforces أو AtCoder!\n\n\n\n\n\n\n\n\n\n\n\n\nالنوع\nالمعنى\nالمثال\nالذاكرة التقريبية\n\n\n\n\nint\nعدد صحيح\n5, -10\n4 بايت\n\n\nlong long\nعدد صحيح كبير\n1000000000000\n8 بايت\n\n\nfloat\nعدد عشري (دقة منخفضة)\n3.14\n4 بايت\n\n\ndouble\nعدد عشري (دقة عالية)\n3.1415926535\n8 بايت\n\n\nbool\nصحيح / خطأ\ntrue\n1 بايت\n\n\nchar\nحرف واحد\n'A'\n1 بايت\n\n\nstring\nنص\n\"Hello\"\nحسب الطول\n\n\n\n\n\n\nأحيانًا نستخدم أنواعًا مختلفة في العملية نفسها:\n\nint a = 3;\ndouble b = 2.5;\ncout &lt;&lt; a + b; // 5.5\n\nيقوم C++ بتحويل المتغير a مؤقتًا إلى double، لذلك يكون الناتج من نفس النوع.\n\n\n\nالكلمة المفتاحية auto تسمح للمترجم بتحديد نوع المتغير تلقائيًا:\n\nauto x = 5;        // int\nauto y = 3.14;     // double\nauto word = \"Hi\";  // const char*\n\nستستخدمها غالبًا في مسائل متقدمة لاحقًا.\n\n\n\nعند إنشاء متغيرات في C++، يجب اختيار اسم لكل متغير. هذا الاسم يوضح للبرنامج (وللقارئ البشري) وظيفة المتغير وما يمثله.\nالأسماء الجيدة تجعل الكود أكثر وضوحًا وسهولة في الفهم.\n\n\nيمكنك:\n\nاستخدام الحروف، الأرقام، والشرطة السفلية (_)\nالبدء بحرف أو بشرطة سفلية\nاستخدام الحروف الكبيرة والصغيرة (C++ تفرّق بينهما)\n\nلا يمكنك:\n\nالبدء برقم\nاستخدام المسافات\nاستخدام رموز خاصة مثل @, $, %, !, #, ?, إلخ\nاستخدام الكلمات المحجوزة في C++ (مثل int, for, return, while, …)\n\n\n\n\nأسماء صحيحة:\n\nint age;\ndouble total_price;\nbool isValid;\nstring firstName;\n\nأسماء غير صحيحة:\n\nint 2cats;       // يبدأ برقم\nint my variable; // يحتوي على مسافة\nint total$;      // يحتوي على رمز خاص\nint int;         // كلمة محجوزة\n\n\n\n\nلغة C++ تفرّق بين الأحرف الكبيرة والصغيرة:\n\nint score = 10;\nint Score = 20;\n\ncout &lt;&lt; score; // يطبع 10\n\nفي هذا المثال، score و Score هما متغيران مختلفان.\n\n\n\nتوجد عدة أنماط لتسمية المتغيرات، ومعظم مبرمجي C++ يستخدمون أحد الأنماط التالية:\n\n\n\n\n\n\n\n\nالنمط\nالمثال\nالاستخدام الشائع\n\n\n\n\nsnake_case\nplayer_health\nللمتغيرات والدوال في البرامج البسيطة\n\n\ncamelCase\nplayerHealth\nيُستخدم عادة في المشاريع الكبيرة أو المكتبات\n\n\nPascalCase\nPlayerHealth\nيُستخدم عادة في تعريف الـ classes أو الـ structs\n\n\n\nاختر نمطًا واحدًا والتزم به في جميع أجزاء الكود.\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int playerHealth = 100;\n    int playerScore = 2500;\n    bool isAlive = true;\n\n    cout &lt;&lt; \"Health: \" &lt;&lt; playerHealth &lt;&lt; endl;\n    cout &lt;&lt; \"Score: \" &lt;&lt; playerScore &lt;&lt; endl;\n    cout &lt;&lt; \"Alive: \" &lt;&lt; isAlive &lt;&lt; endl;\n\n    return 0;\n}\n\nالناتج:\n\nHealth: 100\nScore: 2500\nAlive: 1\n\n\n\n\n\n\n\n\n\n\n\n\nالقاعدة\nمسموح؟\nالمثال\n\n\n\n\nيبدأ بحرف أو شرطة سفلية\nنعم\n_count, sum\n\n\nيبدأ برقم\nلا\n9lives\n\n\nيحتوي على مسافة\nلا\ntotal price\n\n\nيحتوي على شرطة سفلية\nنعم\ntotal_price\n\n\nيحتوي على رمز ($، #، @، إلخ)\nلا\ntotal$\n\n\nكلمة محجوزة في C++\nلا\nint, while\n\n\n\nاختيار أسماء مناسبة للمتغيرات يجعل الكود أنظف وأسهل في القراءة والصيانة!",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المتغيرات والأنواع"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#مثال",
    "href": "b0/cpp/variables-and-types.html#مثال",
    "title": "المتغيرات والأنواع",
    "section": "",
    "text": "#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int age = 15;\n    double height = 1.70;\n    char grade = 'A';\n    string name = \"Ali\";\n\n    cout &lt;&lt; name &lt;&lt; \" is \" &lt;&lt; age &lt;&lt; \" years old.\";\n    return 0;\n}\n\nالناتج:\n\nAli is 15 years old.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المتغيرات والأنواع"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#الشرح",
    "href": "b0/cpp/variables-and-types.html#الشرح",
    "title": "المتغيرات والأنواع",
    "section": "",
    "text": "النوع\nالوصف\nأمثلة\n\n\n\n\nint\nللأعداد الصحيحة\n3, -7, 2025\n\n\ndouble\nللأعداد التي تحتوي على كسور عشرية\n3.14, -0.5\n\n\nchar\nلحرف أو رمز واحد\n'A', 'z', '?'\n\n\nstring\nللنصوص أو تسلسلات الحروف\n\"Hello\"",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المتغيرات والأنواع"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#أنواع-أعداد-إضافية",
    "href": "b0/cpp/variables-and-types.html#أنواع-أعداد-إضافية",
    "title": "المتغيرات والأنواع",
    "section": "",
    "text": "عندما تصبح الأعداد كبيرة جدًا بحيث لا يمكن تخزينها في متغير من نوع int (على سبيل المثال عند التعامل مع المليارات أو التريليونات)، نستخدم النوع long long.\n\nlong long population = 8000000000; // 8 billion\n\nالسبب هو أن النوع int يمكنه عادة تخزين قيم تصل حتى حوالي 2 مليار (2,147,483,647). أما إذا احتجنا إلى أعداد أكبر، فنستخدم long long.\n\n\n\nكلا النوعين يخزنان الأعداد العشرية، ولكن يختلفان في الدقة (عدد الخانات العشرية التي يمكن تمثيلها بدقة).\n\n\n\n\n\n\n\n\nالنوع\nالدقة التقريبية\nالمثال\n\n\n\n\nfloat\nحوالي 6–7 خانات عشرية\n3.141593\n\n\ndouble\nحوالي 15–16 خانة عشرية\n3.141592653589793\n\n\n\n\n    float f = 1.61;\n    double d = 1.61;\n\n    cout &lt;&lt; setprecision(20); // عرض 20 خانة عشرية\n\n    cout &lt;&lt; f &lt;&lt; endl; // يطبع 1.6100000143051147461\n    cout &lt;&lt; d &lt;&lt; endl; // يطبع 1.6100000000000000977\n\n\n\n\n\n\n\nCaution\n\n\n\nكما تلاحظ في المثال، أغلب الأعداد الحقيقية لا يمكن تمثيلها بدقة تامة باستخدام float أو double. يجب أن تضع ذلك في اعتبارك دائمًا عند التعامل مع هذه الأنواع.\n\n\nفي الغالب، يستخدم المبرمجون النوع double لأنه أكثر دقة. ومع ذلك، فإن double يستهلك 8 بايت من الذاكرة، بينما float يستهلك 4 فقط. لذا استخدم float فقط إذا كنت بحاجة إلى تقليل استهلاك الذاكرة.\n\n\n\nالمتغير من نوع bool يمكن أن يأخذ قيمتين فقط: true أو false.\n\nbool isEven = true;\nbool isPrime = false;\n\nغالبًا ما نستخدمه في الشروط والمنطق داخل تعبيرات if:\n\nint x = 7;\nbool big = x &gt; 10;\ncout &lt;&lt; big; // يطبع 0 (false)\n\nالقيمة true تمثل داخليًا بالرقم 1، وfalse تمثل بالرقم 0.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المتغيرات والأنواع"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#مثال-الإدخال-والإخراج-مع-المتغيرات",
    "href": "b0/cpp/variables-and-types.html#مثال-الإدخال-والإخراج-مع-المتغيرات",
    "title": "المتغيرات والأنواع",
    "section": "",
    "text": "int x, y;\ncin &gt;&gt; x &gt;&gt; y;\ncout &lt;&lt; x + y;\n\nالإدخال:\n\n4 9\n\nالناتج:\n\n13\n\nهكذا تبدو معظم المسائل البسيطة في منصات مثل Codeforces أو AtCoder!",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المتغيرات والأنواع"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#جدول-ملخص-لأنواع-البيانات",
    "href": "b0/cpp/variables-and-types.html#جدول-ملخص-لأنواع-البيانات",
    "title": "المتغيرات والأنواع",
    "section": "",
    "text": "النوع\nالمعنى\nالمثال\nالذاكرة التقريبية\n\n\n\n\nint\nعدد صحيح\n5, -10\n4 بايت\n\n\nlong long\nعدد صحيح كبير\n1000000000000\n8 بايت\n\n\nfloat\nعدد عشري (دقة منخفضة)\n3.14\n4 بايت\n\n\ndouble\nعدد عشري (دقة عالية)\n3.1415926535\n8 بايت\n\n\nbool\nصحيح / خطأ\ntrue\n1 بايت\n\n\nchar\nحرف واحد\n'A'\n1 بايت\n\n\nstring\nنص\n\"Hello\"\nحسب الطول",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المتغيرات والأنواع"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#تحويل-الأنواع",
    "href": "b0/cpp/variables-and-types.html#تحويل-الأنواع",
    "title": "المتغيرات والأنواع",
    "section": "",
    "text": "أحيانًا نستخدم أنواعًا مختلفة في العملية نفسها:\n\nint a = 3;\ndouble b = 2.5;\ncout &lt;&lt; a + b; // 5.5\n\nيقوم C++ بتحويل المتغير a مؤقتًا إلى double، لذلك يكون الناتج من نفس النوع.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المتغيرات والأنواع"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#اختياري-auto",
    "href": "b0/cpp/variables-and-types.html#اختياري-auto",
    "title": "المتغيرات والأنواع",
    "section": "",
    "text": "الكلمة المفتاحية auto تسمح للمترجم بتحديد نوع المتغير تلقائيًا:\n\nauto x = 5;        // int\nauto y = 3.14;     // double\nauto word = \"Hi\";  // const char*\n\nستستخدمها غالبًا في مسائل متقدمة لاحقًا.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المتغيرات والأنواع"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#تسمية-المتغيرات",
    "href": "b0/cpp/variables-and-types.html#تسمية-المتغيرات",
    "title": "المتغيرات والأنواع",
    "section": "",
    "text": "عند إنشاء متغيرات في C++، يجب اختيار اسم لكل متغير. هذا الاسم يوضح للبرنامج (وللقارئ البشري) وظيفة المتغير وما يمثله.\nالأسماء الجيدة تجعل الكود أكثر وضوحًا وسهولة في الفهم.\n\n\nيمكنك:\n\nاستخدام الحروف، الأرقام، والشرطة السفلية (_)\nالبدء بحرف أو بشرطة سفلية\nاستخدام الحروف الكبيرة والصغيرة (C++ تفرّق بينهما)\n\nلا يمكنك:\n\nالبدء برقم\nاستخدام المسافات\nاستخدام رموز خاصة مثل @, $, %, !, #, ?, إلخ\nاستخدام الكلمات المحجوزة في C++ (مثل int, for, return, while, …)\n\n\n\n\nأسماء صحيحة:\n\nint age;\ndouble total_price;\nbool isValid;\nstring firstName;\n\nأسماء غير صحيحة:\n\nint 2cats;       // يبدأ برقم\nint my variable; // يحتوي على مسافة\nint total$;      // يحتوي على رمز خاص\nint int;         // كلمة محجوزة\n\n\n\n\nلغة C++ تفرّق بين الأحرف الكبيرة والصغيرة:\n\nint score = 10;\nint Score = 20;\n\ncout &lt;&lt; score; // يطبع 10\n\nفي هذا المثال، score و Score هما متغيران مختلفان.\n\n\n\nتوجد عدة أنماط لتسمية المتغيرات، ومعظم مبرمجي C++ يستخدمون أحد الأنماط التالية:\n\n\n\n\n\n\n\n\nالنمط\nالمثال\nالاستخدام الشائع\n\n\n\n\nsnake_case\nplayer_health\nللمتغيرات والدوال في البرامج البسيطة\n\n\ncamelCase\nplayerHealth\nيُستخدم عادة في المشاريع الكبيرة أو المكتبات\n\n\nPascalCase\nPlayerHealth\nيُستخدم عادة في تعريف الـ classes أو الـ structs\n\n\n\nاختر نمطًا واحدًا والتزم به في جميع أجزاء الكود.\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int playerHealth = 100;\n    int playerScore = 2500;\n    bool isAlive = true;\n\n    cout &lt;&lt; \"Health: \" &lt;&lt; playerHealth &lt;&lt; endl;\n    cout &lt;&lt; \"Score: \" &lt;&lt; playerScore &lt;&lt; endl;\n    cout &lt;&lt; \"Alive: \" &lt;&lt; isAlive &lt;&lt; endl;\n\n    return 0;\n}\n\nالناتج:\n\nHealth: 100\nScore: 2500\nAlive: 1\n\n\n\n\n\n\n\n\n\n\n\n\nالقاعدة\nمسموح؟\nالمثال\n\n\n\n\nيبدأ بحرف أو شرطة سفلية\nنعم\n_count, sum\n\n\nيبدأ برقم\nلا\n9lives\n\n\nيحتوي على مسافة\nلا\ntotal price\n\n\nيحتوي على شرطة سفلية\nنعم\ntotal_price\n\n\nيحتوي على رمز ($، #، @، إلخ)\nلا\ntotal$\n\n\nكلمة محجوزة في C++\nلا\nint, while\n\n\n\nاختيار أسماء مناسبة للمتغيرات يجعل الكود أنظف وأسهل في القراءة والصيانة!",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "المتغيرات والأنواع"
    ]
  },
  {
    "objectID": "b0/cpp/for.html",
    "href": "b0/cpp/for.html",
    "title": "حلقة for",
    "section": "",
    "text": "تُستخدم حلقة for غالبًا في الحالات التي يكون فيها عدد التكرارات معلومًا مسبقًا، وهي تسمح بكتابة التهيئة، والشرط، والتحديث في سطر واحد.\n\n\n\nfor (initialization; condition; update)\n    statement;\n\n\n\n\n\n// countdown using a for loop\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    for (int n = 10; n &gt; 0; n--) {\n        cout &lt;&lt; n &lt;&lt; \", \";\n    }\n    cout &lt;&lt; \"liftoff!\\n\";\n}\n\nالناتج:\n\n10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff!\n\n\n\n\n\nالتهيئة (Initialization): تُنفَّذ مرة واحدة قبل بداية الحلقة، مثل: int n = 10;.\nالشرط (Condition): يُفحَص قبل كل تكرار، مثل: n &gt; 0.\nالتحديث (Update): يُنفَّذ بعد كل تكرار، مثل: n--.\nالامر (Statement): تُنفَّذ إذا كان الشرط صحيحًا، مثل: cout &lt;&lt; n &lt;&lt; \", \";.\n\n\n\n\nالأجزاء الثلاثة في رأس حلقة for اختيارية، لكن الفواصل المنقوطة (;) إلزامية:\n\nfor (; n &lt; 10; )    // بدون تهيئة أو تحديث\nfor (; n &lt; 10; ++n) // مع تحديث فقط\n\n\n\n\n\n\n\nCaution\n\n\n\nإهمال الشرط تمامًا يجعل الحلقة لا نهائية.\n\n\n\n\n\nتُستخدم للتكرار تلقائيًا على كل عنصر في مجال (مثل المصفوفات أو السلاسل النصية):\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string str {\"Hello!\"};\n    for (char c : str)\n        cout &lt;&lt; \"[\" &lt;&lt; c &lt;&lt; \"]\";\n    cout &lt;&lt; '\\n';\n}\n\nالناتج:\n\n[H][e][l][l][o][!]\n\nيمكن استخدام الكلمة auto لجعل المترجم يحدّد نوع العنصر تلقائيًا، وتكون النتيجة نفسها:\n\nfor (auto c : str)\n    cout &lt;&lt; \"[\" &lt;&lt; c &lt;&lt; \"]\";",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "حلقة `for`"
    ]
  },
  {
    "objectID": "b0/cpp/for.html#الصياغة-syntax",
    "href": "b0/cpp/for.html#الصياغة-syntax",
    "title": "حلقة for",
    "section": "",
    "text": "for (initialization; condition; update)\n    statement;",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "حلقة `for`"
    ]
  },
  {
    "objectID": "b0/cpp/for.html#مثال-العد-التنازلي",
    "href": "b0/cpp/for.html#مثال-العد-التنازلي",
    "title": "حلقة for",
    "section": "",
    "text": "// countdown using a for loop\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    for (int n = 10; n &gt; 0; n--) {\n        cout &lt;&lt; n &lt;&lt; \", \";\n    }\n    cout &lt;&lt; \"liftoff!\\n\";\n}\n\nالناتج:\n\n10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff!",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "حلقة `for`"
    ]
  },
  {
    "objectID": "b0/cpp/for.html#كيف-تعمل-حلقة-for",
    "href": "b0/cpp/for.html#كيف-تعمل-حلقة-for",
    "title": "حلقة for",
    "section": "",
    "text": "التهيئة (Initialization): تُنفَّذ مرة واحدة قبل بداية الحلقة، مثل: int n = 10;.\nالشرط (Condition): يُفحَص قبل كل تكرار، مثل: n &gt; 0.\nالتحديث (Update): يُنفَّذ بعد كل تكرار، مثل: n--.\nالامر (Statement): تُنفَّذ إذا كان الشرط صحيحًا، مثل: cout &lt;&lt; n &lt;&lt; \", \";.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "حلقة `for`"
    ]
  },
  {
    "objectID": "b0/cpp/for.html#أمثلة",
    "href": "b0/cpp/for.html#أمثلة",
    "title": "حلقة for",
    "section": "",
    "text": "الأجزاء الثلاثة في رأس حلقة for اختيارية، لكن الفواصل المنقوطة (;) إلزامية:\n\nfor (; n &lt; 10; )    // بدون تهيئة أو تحديث\nfor (; n &lt; 10; ++n) // مع تحديث فقط\n\n\n\n\n\n\n\nCaution\n\n\n\nإهمال الشرط تمامًا يجعل الحلقة لا نهائية.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "حلقة `for`"
    ]
  },
  {
    "objectID": "b0/cpp/for.html#حلقة-for-المبنية-على-المجال-range-based-for",
    "href": "b0/cpp/for.html#حلقة-for-المبنية-على-المجال-range-based-for",
    "title": "حلقة for",
    "section": "",
    "text": "تُستخدم للتكرار تلقائيًا على كل عنصر في مجال (مثل المصفوفات أو السلاسل النصية):\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string str {\"Hello!\"};\n    for (char c : str)\n        cout &lt;&lt; \"[\" &lt;&lt; c &lt;&lt; \"]\";\n    cout &lt;&lt; '\\n';\n}\n\nالناتج:\n\n[H][e][l][l][o][!]\n\nيمكن استخدام الكلمة auto لجعل المترجم يحدّد نوع العنصر تلقائيًا، وتكون النتيجة نفسها:\n\nfor (auto c : str)\n    cout &lt;&lt; \"[\" &lt;&lt; c &lt;&lt; \"]\";",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "حلقة `for`"
    ]
  },
  {
    "objectID": "b0/cpp/if.html",
    "href": "b0/cpp/if.html",
    "title": "عبارة if",
    "section": "",
    "text": "تُستخدم عبارة if لاتخاذ القرارات داخل البرنامج — فهي تجعل البرنامج ينفّذ جزءًا معيّنًا فقط إذا كان الشرط المحدّد صحيحًا.\n\n\n\nif (condition)\n    statement;\n\n\ncondition هي عبارة (expression) يتم تقييمها إلى إمّا true أو false.\nإذا كان الشرط صحيحًا (true)، يتم تنفيذ الامر (statement).\nإذا كان الشرط غير صحيح (false)، يتم تجاهل الامر، ويستمر البرنامج في التنفيذ بعد عبارة if.\n\n\n\n\n\nif (x == 100)\n    cout &lt;&lt; \"x is 100\";\n\nإذا كانت قيمة x تساوي بالضبط 100، سيتم طباعة الرسالة \"x is 100\". وإلا، لن يحدث شيء وسيُكمل البرنامج التنفيذ بشكل طبيعي.\n\n\n\nإذا أردت تنفيذ أكثر من امر واحدة عندما يكون الشرط صحيحًا، قم بتجميعها بين الأقواس المعقوفة {} لتكوين كتلة (block):\n\nif (x == 100)\n{\n    cout &lt;&lt; \"x is \";\n    cout &lt;&lt; x;\n}\n\nتُعامل هذه الكتلة كأنها امر واحدة في سياق التحكم في التدفق. المسافات البادئة (indentation) وتنسيق الأسطر لا يؤثّران على طريقة تنفيذ البرنامج، لذلك الكود التالي مكافئ:\n\nif (x == 100) { cout &lt;&lt; \"x is \"; cout &lt;&lt; x; }\n\n\n\n\nيمكنك إضافة جزء else لتحديد ما يحدث عندما يكون الشرط غير صحيح:\n\nif (x == 100)\n    cout &lt;&lt; \"x is 100\";\nelse\n    cout &lt;&lt; \"x is not 100\";\n\n\nإذا كان الشرط صحيحًا، تُنفّذ الامر الأولى.\nإذا كان غير صحيح، تُنفّذ الامر بعد else بدلًا منها.\n\n\n\n\nيمكنك ربط عدّة شروط باستخدام else if للتعامل مع عدّة حالات:\n\nif (x &gt; 0)\n    cout &lt;&lt; \"x is positive\";\nelse if (x &lt; 0)\n    cout &lt;&lt; \"x is negative\";\nelse\n    cout &lt;&lt; \"x is 0\";\n\nهذا التركيب يسمح للبرنامج بالاختيار بين عدّة بدائل:\n\nإذا كانت x أكبر من صفر → يطبع \"x is positive\".\nإذا كانت x أقل من صفر → يطبع \"x is negative\".\nخلاف ذلك → يطبع \"x is 0\".",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "عبارة `if`"
    ]
  },
  {
    "objectID": "b0/cpp/if.html#البنية-الأساسية",
    "href": "b0/cpp/if.html#البنية-الأساسية",
    "title": "عبارة if",
    "section": "",
    "text": "if (condition)\n    statement;\n\n\ncondition هي عبارة (expression) يتم تقييمها إلى إمّا true أو false.\nإذا كان الشرط صحيحًا (true)، يتم تنفيذ الامر (statement).\nإذا كان الشرط غير صحيح (false)، يتم تجاهل الامر، ويستمر البرنامج في التنفيذ بعد عبارة if.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "عبارة `if`"
    ]
  },
  {
    "objectID": "b0/cpp/if.html#مثال",
    "href": "b0/cpp/if.html#مثال",
    "title": "عبارة if",
    "section": "",
    "text": "if (x == 100)\n    cout &lt;&lt; \"x is 100\";\n\nإذا كانت قيمة x تساوي بالضبط 100، سيتم طباعة الرسالة \"x is 100\". وإلا، لن يحدث شيء وسيُكمل البرنامج التنفيذ بشكل طبيعي.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "عبارة `if`"
    ]
  },
  {
    "objectID": "b0/cpp/if.html#عدة-تعليمات-كتلة-مركبة",
    "href": "b0/cpp/if.html#عدة-تعليمات-كتلة-مركبة",
    "title": "عبارة if",
    "section": "",
    "text": "إذا أردت تنفيذ أكثر من امر واحدة عندما يكون الشرط صحيحًا، قم بتجميعها بين الأقواس المعقوفة {} لتكوين كتلة (block):\n\nif (x == 100)\n{\n    cout &lt;&lt; \"x is \";\n    cout &lt;&lt; x;\n}\n\nتُعامل هذه الكتلة كأنها امر واحدة في سياق التحكم في التدفق. المسافات البادئة (indentation) وتنسيق الأسطر لا يؤثّران على طريقة تنفيذ البرنامج، لذلك الكود التالي مكافئ:\n\nif (x == 100) { cout &lt;&lt; \"x is \"; cout &lt;&lt; x; }",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "عبارة `if`"
    ]
  },
  {
    "objectID": "b0/cpp/if.html#استخدام-else",
    "href": "b0/cpp/if.html#استخدام-else",
    "title": "عبارة if",
    "section": "",
    "text": "يمكنك إضافة جزء else لتحديد ما يحدث عندما يكون الشرط غير صحيح:\n\nif (x == 100)\n    cout &lt;&lt; \"x is 100\";\nelse\n    cout &lt;&lt; \"x is not 100\";\n\n\nإذا كان الشرط صحيحًا، تُنفّذ الامر الأولى.\nإذا كان غير صحيح، تُنفّذ الامر بعد else بدلًا منها.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "عبارة `if`"
    ]
  },
  {
    "objectID": "b0/cpp/if.html#سلاسل-else-if",
    "href": "b0/cpp/if.html#سلاسل-else-if",
    "title": "عبارة if",
    "section": "",
    "text": "يمكنك ربط عدّة شروط باستخدام else if للتعامل مع عدّة حالات:\n\nif (x &gt; 0)\n    cout &lt;&lt; \"x is positive\";\nelse if (x &lt; 0)\n    cout &lt;&lt; \"x is negative\";\nelse\n    cout &lt;&lt; \"x is 0\";\n\nهذا التركيب يسمح للبرنامج بالاختيار بين عدّة بدائل:\n\nإذا كانت x أكبر من صفر → يطبع \"x is positive\".\nإذا كانت x أقل من صفر → يطبع \"x is negative\".\nخلاف ذلك → يطبع \"x is 0\".",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "عبارة `if`"
    ]
  },
  {
    "objectID": "b0/cpp/structure-of-a-program.html",
    "href": "b0/cpp/structure-of-a-program.html",
    "title": "بنية البرنامج",
    "section": "",
    "text": "لننظر ممَّ يتكوَّن أي برنامج مكتوب بلغة C++.\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Your first program!\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\";\n    return 0;\n}\n\n\n\n\nأوامر المترجم القبلي (Preprocessor commands)\n\nتبدأ بالرمز # مثل: #include &lt;iostream&gt;.\nتُخبر المترجم بإضافة ملفات أو أدوات إضافية قبل ترجمة البرنامج.\n\nمساحات الأسماء (Namespaces)\n\nغالبًا نكتب: using namespace std;.\nلست بحاجة الآن لفهم مساحات الأسماء بعمق؛ فقط أضِف هذه العبارة في برامجك المبدئية لتتمكّن من استخدام cout وcin بسهولة.\n\nالدالة main()\n\nهي النقطة التي يبدأ عندها تنفيذ البرنامج.\nينفّذ الحاسوب الأوامر داخل الأقواس { ... } من الأعلى إلى الأسفل.\n\nالأقواس المعقوفة {}\n\nتُستخدم لتجميع مجموعة من التعليمات في كتلة واحدة.\nستراها في الدوال، والحلقات، وعبارات الشرط.\n\nالفواصل المنقوطة ;\n\nكل أمر (instruction) ينتهي بفاصلة منقوطة.\nنسيانها يؤدّي إلى ظهور خطأ عند الترجمة.\n\nأمر الإرجاع return\n\nالسطر return 0; ينهي تنفيذ البرنامج، ويُشير إلى أنّه انتهى بنجاح.\n\n\n\n\n\n\n#include &lt;iostream&gt; : يُخبر المترجم بأننا نريد استخدام أوامر الإدخال/الإخراج.\nusing namespace std; : يتيح لنا كتابة cout بدل std::cout، أي بشكل أقصر.\nint main() : الدالة الرئيسية، يبدأ تنفيذ البرنامج منها.\n{ ... } : كل ما بداخل الأقواس المعقوفة هو جسم الدالة main، أي الجزء الذي يُنفَّذ.\ncout &lt;&lt; \"Hello, World!\"; : تطبع النص على الشاشة.\nreturn 0; : تُنهي البرنامج وتُعلم نظام التشغيل بأن التنفيذ تم بنجاح.\n\nعند تشغيل هذا البرنامج سيظهر:\n\nHello, World!\n\nوهذا هو أوّل برنامج كامل لك في C++.\n\n\n\nالتعليقات هي ملاحظات يكتبها المبرمج، ويتجاهلها الحاسوب تمامًا. الغرض منها توضيح وظيفة أجزاء من البرنامج.\n\n// This is a single-line comment\n\n/*\nThis is a\nmulti-line comment\n*/\n\nستستخدم التعليقات كثيرًا لشرح ما يفعله الكود وتذكير نفسك أو غيرك بوظيفته.\n\n\n\nيُفضَّل دائمًا الإزاحة (Indent) داخل الأقواس {} باستخدام Tab أو 4 مسافات؛ لأن ذلك يجعل الكود أوضح وأسهل قراءة:\n\nint main() {\n    cout &lt;&lt; \"Good style matters!\";\n}\n\nأسلوب غير جيّد:\n\nint main(){\ncout&lt;&lt;\"Hard to read\";\n}\n\nتنظيم البرنامج لا يغيّر من طريقة تنفيذ البرنامج، لكنه مهم جدًا لقراءتها وصيانتها.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "بنية البرنامج"
    ]
  },
  {
    "objectID": "b0/cpp/structure-of-a-program.html#المكونات-الأساسية",
    "href": "b0/cpp/structure-of-a-program.html#المكونات-الأساسية",
    "title": "بنية البرنامج",
    "section": "",
    "text": "أوامر المترجم القبلي (Preprocessor commands)\n\nتبدأ بالرمز # مثل: #include &lt;iostream&gt;.\nتُخبر المترجم بإضافة ملفات أو أدوات إضافية قبل ترجمة البرنامج.\n\nمساحات الأسماء (Namespaces)\n\nغالبًا نكتب: using namespace std;.\nلست بحاجة الآن لفهم مساحات الأسماء بعمق؛ فقط أضِف هذه العبارة في برامجك المبدئية لتتمكّن من استخدام cout وcin بسهولة.\n\nالدالة main()\n\nهي النقطة التي يبدأ عندها تنفيذ البرنامج.\nينفّذ الحاسوب الأوامر داخل الأقواس { ... } من الأعلى إلى الأسفل.\n\nالأقواس المعقوفة {}\n\nتُستخدم لتجميع مجموعة من التعليمات في كتلة واحدة.\nستراها في الدوال، والحلقات، وعبارات الشرط.\n\nالفواصل المنقوطة ;\n\nكل أمر (instruction) ينتهي بفاصلة منقوطة.\nنسيانها يؤدّي إلى ظهور خطأ عند الترجمة.\n\nأمر الإرجاع return\n\nالسطر return 0; ينهي تنفيذ البرنامج، ويُشير إلى أنّه انتهى بنجاح.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "بنية البرنامج"
    ]
  },
  {
    "objectID": "b0/cpp/structure-of-a-program.html#ماذا-يحدث-في-هذا-البرنامج",
    "href": "b0/cpp/structure-of-a-program.html#ماذا-يحدث-في-هذا-البرنامج",
    "title": "بنية البرنامج",
    "section": "",
    "text": "#include &lt;iostream&gt; : يُخبر المترجم بأننا نريد استخدام أوامر الإدخال/الإخراج.\nusing namespace std; : يتيح لنا كتابة cout بدل std::cout، أي بشكل أقصر.\nint main() : الدالة الرئيسية، يبدأ تنفيذ البرنامج منها.\n{ ... } : كل ما بداخل الأقواس المعقوفة هو جسم الدالة main، أي الجزء الذي يُنفَّذ.\ncout &lt;&lt; \"Hello, World!\"; : تطبع النص على الشاشة.\nreturn 0; : تُنهي البرنامج وتُعلم نظام التشغيل بأن التنفيذ تم بنجاح.\n\nعند تشغيل هذا البرنامج سيظهر:\n\nHello, World!\n\nوهذا هو أوّل برنامج كامل لك في C++.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "بنية البرنامج"
    ]
  },
  {
    "objectID": "b0/cpp/structure-of-a-program.html#التعليقات-comments",
    "href": "b0/cpp/structure-of-a-program.html#التعليقات-comments",
    "title": "بنية البرنامج",
    "section": "",
    "text": "التعليقات هي ملاحظات يكتبها المبرمج، ويتجاهلها الحاسوب تمامًا. الغرض منها توضيح وظيفة أجزاء من البرنامج.\n\n// This is a single-line comment\n\n/*\nThis is a\nmulti-line comment\n*/\n\nستستخدم التعليقات كثيرًا لشرح ما يفعله الكود وتذكير نفسك أو غيرك بوظيفته.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "بنية البرنامج"
    ]
  },
  {
    "objectID": "b0/cpp/structure-of-a-program.html#المسافات-البادئة-وتحسين-القراءة-indentation",
    "href": "b0/cpp/structure-of-a-program.html#المسافات-البادئة-وتحسين-القراءة-indentation",
    "title": "بنية البرنامج",
    "section": "",
    "text": "يُفضَّل دائمًا الإزاحة (Indent) داخل الأقواس {} باستخدام Tab أو 4 مسافات؛ لأن ذلك يجعل الكود أوضح وأسهل قراءة:\n\nint main() {\n    cout &lt;&lt; \"Good style matters!\";\n}\n\nأسلوب غير جيّد:\n\nint main(){\ncout&lt;&lt;\"Hard to read\";\n}\n\nتنظيم البرنامج لا يغيّر من طريقة تنفيذ البرنامج، لكنه مهم جدًا لقراءتها وصيانتها.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "بنية البرنامج"
    ]
  },
  {
    "objectID": "b0/cpp/while.html",
    "href": "b0/cpp/while.html",
    "title": "حلقة while",
    "section": "",
    "text": "تُعدّ حلقة while أبسط حلقات التكرار في لغة C++. فهي تنفّذ امرا أو كتلة اوامر مرارًا ما دام الشرط صحيحًا.\n\n\n\nwhile (expression)\n    statement;\n\n\nيتم تقييم التعبير expression قبل كل دورة (iteration).\nإذا كانت قيمة التعبير true، ينفد الامر داخل الحلقة.\nإذا كانت false، تتوقّف الحلقة، ويستمر تنفيذ البرنامج بعدها.\n\n\n\n\n\n// custom countdown using while\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n = 10;\n\n    while (n &gt; 0) {\n        cout &lt;&lt; n &lt;&lt; \", \";\n        --n;\n    }\n\n    cout &lt;&lt; \"liftoff!\\n\";\n}\n\nالناتج:\n\n10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff!\n\n\n\n\n\nتبدأ قيمة n بـ 10.\nيتم فحص الشرط n &gt; 0.\nإذا كان الشرط صحيحًا → تُطبع قيمة n، ثم تُنقص بمقدار واحد.\nعندما تصل n إلى 0 → يصبح الشرط خاطئًا → تتوقّف الحلقة.\nيواصل البرنامج التنفيذ بعد نهاية الحلقة.\n\n\n\n\n\n\n\nImportant\n\n\n\nتحدث حلقة لا نهائية عندما يبقى شرط الحلقة دائمًا صحيحًا. على سبيل المثال، إذا نسينا تحديث قيمة n داخل الحلقة (حذف --n)، أو كتبنا شرطًا مثل while (true) بدون كسر الحلقة، فلن تنتهي أبدًا. لذلك يجب التأكّد من أنّ الشرط سيصبح في النهاية خاطئًا.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "حلقة `while`"
    ]
  },
  {
    "objectID": "b0/cpp/while.html#الصياغة-syntax",
    "href": "b0/cpp/while.html#الصياغة-syntax",
    "title": "حلقة while",
    "section": "",
    "text": "while (expression)\n    statement;\n\n\nيتم تقييم التعبير expression قبل كل دورة (iteration).\nإذا كانت قيمة التعبير true، ينفد الامر داخل الحلقة.\nإذا كانت false، تتوقّف الحلقة، ويستمر تنفيذ البرنامج بعدها.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "حلقة `while`"
    ]
  },
  {
    "objectID": "b0/cpp/while.html#مثال-العد-التنازلي",
    "href": "b0/cpp/while.html#مثال-العد-التنازلي",
    "title": "حلقة while",
    "section": "",
    "text": "// custom countdown using while\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n = 10;\n\n    while (n &gt; 0) {\n        cout &lt;&lt; n &lt;&lt; \", \";\n        --n;\n    }\n\n    cout &lt;&lt; \"liftoff!\\n\";\n}\n\nالناتج:\n\n10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff!",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "حلقة `while`"
    ]
  },
  {
    "objectID": "b0/cpp/while.html#كيف-تعمل-الحلقة",
    "href": "b0/cpp/while.html#كيف-تعمل-الحلقة",
    "title": "حلقة while",
    "section": "",
    "text": "تبدأ قيمة n بـ 10.\nيتم فحص الشرط n &gt; 0.\nإذا كان الشرط صحيحًا → تُطبع قيمة n، ثم تُنقص بمقدار واحد.\nعندما تصل n إلى 0 → يصبح الشرط خاطئًا → تتوقّف الحلقة.\nيواصل البرنامج التنفيذ بعد نهاية الحلقة.\n\n\n\n\n\n\n\nImportant\n\n\n\nتحدث حلقة لا نهائية عندما يبقى شرط الحلقة دائمًا صحيحًا. على سبيل المثال، إذا نسينا تحديث قيمة n داخل الحلقة (حذف --n)، أو كتبنا شرطًا مثل while (true) بدون كسر الحلقة، فلن تنتهي أبدًا. لذلك يجب التأكّد من أنّ الشرط سيصبح في النهاية خاطئًا.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "حلقة `while`"
    ]
  },
  {
    "objectID": "b0/cpp/functions.html",
    "href": "b0/cpp/functions.html",
    "title": "الدوال",
    "section": "",
    "text": "الدالة هي مجموعة من الأوامر مجمعة تحت اسم معين. يمكن استدعاء هذا الاسم لتنفيذ الأوامر عند الحاجة.\nتتكون الدالة في C++ من أربعة أجزاء رئيسية:\n\nاسم الدالة : الاسم الذي سيتم استخدامه لاستدعاء الدالة.\nمحتوى الدالة : المكان الذي تكتب فيه أوامر الدالة.\nالمعاملات : القيم التي تُمرر إلى الدالة عند استدعائها. يمكن أن تحتوي الدالة على أي عدد من المعاملات (بما في ذلك صفر).\nنوع القيمة المرجعة : الدوال يمكن أن تُرجع قيمة إلى الموضع الذي استدعيت منها. نوع القيمة المرجعة يحدد نوع هذه القيمة المرجعة. إذا لم تُرجع الدالة أي شيء، يجب أن يكون نوعها void.\n\n\n\n\n\n\nتُكتب الدوال عادةً خارج الدالة main() بالصورة التالية:\n\nreturn_type function_name(parameter1, parameter2, ... , parameterN) {\n    // محتوى الدالة\n}\n\n\n\n\n\n\n\n\nالعنصر\nالشرح\n\n\n\n\nreturn_type\nنوع القيمة التي سترجعها الدالة (مثل int, long long, string…). إذا كان void، فلن تُرجع الدالة أي قيمة.\n\n\nfunction_name\nالاسم الذي تستدعي به الدالة.\n\n\nparameter1, parameter2, ... , parameterN\nمعاملات الدالة.\n\n\n\n\n\n\nلاستدعاء دالة نستخدم الصيغة التالية:\n\nfunction_name(value1, value2, ... , valueN);\n\n\n\n\nمثال على برنامج يحتوي على دالة لا تُرجع أي قيمة (return_type = void) ولا تحتوي على معاملات هو كالتالي:\n\n#include&lt;iostream&gt;\nusing namespace std;\n \nvoid f() { //  وليس لديها معاملات (void) ولا ترجع أي قيمة f دالة باسم\n    cout &lt;&lt; \"Hello Function\" &lt;&lt; endl;\n}\n \nint main() { // يبدأ البرنامج من هنا\n    f();\n    cout &lt;&lt; \"Hello Main\" &lt;&lt; endl;\n    f();\n}\n\nالناتج سيكون:\nHello Function\nHello Main\nHello Function\nهذا البرنامج يحتوي على دالتين: f() و main(). تنفذ C++ main() فقط، ومن داخلها يتم استدعاء باقي الدوال. أولاً يتم استدعاء f() من main()، فتبدأ بتنفيذ الأمر cout &lt;&lt; \"Hello Function\"&lt;&lt; endl; عند الانتهاء من f()، يعود التنفيذ إلى main() ويستمر ببتنفيذ الأمر cout &lt;&lt; \"Hello Main\" &lt;&lt; endl; وثم تقوم باستدعاء f() مرة أخرى.\n\n\n\n\n\n\nالمعاملات هي متغيرات تستقبل قيمة عند استدعاء الدالة. تُعرف بالشكل التالي: parameter_type parameter_name. مثال:\n\nvoid multiply(int x, int y) {\n    cout &lt;&lt; x * y &lt;&lt; endl;\n}\n\nهنا قمنا بتعريف دالة multiply() التي تستقبل معاملين (x و y) وتطبع حاصل ضربهما.\n\n\n\nلاستدعاء multiply() نضع القيم التي نريد تمريرها داخل الأقواس عند الاستدعاء. يجب أن يتطابق ترتيب القيم الممررة مع ترتيب المعاملات في التعريف. مثال لطباعة حاصل ضرب 5 و 3:\n\nmultiply(5, 3);\n\nهنا تم استدعاء الدالة بحيث x = 5 و y = 3.\n\n\n\n\n\nflowchart BT\n    subgraph استدعاء\n        F[\"multiply(5, 3)\"]\n    end\n\n    subgraph الدالة\n        M[\"int multiply(int x, int y)\"]\n        X[\"x = 5\"]\n        Y[\"y = 3\"]\n    end\n\n    F --&gt; X\n    F --&gt; Y\n    X --&gt; M\n    Y --&gt; M\n\n\n\n\n\n\n\n\n\nعند تمرير متغير إلى دالة، تنسخ قيمته ويتم إسنادها إلى المعامل الخاص بالدالة. أي تعديل يحصل للمعامل داخل الدالة لا يؤثر على المتغير الأصلي. هذا يسمى تمرير بالقيمة. لكن يمكن تمرير المتغير بالمرجع بحيث يصبح المعامل هو نفسه المتغير الذي تم تمريره، وأي تعديل يحصل للمعامل يغير قيمة المتغير الأصلي.\nلتمرير المعامل بالمرجع نضف & قبل اسم المعامل. مثال:\n\nvoid addOneByValue(int x) {\n    x = x + 1;\n}\n\n\nvoid addOneByReference(int &x) {\n    x = x + 1;\n}\n\nمثال يستخدم كلا الطريقتين:\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nvoid addOneByReference(int &x) {\n    x = x + 1;\n}\n\nvoid addOneByValue(int x) {\n    x = x + 1;\n}\n\nint main() {\n    int n = 5;\n    addOneByValue(n); // لن يتغير nو ،n سينسخ قيمة x \n    cout &lt;&lt; n &lt;&lt; endl;\n    addOneByReference(n); // x يتغير بتغير nو ،n سيصبح x \n    cout &lt;&lt; n &lt;&lt; endl;\n}\n\nالناتج سيكون:\n5\n6\nعند استدعاء addOneByValue(n); تم نسخ قيمة n إلى x، فالتعديل على x لم يغير قيمة n. وعند استدعاء addOneByReference(n); أصبح x هو n نفسه، فالتعديل على x غيّر قيمة n.\n\n\n\n\nبعد انتهاء أي دالة، يمكنها إرجاع قيمة للموضع التي استدعيت فيه بكتابة return. لكتابة دالة ترجع قيمة معينة يجب تحديد نوع القيمة المرجعة قبل اسم الدالة. مثال:\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int result = add(5, 3); // هي 8 result أصبحت قيمة\n}\n\n\n\n\n\n\n\n\nالجزء\nالشرح\n\n\n\n\nint قبل add\nالدالة ترجع عدداً من نوع int.\n\n\nreturn a + b\nتُرجع ناتج الجمع إلى مكان الاستدعاء.\n\n\nint result = add(5, 3)\nتخزّن القيمة المرجعة في المتغير result.\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant main()\n    participant Add()\n\n    main()-&gt;&gt;Add():  add(5, 3) استدعاء\n    Add()-&gt;&gt;Add():  a + b حساب\n    Add()--&gt;&gt;main(): return 8\n    main()-&gt;&gt;main(): result = 8\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nبعد return a + b; تنتهي الدالة فوراً، وأي تعليمات بعدها لن تُنفذ.\n\n\n\n\n\n\n\nيمكن استدعاء دالة داخل دالة أخرى. عند انتهاء الدالة المستدعاة يعود التنفيذ إلى الدالة التي استدعتها. مثال:\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvoid m() {\n    cout &lt;&lt; \"third\" &lt;&lt; endl;\n}\n\nvoid f() {\n    cout &lt;&lt; \"second\" &lt;&lt; endl;\n    m();\n    cout &lt;&lt; \"fourth\" &lt;&lt; endl;\n}\n\nint main() {\n    cout &lt;&lt; \"first\" &lt;&lt; endl;\n    f();\n    cout &lt;&lt; \"fifth\" &lt;&lt; endl;\n}\n\nالناتج:\nfirst\nsecond\nthird\nfourth\nfifth\nالبرنامج يبدأ بتنفيذ main() التي تنفذ cout &lt;&lt; \"first\" &lt;&lt; endl; ثم تستدعي f()، داخل f() يتم تنفيذ cout &lt;&lt; \"second\" &lt;&lt; endl; ثم يتم استدعاء m()، داخل m() يتم تنفيذ cout &lt;&lt; \"third\" &lt;&lt; endl; ثم تنتهي الدالة وتعود إلى f() لتنفيذ cout &lt;&lt; \"fourth\" &lt;&lt; endl; ، ثم تنتهي f() وتعود إلى main() لتنفيذ cout &lt;&lt; \"fifth\" &lt;&lt; endl;.\n\n\n\n\n\n\nsequenceDiagram\n    participant main()\n    participant f()\n    participant m()\n\n    main()-&gt;&gt;main(): cout &lt;&lt; \"first\" &lt;&lt; endl;\n    main()-&gt;&gt;f():  f() استدعاء\n    f()-&gt;&gt;f(): cout &lt;&lt; \"second\" &lt;&lt; endl;\n    f()-&gt;&gt;m():  m() استدعاء;\n    m()-&gt;&gt;m(): cout &lt;&lt; \"third\" &lt;&lt; endl;\n    m()--&gt;&gt;f(): return\n    f()-&gt;&gt;f(): cout &lt;&lt; \"fourth\" &lt;&lt; endl;\n    f()--&gt;&gt;main(): return\n    main()-&gt;&gt;main(): cout &lt;&lt; \"fifth\" &lt;&lt; endl;\n\n\n\n\n\n\n\n\n\n\nالدوال العَودية (أو دوال الاستدعاء الذاتي) هي دوال تستدعي نفسها أثناء تنفيذها. مثال: حساب المضروب n! ويحسب كالتالي.\nn! = 1 * 2 * 3 .... * (n - 1) * n\nإذن فإن مضروب الرقم 4 (!4) هو :\n24 = 4 * 3 * 2 * 1 = !4\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nمضروب الرقم n هو حاصل ضرب مضروب n - 1 بn (أي n! = (n - 1)! * n).\n\n\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint factorial(int x) {\n    if (x &lt;= 1) {\n        return 1;\n    } else {\n        return factorial(x - 1) * x;\n    }\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; factorial(n) &lt;&lt; endl;\n}\n\nفي هذا البرنامج قمنا بكتابة دالة factorial() التي تستدعي نفسها لحساب مضروب رقم معين. إذا أدخلنا الرقم 3، سيتم استدعاء factorial(3) التي تستدعي factorial(2) والتي تقوم باستدعاء factorial(1). factorial(1) تُرجع 1 إلى الموضع الذي استدعيت فيه (factorial(2)). factorial(2) تُرجع factorial(1) * 2 = 1 * 2 = 2 إلى factorial(3)، وأخيراً تُرجع factorial(3) القيمة factorial(2) * 3 = 2 * 3 = 6 إلى main() لتُطبع.\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nالشرط if (x &lt;= 1) ضروري جداً لتجنب استدعاء الدالة لنفسها إلى ما لا نهاية.\n\n\n\n\n\n\n\nsequenceDiagram\n    participant ()main\n    participant f(3)\n    participant f(2)\n    participant f(1)\n\n\n    \n    ()main-&gt;&gt;f(3): استدعاء f(3)\n    f(3)-&gt;&gt;f(2): استدعاء f(2)\n    f(2)-&gt;&gt;f(1): استدعاء f(1)\n    f(1)--&gt;&gt;f(2): return 1\n    f(2)--&gt;&gt;f(3): return 1 * 2\n    f(3)--&gt;&gt;()main: return 2 * 3",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الدوال"
    ]
  },
  {
    "objectID": "b0/cpp/functions.html#ما-هي-الدالة",
    "href": "b0/cpp/functions.html#ما-هي-الدالة",
    "title": "الدوال",
    "section": "",
    "text": "الدالة هي مجموعة من الأوامر مجمعة تحت اسم معين. يمكن استدعاء هذا الاسم لتنفيذ الأوامر عند الحاجة.\nتتكون الدالة في C++ من أربعة أجزاء رئيسية:\n\nاسم الدالة : الاسم الذي سيتم استخدامه لاستدعاء الدالة.\nمحتوى الدالة : المكان الذي تكتب فيه أوامر الدالة.\nالمعاملات : القيم التي تُمرر إلى الدالة عند استدعائها. يمكن أن تحتوي الدالة على أي عدد من المعاملات (بما في ذلك صفر).\nنوع القيمة المرجعة : الدوال يمكن أن تُرجع قيمة إلى الموضع الذي استدعيت منها. نوع القيمة المرجعة يحدد نوع هذه القيمة المرجعة. إذا لم تُرجع الدالة أي شيء، يجب أن يكون نوعها void.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الدوال"
    ]
  },
  {
    "objectID": "b0/cpp/functions.html#صيغة-الدوال",
    "href": "b0/cpp/functions.html#صيغة-الدوال",
    "title": "الدوال",
    "section": "",
    "text": "تُكتب الدوال عادةً خارج الدالة main() بالصورة التالية:\n\nreturn_type function_name(parameter1, parameter2, ... , parameterN) {\n    // محتوى الدالة\n}\n\n\n\n\n\n\n\n\nالعنصر\nالشرح\n\n\n\n\nreturn_type\nنوع القيمة التي سترجعها الدالة (مثل int, long long, string…). إذا كان void، فلن تُرجع الدالة أي قيمة.\n\n\nfunction_name\nالاسم الذي تستدعي به الدالة.\n\n\nparameter1, parameter2, ... , parameterN\nمعاملات الدالة.\n\n\n\n\n\n\nلاستدعاء دالة نستخدم الصيغة التالية:\n\nfunction_name(value1, value2, ... , valueN);\n\n\n\n\nمثال على برنامج يحتوي على دالة لا تُرجع أي قيمة (return_type = void) ولا تحتوي على معاملات هو كالتالي:\n\n#include&lt;iostream&gt;\nusing namespace std;\n \nvoid f() { //  وليس لديها معاملات (void) ولا ترجع أي قيمة f دالة باسم\n    cout &lt;&lt; \"Hello Function\" &lt;&lt; endl;\n}\n \nint main() { // يبدأ البرنامج من هنا\n    f();\n    cout &lt;&lt; \"Hello Main\" &lt;&lt; endl;\n    f();\n}\n\nالناتج سيكون:\nHello Function\nHello Main\nHello Function\nهذا البرنامج يحتوي على دالتين: f() و main(). تنفذ C++ main() فقط، ومن داخلها يتم استدعاء باقي الدوال. أولاً يتم استدعاء f() من main()، فتبدأ بتنفيذ الأمر cout &lt;&lt; \"Hello Function\"&lt;&lt; endl; عند الانتهاء من f()، يعود التنفيذ إلى main() ويستمر ببتنفيذ الأمر cout &lt;&lt; \"Hello Main\" &lt;&lt; endl; وثم تقوم باستدعاء f() مرة أخرى.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الدوال"
    ]
  },
  {
    "objectID": "b0/cpp/functions.html#المعاملات",
    "href": "b0/cpp/functions.html#المعاملات",
    "title": "الدوال",
    "section": "",
    "text": "المعاملات هي متغيرات تستقبل قيمة عند استدعاء الدالة. تُعرف بالشكل التالي: parameter_type parameter_name. مثال:\n\nvoid multiply(int x, int y) {\n    cout &lt;&lt; x * y &lt;&lt; endl;\n}\n\nهنا قمنا بتعريف دالة multiply() التي تستقبل معاملين (x و y) وتطبع حاصل ضربهما.\n\n\n\nلاستدعاء multiply() نضع القيم التي نريد تمريرها داخل الأقواس عند الاستدعاء. يجب أن يتطابق ترتيب القيم الممررة مع ترتيب المعاملات في التعريف. مثال لطباعة حاصل ضرب 5 و 3:\n\nmultiply(5, 3);\n\nهنا تم استدعاء الدالة بحيث x = 5 و y = 3.\n\n\n\n\n\nflowchart BT\n    subgraph استدعاء\n        F[\"multiply(5, 3)\"]\n    end\n\n    subgraph الدالة\n        M[\"int multiply(int x, int y)\"]\n        X[\"x = 5\"]\n        Y[\"y = 3\"]\n    end\n\n    F --&gt; X\n    F --&gt; Y\n    X --&gt; M\n    Y --&gt; M\n\n\n\n\n\n\n\n\n\nعند تمرير متغير إلى دالة، تنسخ قيمته ويتم إسنادها إلى المعامل الخاص بالدالة. أي تعديل يحصل للمعامل داخل الدالة لا يؤثر على المتغير الأصلي. هذا يسمى تمرير بالقيمة. لكن يمكن تمرير المتغير بالمرجع بحيث يصبح المعامل هو نفسه المتغير الذي تم تمريره، وأي تعديل يحصل للمعامل يغير قيمة المتغير الأصلي.\nلتمرير المعامل بالمرجع نضف & قبل اسم المعامل. مثال:\n\nvoid addOneByValue(int x) {\n    x = x + 1;\n}\n\n\nvoid addOneByReference(int &x) {\n    x = x + 1;\n}\n\nمثال يستخدم كلا الطريقتين:\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nvoid addOneByReference(int &x) {\n    x = x + 1;\n}\n\nvoid addOneByValue(int x) {\n    x = x + 1;\n}\n\nint main() {\n    int n = 5;\n    addOneByValue(n); // لن يتغير nو ،n سينسخ قيمة x \n    cout &lt;&lt; n &lt;&lt; endl;\n    addOneByReference(n); // x يتغير بتغير nو ،n سيصبح x \n    cout &lt;&lt; n &lt;&lt; endl;\n}\n\nالناتج سيكون:\n5\n6\nعند استدعاء addOneByValue(n); تم نسخ قيمة n إلى x، فالتعديل على x لم يغير قيمة n. وعند استدعاء addOneByReference(n); أصبح x هو n نفسه، فالتعديل على x غيّر قيمة n.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الدوال"
    ]
  },
  {
    "objectID": "b0/cpp/functions.html#القيم-المرجعة",
    "href": "b0/cpp/functions.html#القيم-المرجعة",
    "title": "الدوال",
    "section": "",
    "text": "بعد انتهاء أي دالة، يمكنها إرجاع قيمة للموضع التي استدعيت فيه بكتابة return. لكتابة دالة ترجع قيمة معينة يجب تحديد نوع القيمة المرجعة قبل اسم الدالة. مثال:\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int result = add(5, 3); // هي 8 result أصبحت قيمة\n}\n\n\n\n\n\n\n\n\nالجزء\nالشرح\n\n\n\n\nint قبل add\nالدالة ترجع عدداً من نوع int.\n\n\nreturn a + b\nتُرجع ناتج الجمع إلى مكان الاستدعاء.\n\n\nint result = add(5, 3)\nتخزّن القيمة المرجعة في المتغير result.\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant main()\n    participant Add()\n\n    main()-&gt;&gt;Add():  add(5, 3) استدعاء\n    Add()-&gt;&gt;Add():  a + b حساب\n    Add()--&gt;&gt;main(): return 8\n    main()-&gt;&gt;main(): result = 8\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nبعد return a + b; تنتهي الدالة فوراً، وأي تعليمات بعدها لن تُنفذ.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الدوال"
    ]
  },
  {
    "objectID": "b0/cpp/functions.html#الاستدعاء-في-الدوال",
    "href": "b0/cpp/functions.html#الاستدعاء-في-الدوال",
    "title": "الدوال",
    "section": "",
    "text": "يمكن استدعاء دالة داخل دالة أخرى. عند انتهاء الدالة المستدعاة يعود التنفيذ إلى الدالة التي استدعتها. مثال:\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvoid m() {\n    cout &lt;&lt; \"third\" &lt;&lt; endl;\n}\n\nvoid f() {\n    cout &lt;&lt; \"second\" &lt;&lt; endl;\n    m();\n    cout &lt;&lt; \"fourth\" &lt;&lt; endl;\n}\n\nint main() {\n    cout &lt;&lt; \"first\" &lt;&lt; endl;\n    f();\n    cout &lt;&lt; \"fifth\" &lt;&lt; endl;\n}\n\nالناتج:\nfirst\nsecond\nthird\nfourth\nfifth\nالبرنامج يبدأ بتنفيذ main() التي تنفذ cout &lt;&lt; \"first\" &lt;&lt; endl; ثم تستدعي f()، داخل f() يتم تنفيذ cout &lt;&lt; \"second\" &lt;&lt; endl; ثم يتم استدعاء m()، داخل m() يتم تنفيذ cout &lt;&lt; \"third\" &lt;&lt; endl; ثم تنتهي الدالة وتعود إلى f() لتنفيذ cout &lt;&lt; \"fourth\" &lt;&lt; endl; ، ثم تنتهي f() وتعود إلى main() لتنفيذ cout &lt;&lt; \"fifth\" &lt;&lt; endl;.\n\n\n\n\n\n\nsequenceDiagram\n    participant main()\n    participant f()\n    participant m()\n\n    main()-&gt;&gt;main(): cout &lt;&lt; \"first\" &lt;&lt; endl;\n    main()-&gt;&gt;f():  f() استدعاء\n    f()-&gt;&gt;f(): cout &lt;&lt; \"second\" &lt;&lt; endl;\n    f()-&gt;&gt;m():  m() استدعاء;\n    m()-&gt;&gt;m(): cout &lt;&lt; \"third\" &lt;&lt; endl;\n    m()--&gt;&gt;f(): return\n    f()-&gt;&gt;f(): cout &lt;&lt; \"fourth\" &lt;&lt; endl;\n    f()--&gt;&gt;main(): return\n    main()-&gt;&gt;main(): cout &lt;&lt; \"fifth\" &lt;&lt; endl;\n\n\n\n\n\n\n\n\n\n\nالدوال العَودية (أو دوال الاستدعاء الذاتي) هي دوال تستدعي نفسها أثناء تنفيذها. مثال: حساب المضروب n! ويحسب كالتالي.\nn! = 1 * 2 * 3 .... * (n - 1) * n\nإذن فإن مضروب الرقم 4 (!4) هو :\n24 = 4 * 3 * 2 * 1 = !4\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nمضروب الرقم n هو حاصل ضرب مضروب n - 1 بn (أي n! = (n - 1)! * n).\n\n\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint factorial(int x) {\n    if (x &lt;= 1) {\n        return 1;\n    } else {\n        return factorial(x - 1) * x;\n    }\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; factorial(n) &lt;&lt; endl;\n}\n\nفي هذا البرنامج قمنا بكتابة دالة factorial() التي تستدعي نفسها لحساب مضروب رقم معين. إذا أدخلنا الرقم 3، سيتم استدعاء factorial(3) التي تستدعي factorial(2) والتي تقوم باستدعاء factorial(1). factorial(1) تُرجع 1 إلى الموضع الذي استدعيت فيه (factorial(2)). factorial(2) تُرجع factorial(1) * 2 = 1 * 2 = 2 إلى factorial(3)، وأخيراً تُرجع factorial(3) القيمة factorial(2) * 3 = 2 * 3 = 6 إلى main() لتُطبع.\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nالشرط if (x &lt;= 1) ضروري جداً لتجنب استدعاء الدالة لنفسها إلى ما لا نهاية.\n\n\n\n\n\n\n\nsequenceDiagram\n    participant ()main\n    participant f(3)\n    participant f(2)\n    participant f(1)\n\n\n    \n    ()main-&gt;&gt;f(3): استدعاء f(3)\n    f(3)-&gt;&gt;f(2): استدعاء f(2)\n    f(2)-&gt;&gt;f(1): استدعاء f(1)\n    f(1)--&gt;&gt;f(2): return 1\n    f(2)--&gt;&gt;f(3): return 1 * 2\n    f(3)--&gt;&gt;()main: return 2 * 3",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "الدوال"
    ]
  },
  {
    "objectID": "b0/cpp/vectors.html",
    "href": "b0/cpp/vectors.html",
    "title": "vector",
    "section": "",
    "text": "في C++، المصفوفات لها حجم ثابت، أي لا يمكنك تغيير عدد العناصر التي تحتويها بعد إنشائها. قد تكون هذه مشكلة إذا لم تكن تعرف مسبقًا عدد العناصر التي ستحتاجها. لحل هذه المشكلة، توفر C++ الكائن std::vector. يعمل vector مثل المصفوفة، لكنه يمكن أن ينمو أو يتقلص عند إضافة أو إزالة عناصر.\n\n\nvector هي جزء من مكتبة تُسمى &lt;vector&gt; وتُعرّف كما يلي:\n\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;type&gt; name;\n\n\n\n\n\n\n\n\nالعنصر\nالشرح\n\n\n\n\nname\nهو اسم الـvector.\n\n\ntype\nهو نوع البيانات المخزن في الـvector. يمكن أن يكون أي نوع C++ صالح (int, double, string, إلخ).\n\n\n\nبعد تعريف الـvector، يكون الـvector فارغًا (كمصفوفة بحجم 0). لإعطاء الـvector حجمًا ابتدائيًا، استخدم الصيغة التالية:\n\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;type&gt; name(size, value);\n\n\n\n\n\n\n\n\nالعنصر\nالشرح\n\n\n\n\nsize\nعدد العناصر في الـvector.\n\n\nvalue\nالقيمة الابتدائية المعطاة لجميع عناصر الـvector.\n\n\n\n\n\n\nيتصرف الـvector بطريقة مشابهة للمصفوفات. ومع ذلك، فإن للـvector وظائف إضافية. لنفترض أننا عرّفنا vector اسمه v.\n\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;int&gt; v;\n\nبما أن v يمكن أن يتغير حجمه، نستخدم v.size() للحصول على عدد العناصر في طv.\nالوظيفتان الرئيسيتان اللتان تجعل الـvector مميزا هما v.push_back(x) وv.pop_back().\n\nv.push_back(x) تضيف القيمة x إلى نهاية الـvector.\n\nv.pop_back() تزيل آخر عنصر في الـvector.\n\nالجدول التالي يوضح بعض الدوال الشائعة التي يمكن إجراؤها على الـvector:\n\n\n\n\n\n\n\nالدالة\nالوصف\n\n\n\n\nv.size()\nتُعيد عدد العناصر الحالي في الـvector.\n\n\nv.push_back(x)\nتضيف العنصر x إلى نهاية الـvector.\n\n\nv.pop_back()\nتزيل آخر عنصر من الـvector.\n\n\nv.resize(n)\nتغيّر عدد عناصر الـvector إلى n. إذا كان n أكبر من الحجم الحالي للـvector، تُضاف عناصر جديدة؛ وإذا كان أصغر، تُزال العناصر الزائدة من النهاية.\n\n\nv.clear()\nتزيل جميع العناصر من الـvector.\n\n\n\n\n\n\nلنلق نظرة على برنامج يستخدم الـvector .\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    \n    vector&lt;int&gt; v(3, 5);         // بحجم 3 وكل عناصره 5 vector يعرف\n\n    v.pop_back();                // v = {5, 5} يزيل آخر عنصر، فيصبح \n\n    v.push_back(2);              // v = {5, 5, 2} يضيف العنصر 2 إلى النهاية، فيصبح \n    v.push_back(1);              //  v = {5, 5, 2, 1}يضيف العنصر 1 إلى النهاية، فيصبح \n\n    cout &lt;&lt; v.size() &lt;&lt; endl;    // v يطبع عدد العناصر في \n\n    for (int i = 0; i &lt; v.size(); i++) {\n        cout &lt;&lt; v[i] &lt;&lt; ' ';     // i يطبع العنصر عند الموقع \n    }\n}\n&lt;/div&gt;\nسيكون ناتج هذا البرنامج:\n4\n5 5 2 1\nيوضح هذا المثال العمليات الأساسية على الـvector — الإضافة والإزالة — وتأثيرها على المحتوى والحجم.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "<span dir=\"ltr\">`vector`</span>"
    ]
  },
  {
    "objectID": "b0/cpp/vectors.html#تعريف-الـvector",
    "href": "b0/cpp/vectors.html#تعريف-الـvector",
    "title": "vector",
    "section": "",
    "text": "vector هي جزء من مكتبة تُسمى &lt;vector&gt; وتُعرّف كما يلي:\n\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;type&gt; name;\n\n\n\n\n\n\n\n\nالعنصر\nالشرح\n\n\n\n\nname\nهو اسم الـvector.\n\n\ntype\nهو نوع البيانات المخزن في الـvector. يمكن أن يكون أي نوع C++ صالح (int, double, string, إلخ).\n\n\n\nبعد تعريف الـvector، يكون الـvector فارغًا (كمصفوفة بحجم 0). لإعطاء الـvector حجمًا ابتدائيًا، استخدم الصيغة التالية:\n\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;type&gt; name(size, value);\n\n\n\n\n\n\n\n\nالعنصر\nالشرح\n\n\n\n\nsize\nعدد العناصر في الـvector.\n\n\nvalue\nالقيمة الابتدائية المعطاة لجميع عناصر الـvector.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "<span dir=\"ltr\">`vector`</span>"
    ]
  },
  {
    "objectID": "b0/cpp/vectors.html#العمليات-على-الـvector",
    "href": "b0/cpp/vectors.html#العمليات-على-الـvector",
    "title": "vector",
    "section": "",
    "text": "يتصرف الـvector بطريقة مشابهة للمصفوفات. ومع ذلك، فإن للـvector وظائف إضافية. لنفترض أننا عرّفنا vector اسمه v.\n\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;int&gt; v;\n\nبما أن v يمكن أن يتغير حجمه، نستخدم v.size() للحصول على عدد العناصر في طv.\nالوظيفتان الرئيسيتان اللتان تجعل الـvector مميزا هما v.push_back(x) وv.pop_back().\n\nv.push_back(x) تضيف القيمة x إلى نهاية الـvector.\n\nv.pop_back() تزيل آخر عنصر في الـvector.\n\nالجدول التالي يوضح بعض الدوال الشائعة التي يمكن إجراؤها على الـvector:\n\n\n\n\n\n\n\nالدالة\nالوصف\n\n\n\n\nv.size()\nتُعيد عدد العناصر الحالي في الـvector.\n\n\nv.push_back(x)\nتضيف العنصر x إلى نهاية الـvector.\n\n\nv.pop_back()\nتزيل آخر عنصر من الـvector.\n\n\nv.resize(n)\nتغيّر عدد عناصر الـvector إلى n. إذا كان n أكبر من الحجم الحالي للـvector، تُضاف عناصر جديدة؛ وإذا كان أصغر، تُزال العناصر الزائدة من النهاية.\n\n\nv.clear()\nتزيل جميع العناصر من الـvector.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "<span dir=\"ltr\">`vector`</span>"
    ]
  },
  {
    "objectID": "b0/cpp/vectors.html#مثال",
    "href": "b0/cpp/vectors.html#مثال",
    "title": "vector",
    "section": "",
    "text": "لنلق نظرة على برنامج يستخدم الـvector .\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    \n    vector&lt;int&gt; v(3, 5);         // بحجم 3 وكل عناصره 5 vector يعرف\n\n    v.pop_back();                // v = {5, 5} يزيل آخر عنصر، فيصبح \n\n    v.push_back(2);              // v = {5, 5, 2} يضيف العنصر 2 إلى النهاية، فيصبح \n    v.push_back(1);              //  v = {5, 5, 2, 1}يضيف العنصر 1 إلى النهاية، فيصبح \n\n    cout &lt;&lt; v.size() &lt;&lt; endl;    // v يطبع عدد العناصر في \n\n    for (int i = 0; i &lt; v.size(); i++) {\n        cout &lt;&lt; v[i] &lt;&lt; ' ';     // i يطبع العنصر عند الموقع \n    }\n}\n&lt;/div&gt;\nسيكون ناتج هذا البرنامج:\n4\n5 5 2 1\nيوضح هذا المثال العمليات الأساسية على الـvector — الإضافة والإزالة — وتأثيرها على المحتوى والحجم.",
    "crumbs": [
      "المرحلة 1",
      "أساسيات ++C",
      "<span dir=\"ltr\">`vector`</span>"
    ]
  },
  {
    "objectID": "b0/problems/beautiful-matrix.html",
    "href": "b0/problems/beautiful-matrix.html",
    "title": "",
    "section": "",
    "text": "Beautiful Matrix\n\nCodeforces\neasy\n\n\n\nعند إعطائك مصفوفة بحجم \\(5 \\times 5\\) تحتوي على \\(24\\) صفراً وواحد فقط من القيمة \\(1\\)، تكون مهمتك هي إيجاد أقل عدد من الحركات المطلوبة لوضع العدد \\(1\\) في مركز المصفوفة.\nالحركات المسموح بها هي تبديل موقع خليتين متجاورتين عموديًا أو أفقيًا.\n\n\n\n\n\nSolution\n\nإن التحركات العمودية والأفقية مستقلة عن بعضها، لذلك يمكن التفكير في كل واحدة على حدة. إذا قمنا بترقيم الصفوف من \\(1\\) إلى \\(5\\)، فإن الصف الأوسط هو الصف رقم \\(3\\). لنفترض أن العدد \\(1\\) موجود حاليًا في الصف رقم \\(r\\). كل حركة عمودية تغيّر موقعه بمقدار صف واحد، لذا سيحتاج إلى \\(|r - 3|\\) حركة للوصول إلى الصف الأوسط.\nوبالطريقة نفسها، إذا قمنا بترقيم الأعمدة من \\(1\\) إلى \\(5\\)، فإن العمود الأوسط هو العمود رقم \\(3\\). وإذا كان العدد \\(1\\) في العمود رقم \\(c\\)، فسيحتاج إلى \\(|c - 3|\\) حركة للوصول إلى العمود الأوسط.\nبجمع هاتين القيمتين نحصل على العدد الكلي للحركات المطلوبة: \\(|r - 3| + |c - 3|\\)\n\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint abs_val(int v) {\n    return (v &gt; 0 ? v : -v); // عامل شرطي يعيد القيمة الموجبة دائمًا\n}\n\nint main () {\n    int r, c;\n\n    for (int i = 1 ; i &lt;= 5 ; i++) {\n        for (int j = 1 ; j &lt;= 5 ; j++) {\n            int x;\n            cin &gt;&gt; x;\n\n            if (x == 1) {\n                r = i;\n                c = j;\n            }\n        }\n    }\n\n    cout &lt;&lt; abs_val(r - 3) + abs_val(c - 3);\n}",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Beautiful Matrix"
    ]
  },
  {
    "objectID": "b0/problems/beautiful-matrix.html#beautiful-matrix",
    "href": "b0/problems/beautiful-matrix.html#beautiful-matrix",
    "title": "",
    "section": "",
    "text": "Beautiful Matrix\n\nCodeforces\neasy\n\n\n\nعند إعطائك مصفوفة بحجم \\(5 \\times 5\\) تحتوي على \\(24\\) صفراً وواحد فقط من القيمة \\(1\\)، تكون مهمتك هي إيجاد أقل عدد من الحركات المطلوبة لوضع العدد \\(1\\) في مركز المصفوفة.\nالحركات المسموح بها هي تبديل موقع خليتين متجاورتين عموديًا أو أفقيًا.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Beautiful Matrix"
    ]
  },
  {
    "objectID": "b0/problems/bit++.html",
    "href": "b0/problems/bit++.html",
    "title": "",
    "section": "",
    "text": "Bit++\n\nCodeforces\neasy\n\n\n\nتم إعطاؤك \\(n\\) جملة في لغة \\(\\text{Bit++}\\). يوجد متغير واحد \\(x\\)، مبدئيًا قيمته \\(0\\).\nكل جملة هي بالضبط واحدة من: ++X، X++، --X، X--.\nتنفيذ ++ يزيد \\(x\\) بمقدار 1؛ وتنفيذ -- ينقص \\(x\\) بمقدار 1.\nبعد تنفيذ جميع الجمل \\(n\\)، اطبع القيمة النهائية لـ \\(x\\).\n\n\n\n\n\nSolution\n\nكل سطر يغير \\(x\\) بمقدار ±1 بالضبط. بما أن حرف X قد يظهر قبل أو بعد العملية، فإن قاعدة بسيطة وموثوقة هي:\n\nانظر إلى الحرف الأوسط في الجملة ذات الثلاث خانات. إذا كان '+'، فهذا يعني وجود ++ → أضف 1؛ وإلا فهو '-' → اطرح 1.\n\nالخوارزمية:\n\nاقرأ \\(n\\)، واجعل \\(x \\leftarrow 0\\).\nلكل سطر من \\(n\\) أسطر، اقرأ السلسلة s وحدّث:\n\nإذا كان s[1] = '+' نفّذ ++x؛ وإلا نفّذ --x.\n\nاطبع \\(x\\).\n\nيعمل هذا في زمن \\(O(n)\\) ويحتاج لمساحة إضافية \\(O(1)\\) فقط.\n\n\n\n\n\n\nNoteخدعة التحليل (Parsing trick)\n\n\n\nكل الجمل الصالحة لها طول 3 خانات. العملية دائمًا موجودة في الموقع 1 (s[1]): '+' لكل من ++X/X++ و'-' لكل من --X/X--.\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    int n; \n    cin &gt;&gt; n;\n    int x = 0;\n\n    while (n--) {\n        string s; \n        cin &gt;&gt; s;               // s هي واحدة من: ++X, X++, --X, X--\n        if (s[1] == '+') {\n            ++x;   // الحرف الأوسط يحدد العملية\n        } else {\n            --x;\n        }\n    }\n\n    cout &lt;&lt; x;\n}\n\n\n\n\n\n\n\n\nCautionصيغة الإدخال\n\n\n\nالجمل مضمونة أن تكون بدون فراغات وطولها 3 خانات، لذا قراءة كل واحدة في string باستخدام cin &gt;&gt; s آمنة.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Bit++"
    ]
  },
  {
    "objectID": "b0/problems/bit++.html#bit++",
    "href": "b0/problems/bit++.html#bit++",
    "title": "",
    "section": "",
    "text": "Bit++\n\nCodeforces\neasy\n\n\n\nتم إعطاؤك \\(n\\) جملة في لغة \\(\\text{Bit++}\\). يوجد متغير واحد \\(x\\)، مبدئيًا قيمته \\(0\\).\nكل جملة هي بالضبط واحدة من: ++X، X++، --X، X--.\nتنفيذ ++ يزيد \\(x\\) بمقدار 1؛ وتنفيذ -- ينقص \\(x\\) بمقدار 1.\nبعد تنفيذ جميع الجمل \\(n\\)، اطبع القيمة النهائية لـ \\(x\\).",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Bit++"
    ]
  },
  {
    "objectID": "b0/problems/increasing-decreasing-digits.html",
    "href": "b0/problems/increasing-decreasing-digits.html",
    "title": "",
    "section": "",
    "text": "Increasing Decreasing Digits\n\n\nhard\n\n\n\nيُسمّى العدد جميلًا إذا كان يحتوي على ثلاثة خانات على الأقل، ولا يحتوي على الخانة \\(0\\)، وأرقامه تكون عبارة عن تسلسل متزايد بدقة (بطول لا يقل عن \\(2\\)) من البداية حتى خانة معينة، ثم تسلسل متناقص بدقة (بطول لا يقل عن \\(2\\)) من تلك الخانة حتى النهاية.\nعلى سبيل المثال، الأعداد \\(125862\\) و \\(565\\) و \\(89731\\) هي أعداد جميلة، بينما \\(23241\\) و \\(89722\\) و \\(1234\\) ليست كذلك.\nبالنسبة لعدد طبيعي مُعطى \\(A\\)، حدد أصغر عدد جميل أكبر من \\(A\\) مباشرة.\nعلى سبيل المثال، إذا كان \\(A = 320557\\)، فإن الناتج يكون \\(35321\\).\nيمكنك افتراض أن \\(100 \\leq A \\leq 10^7\\).\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nإذا كان هذا يبدو صعبًا جدًا، يمكنك أولًا محاولة حل المسألة بافتراض أن كلا من \\(A\\) والحل سيكونان مكونين من ثلاثة خانات فقط.",
    "crumbs": [
      "المرحلة 1",
      "مسائل تدريبية",
      "Increasing Decreasing Digits"
    ]
  },
  {
    "objectID": "b0/problems/increasing-decreasing-digits.html#increasing-decreasing-digits",
    "href": "b0/problems/increasing-decreasing-digits.html#increasing-decreasing-digits",
    "title": "",
    "section": "",
    "text": "Increasing Decreasing Digits\n\n\nhard\n\n\n\nيُسمّى العدد جميلًا إذا كان يحتوي على ثلاثة خانات على الأقل، ولا يحتوي على الخانة \\(0\\)، وأرقامه تكون عبارة عن تسلسل متزايد بدقة (بطول لا يقل عن \\(2\\)) من البداية حتى خانة معينة، ثم تسلسل متناقص بدقة (بطول لا يقل عن \\(2\\)) من تلك الخانة حتى النهاية.\nعلى سبيل المثال، الأعداد \\(125862\\) و \\(565\\) و \\(89731\\) هي أعداد جميلة، بينما \\(23241\\) و \\(89722\\) و \\(1234\\) ليست كذلك.\nبالنسبة لعدد طبيعي مُعطى \\(A\\)، حدد أصغر عدد جميل أكبر من \\(A\\) مباشرة.\nعلى سبيل المثال، إذا كان \\(A = 320557\\)، فإن الناتج يكون \\(35321\\).\nيمكنك افتراض أن \\(100 \\leq A \\leq 10^7\\).",
    "crumbs": [
      "المرحلة 1",
      "مسائل تدريبية",
      "Increasing Decreasing Digits"
    ]
  },
  {
    "objectID": "b0/problems/middle-digits.html",
    "href": "b0/problems/middle-digits.html",
    "title": "",
    "section": "",
    "text": "Middle Digits\n\n\nmedium\n\n\n\nتم إعطاء عددين طبيعيين \\(x\\) و \\(y\\)، ولكل منهما عدد فردي من الخانات. اكتب دالة SwapMidDigits(x,y) التي تغيّر قيم هذه الأعداد بالطريقة التالية:\n\nتُزال الخانة الوسطى من \\(x\\) ويُستبدل بالخانة الوسطى من \\(y\\)؛\nتُزال الخانة الوسطى من \\(y\\) ويُستبدل بالخانة الوسطى من \\(x\\).\n\nاطبع الأعداد الجديدة. يجب أن تكتفي الدالة الرئيسية بقراءة \\(x\\) و \\(y\\)، واستدعاء الدالة SwapMidDigits، ثم طباعة القيم الجديدة لـ \\(x\\) و \\(y\\).\nيمكنك افتراض أن \\(100 \\leq x, y &lt; 10^9\\)، وأن كلا من \\(x\\) و \\(y\\) يحتويان على عدد فردي من الخانات.\n\n\n\nإذا كان هذا يبدو صعبًا جدًا، يمكنك أولًا محاولة حل المسألة بافتراض أن كلا من \\(x\\) و \\(y\\) مكونان من ثلاث خانات فقط.",
    "crumbs": [
      "المرحلة 1",
      "مسائل تدريبية",
      "Middle Digits"
    ]
  },
  {
    "objectID": "b0/problems/middle-digits.html#middle-digits",
    "href": "b0/problems/middle-digits.html#middle-digits",
    "title": "",
    "section": "",
    "text": "Middle Digits\n\n\nmedium\n\n\n\nتم إعطاء عددين طبيعيين \\(x\\) و \\(y\\)، ولكل منهما عدد فردي من الخانات. اكتب دالة SwapMidDigits(x,y) التي تغيّر قيم هذه الأعداد بالطريقة التالية:\n\nتُزال الخانة الوسطى من \\(x\\) ويُستبدل بالخانة الوسطى من \\(y\\)؛\nتُزال الخانة الوسطى من \\(y\\) ويُستبدل بالخانة الوسطى من \\(x\\).\n\nاطبع الأعداد الجديدة. يجب أن تكتفي الدالة الرئيسية بقراءة \\(x\\) و \\(y\\)، واستدعاء الدالة SwapMidDigits، ثم طباعة القيم الجديدة لـ \\(x\\) و \\(y\\).\nيمكنك افتراض أن \\(100 \\leq x, y &lt; 10^9\\)، وأن كلا من \\(x\\) و \\(y\\) يحتويان على عدد فردي من الخانات.",
    "crumbs": [
      "المرحلة 1",
      "مسائل تدريبية",
      "Middle Digits"
    ]
  },
  {
    "objectID": "b0/problems/next-round.html",
    "href": "b0/problems/next-round.html",
    "title": "",
    "section": "",
    "text": "Next Round\n\nCodeforces\neasy\n\n\n\nعند إعطائك درجات \\(N\\) مشاركًا في مسابقةٍ ما، تكون مهمتك هي حساب عدد المشاركين الذين كانت درجاتهم أكبر من أو تساوي درجة المشارك الذي حصل على المركز \\(K\\)، بشرط أن تكون درجاتهم موجبة.\n\n\n\n\n\n\nCaution\n\n\n\nمن الأخطاء الشائعة نسيان استبعاد المشاركين الذين حصلوا على درجة \\(0\\)، لذا يجب اتباع نص المسألة بدقة، وأعد قراءتها إذا لم تتمكن من إيجاد الخطأ في فكرتك.\n\n\n\n\n\n\n\n\nTip\n\n\n\nيُعطى في نص المسألة أن \\(A_{i-1} \\ge A_i\\)، وهي معلومة أساسية سنعتمد عليها في الحل.\n\n\n\n\n\n\n\nSolution\n\nالمشارك الذي يحتل المركز \\(K\\) يوجد في الفهرس \\(K - 1\\) من المصفوفة. لذا يكفي أن نكرّر على المصفوفة ونحسب عدد الفهارس التي قيمتها أكبر من أو تساوي تلك القيمة.\n\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    int a[n], ans = 0;\n\n    for (int i = 0 ; i &lt; n ; i++) cin &gt;&gt; a[i];\n\n    for (int i = 0 ; i &lt; n ; i++) {\n        if (a[i] &gt;= a[k - 1] && a[i] &gt; 0) ans++;\n    }\n\n    cout &lt;&lt; ans;\n}\n\n\n\n\n\n\n\nCaution\n\n\n\nيجب قراءة المصفوفة كاملة قبل المعالجة، لأنه إذا تحقق الشرط i &lt; k - 1 فلن تكون قيمة a[k - 1] قد قُرئت بعد.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Next Round"
    ]
  },
  {
    "objectID": "b0/problems/next-round.html#next-round",
    "href": "b0/problems/next-round.html#next-round",
    "title": "",
    "section": "",
    "text": "Next Round\n\nCodeforces\neasy\n\n\n\nعند إعطائك درجات \\(N\\) مشاركًا في مسابقةٍ ما، تكون مهمتك هي حساب عدد المشاركين الذين كانت درجاتهم أكبر من أو تساوي درجة المشارك الذي حصل على المركز \\(K\\)، بشرط أن تكون درجاتهم موجبة.\n\n\n\n\n\n\nCaution\n\n\n\nمن الأخطاء الشائعة نسيان استبعاد المشاركين الذين حصلوا على درجة \\(0\\)، لذا يجب اتباع نص المسألة بدقة، وأعد قراءتها إذا لم تتمكن من إيجاد الخطأ في فكرتك.\n\n\n\n\n\n\n\n\nTip\n\n\n\nيُعطى في نص المسألة أن \\(A_{i-1} \\ge A_i\\)، وهي معلومة أساسية سنعتمد عليها في الحل.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Next Round"
    ]
  },
  {
    "objectID": "b0/problems/sum-product.html",
    "href": "b0/problems/sum-product.html",
    "title": "",
    "section": "",
    "text": "Sum Product\n\n\neasy\n\n\n\nتم إعطاء ثلاثة أعداد صحيحة \\(a\\) و \\(b\\) و \\(c\\). اطبع ناتج ضرب أصغر عدد بينهم في مجموع العددين الآخرين.",
    "crumbs": [
      "المرحلة 1",
      "مسائل تدريبية",
      "Sum Product"
    ]
  },
  {
    "objectID": "b0/problems/sum-product.html#sum-product",
    "href": "b0/problems/sum-product.html#sum-product",
    "title": "",
    "section": "",
    "text": "Sum Product\n\n\neasy\n\n\n\nتم إعطاء ثلاثة أعداد صحيحة \\(a\\) و \\(b\\) و \\(c\\). اطبع ناتج ضرب أصغر عدد بينهم في مجموع العددين الآخرين.",
    "crumbs": [
      "المرحلة 1",
      "مسائل تدريبية",
      "Sum Product"
    ]
  },
  {
    "objectID": "b0/problems/theatre-square.html",
    "href": "b0/problems/theatre-square.html",
    "title": "",
    "section": "",
    "text": "Theatre Square\n\nCodeforces\neasy\n\n\n\nمطلوب منا تغطية شبكة أبعادها \\(N \\times M\\) باستخدام بلاطات أبعادها \\(A \\times A\\). يُسمح للبلاطات بأن تتجاوز حدود الشبكة، ولكن يجب أن تغطيها بالكامل.\n\n\n\n\n\nSolution\n\nعند حساب عدد البلاطات اللازمة لتغطية البعد العمودي للشبكة، نجد أنه يساوي \\(\\lceil \\frac{N}{A} \\rceil\\)، وبالمثل، فإن عدد البلاطات اللازمة لتغطية البعد الأفقي يساوي \\(\\lceil \\frac{M}{A} \\rceil\\).\nوبالتالي، فإن العدد الإجمالي للبلاطات اللازمة لتغطية الشبكة كاملة هو: \\(\\lceil \\frac{N}{A} \\rceil \\times \\lceil \\frac{M}{A} \\rceil\\).\n\n\n\n\n\n\nTipالتقريب إلى الأعلى في القسمة الصحيحة\n\n\n\nيُرمز إليه بـ \\(\\lceil \\frac{A}{B} \\rceil\\)\nويُكتب في لغة ++C على النحو التالي: (A + B - 1) / B\n\n\n\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n, m, a;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a;\n\n    long long v = (n + a - 1) / a;\n    long long h = (m + a - 1) / a;\n\n    cout &lt;&lt; v * h;\n}\n\n\n\n\n\n\n\nCautionتجاوز السعة (Overflow)\n\n\n\nإذا كانت قيم \\(N, M = 10^9\\) و \\(A = 1\\)، فستكون النتيجة \\(N \\times M = 10^{18}\\). المتغير من نوع int سيتجاوز سعته، لذلك نحتاج إلى استخدام النوع long long.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Theatre Square"
    ]
  },
  {
    "objectID": "b0/problems/theatre-square.html#theatre-square",
    "href": "b0/problems/theatre-square.html#theatre-square",
    "title": "",
    "section": "",
    "text": "Theatre Square\n\nCodeforces\neasy\n\n\n\nمطلوب منا تغطية شبكة أبعادها \\(N \\times M\\) باستخدام بلاطات أبعادها \\(A \\times A\\). يُسمح للبلاطات بأن تتجاوز حدود الشبكة، ولكن يجب أن تغطيها بالكامل.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Theatre Square"
    ]
  },
  {
    "objectID": "b0/problems/your-digits.html",
    "href": "b0/problems/your-digits.html",
    "title": "",
    "section": "",
    "text": "Your Digits\n\nCodeforces\nmedium\n\n\n\nلديك \\(k_2\\) من الخانات 2، و \\(k_3\\) من الخانات 3، و \\(k_5\\) من الخانات 5، و \\(k_6\\) من الخانات 6. تريد تكوين الأعداد 32 و 256 باستخدام هذه الخانات (كل خانة مرة واحدة على الأكثر) لتعظيم مجموعها الكلي. جد أقصى مجموع ممكن.\n\n\n\n\n\nSolution\n\nنستطيع ملاحظة أنه من الأفضل تكوين العدد 256 قبل 32. لذا سنقوم بصنع 256 طالما لدينا خانات كافية، ثم باستخدام الخانات المتبقية نصنع 32.\nالعدد 256 يحتاج الخانات 2، 5، 6 مرة واحدة لكل منها، لذا يمكننا صنع أقصى عدد من هذه الأعداد يساوي \\(k = \\min(k_2, k_5, k_6)\\).\nباستخدام الخانات المتبقية، وهي \\(k_3\\) من الخانات 3 و \\(k_2 - k\\) من الخانات 2 (بعد استخدام \\(k\\) منها لصنع 256)، يمكننا تكوين \\(\\min(k_3, k_2-k)\\) من الأعداد 32.\n\n\n\n\n\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int k2, k3, k5, k6;\n    cin &gt;&gt; k2 &gt;&gt; k3 &gt;&gt; k5 &gt;&gt; k6;\n\n    int k = min(min(k2, k5), k6);\n\n    int solution = k * 256 + min(k3, k2 - k) * 32;\n    cout &lt;&lt; solution &lt;&lt; '\\n';\n}",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Your Digits"
    ]
  },
  {
    "objectID": "b0/problems/your-digits.html#your-digits",
    "href": "b0/problems/your-digits.html#your-digits",
    "title": "",
    "section": "",
    "text": "Your Digits\n\nCodeforces\nmedium\n\n\n\nلديك \\(k_2\\) من الخانات 2، و \\(k_3\\) من الخانات 3، و \\(k_5\\) من الخانات 5، و \\(k_6\\) من الخانات 6. تريد تكوين الأعداد 32 و 256 باستخدام هذه الخانات (كل خانة مرة واحدة على الأكثر) لتعظيم مجموعها الكلي. جد أقصى مجموع ممكن.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Your Digits"
    ]
  },
  {
    "objectID": "b0/problems/diverse-game.html",
    "href": "b0/problems/diverse-game.html",
    "title": "",
    "section": "",
    "text": "Diverse Game\n\nCodeforces\neasy\n\n\n\nيوجد \\(T\\) حالة اختبار. في كل حالة يُعطى لك مصفوفة \\(A\\) بحجم \\(N \\times M\\) تحتوي على جميع الأعداد الصحيحة من \\(1\\) إلى \\(N \\cdot M\\) مرة واحدة بالضبط. أنشئ مصفوفة \\(B\\) بنفس الحجم بحيث لكل خلية \\((i, j)\\)، يكون \\(A_{i,j} \\neq B_{i,j}\\).\nإذا كان ذلك مستحيلًا، اطبع \\(-1\\).\n\n\n\n\n\nSolution\n\nأولًا، نكتب حلقة تدور على جميع الحالات \\(T\\).\n\nint test_cases;\ncin &gt;&gt; test_cases;\n\nwhile(testcases--){\n    // حل كل حالة يكتب هنا\n}\n\nالحالة الوحيدة التي لا يوجد لها حل هي عندما \\(N = M = 1\\). ما عدا ذلك، نقول أن \\(B_{i,j} = A_{i,j} + 1\\)، وإذا كان \\(A_{i,j} = N \\cdot M\\)، عندها نضع \\(B_{i,j} = 1\\). هذا يضمن أن \\(B_{i,j} \\neq A_{i,j}\\) لجميع الخلايا.\n\nint n, m;\ncin &gt;&gt; n &gt;&gt; m;\n\nint a[n][m], b[n][m];\n\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; m; j++) {\n        cin &gt;&gt; a[i][j];\n\n        if (a[i][j] == n * m) b[i][j] = 1;\n        else b[i][j] = a[i][j] + 1;\n    }\n}\n\nأخيرًا، نحتاج إلى التحقق إذا كان \\(N = M = 1\\). اذا تحقق الشرط نطبع \\(-1\\) وذا لم يتحقق نطبع المصفوفة \\(B\\).\n\nif (n == 1 && m == 1) {\n    cout &lt;&lt; -1 &lt;&lt; \"\\n\";\n    continue; // للذهاب إلى الحالة القادم\n}\n// لا يتحقق n = m = 1  الآن نعرف ان الشرط \nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; m; j++) {\n        cout &lt;&lt; b[i][j] &lt;&lt; ' ';\n    }\n    cout &lt;&lt; endl;// يجعل كل صف يطبع في سطر مختلف\n}",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Diverse Game"
    ]
  },
  {
    "objectID": "b0/problems/diverse-game.html#diverse-game",
    "href": "b0/problems/diverse-game.html#diverse-game",
    "title": "",
    "section": "",
    "text": "Diverse Game\n\nCodeforces\neasy\n\n\n\nيوجد \\(T\\) حالة اختبار. في كل حالة يُعطى لك مصفوفة \\(A\\) بحجم \\(N \\times M\\) تحتوي على جميع الأعداد الصحيحة من \\(1\\) إلى \\(N \\cdot M\\) مرة واحدة بالضبط. أنشئ مصفوفة \\(B\\) بنفس الحجم بحيث لكل خلية \\((i, j)\\)، يكون \\(A_{i,j} \\neq B_{i,j}\\).\nإذا كان ذلك مستحيلًا، اطبع \\(-1\\).",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Diverse Game"
    ]
  },
  {
    "objectID": "b0/problems/holiday-of-equality.html",
    "href": "b0/problems/holiday-of-equality.html",
    "title": "",
    "section": "",
    "text": "Holiday of Equality\n\nCodeforces\neasy\n\n\n\nلدينا مصفوفة \\(A\\) تحتوي على \\(N\\) من الأعداد الصحيحة. يمكنك زيادة أي عنصر بمقدار \\(1\\) أي عدد من المرات. أوجد الحد الأدنى لإجمالي عدد الزيادات المطلوبة لجعل جميع العناصر متساوية.\n\n\n\n\n\nSolution\n\nلجعل جميع العناصر متساوية بأقل عدد ممكن من الزيادات، نحتاج إلى رفع كل العناصر إلى القيمة العظمى في المصفوفة. ولفعل ذلك، سنكتب دالة تحسب القيمة العظمى بين قيمتين.\n\nint max_function(int x, int y) {\n    if (x &gt; y) return x;\n    else return y;\n}\n\nبعد ذلك، سنحسب القيمة العظمى في المصفوفة \\(max(A_1, \\dots, A_n)\\) بالطريقة التالية.\n\nint n;\ncin &gt;&gt; n;\n\nint a[n];\nfor (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; a[i];\n}\n\nint max_value = a[0];\nfor (int i = 0; i &lt; n; i++) {\n    max_value = max_function(max_value, a[i]);\n}\n\nلكل عنصر \\(i\\)، كمية الزيادة المطلوبة هي \\(max(A_1, \\dots, A_n) - A_i\\).\nبجمع هذه القيم لجميع العناصر نحصل على الحد الأدنى لإجمالي عدد الزيادات المطلوبة.\n\nint coins = 0;\nfor (int i = 0; i &lt; n; i++) {\n    coins += max_value - a[i];\n}\n\ncout &lt;&lt; coins;",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Holiday of Equality"
    ]
  },
  {
    "objectID": "b0/problems/holiday-of-equality.html#holiday-of-equality",
    "href": "b0/problems/holiday-of-equality.html#holiday-of-equality",
    "title": "",
    "section": "",
    "text": "Holiday of Equality\n\nCodeforces\neasy\n\n\n\nلدينا مصفوفة \\(A\\) تحتوي على \\(N\\) من الأعداد الصحيحة. يمكنك زيادة أي عنصر بمقدار \\(1\\) أي عدد من المرات. أوجد الحد الأدنى لإجمالي عدد الزيادات المطلوبة لجعل جميع العناصر متساوية.",
    "crumbs": [
      "المرحلة 1",
      "المسائل",
      "Holiday of Equality"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html",
    "href": "b1/cpp/maps.html",
    "title": "الخرائط (Maps)",
    "section": "",
    "text": "map هو حاوية في C++ تقوم بتخزين أزواج من العناصر بهذا الشكل:\n\nkey -&gt; value\n\nوتقوم بترتيبها حسب المفتاح تلقائيًا.\nمثال:\n\n#include &lt;iostream&gt;\n#include &lt;map&gt;\nusing namespace std;\n\nint main() {\n    map&lt;string, int&gt; ages;\n\n    ages[\"Alice\"] = 25;\n    ages[\"Bob\"] = 30;\n    ages[\"Charlie\"] = 22;\n\n    for (auto p : ages)\n        cout &lt;&lt; p.first &lt;&lt; \": \" &lt;&lt; p.second &lt;&lt; endl;\n}\n\nالناتج:\n\nAlice: 25\nBob: 30\nCharlie: 22\n\nلاحظ أن الأسماء مطبوعة بالترتيب الأبجدي — لأن map يقوم بترتيب المفاتيح تلقائيًا.\n\n\nلاستخدام الخريطة، قم بتضمين:\n\n#include &lt;map&gt;\n\nثم يمكنك إعلانها هكذا:\n\nmap&lt;int, string&gt; students;     // المفتاح: int، القيمة: string\nmap&lt;string, double&gt; prices;    // المفتاح: string، القيمة: double\nmap&lt;char, int&gt; frequency;      // المفتاح: char، القيمة: int\n\n\n\n\n\nmap&lt;string, int&gt; scores;\n\nscores[\"Mark\"] = 90;          // الإضافة باستخدام [] \n\ncout &lt;&lt; scores[\"Mark\"];       // يطبع 90\n\nإذا حاولت الوصول لمفتاح غير موجود باستخدام []، سيتم إنشاؤه تلقائيًا بقيمة افتراضية (مثل 0).\n\ncout &lt;&lt; scores[\"Unknown\"];  // ينشئ \"Unknown\" بقيمة 0\n\nإذا كنت لا تريد هذا السلوك، استخدم count() للتحقق أولًا من وجود المفتاح.\n\nif (scores.count(\"Tom\"))\n    cout &lt;&lt; \"Tom found!\";\n\n\n\n\n\n\n\n\n\n\n\n\nالعملية\nالمثال\nالوصف\n\n\n\n\nm[key]\nm[\"Bob\"]\nالوصول إلى العنصر أو إنشاؤه\n\n\nerase(key)\nm.erase(\"Bob\")\nإزالة المفتاح والقيمة\n\n\ncount(key)\nif (m.count(\"Bob\"))\n1 إذا كان المفتاح موجود، 0 إذا لم يكن\n\n\nsize()\nm.size();\nإعادة عدد العناصر\n\n\nclear()\nm.clear();\nحذف جميع العناصر\n\n\nempty()\nm.empty();\nالتحقق مما إذا كانت الخريطة فارغة\n\n\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string text = \"apple banana apple orange banana apple\";\n    map&lt;string, int&gt; freq;\n\n    string word;\n    for (auto c : text) {\n        if (c == ' ') {\n            if (!word.empty()) freq[word]++;\n            word.clear();\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) freq[word]++; // آخر كلمة\n\n    for (auto p : freq)\n        cout &lt;&lt; p.first &lt;&lt; \": \" &lt;&lt; p.second &lt;&lt; endl;\n}\n\nالناتج:\n\napple: 3\nbanana: 2\norange: 1\n\n\n\n\nيمكنك التكرار باستخدام حلقة for بنطاق:\n\nfor (auto p : myMap)\n    cout &lt;&lt; p.first &lt;&lt; \" -&gt; \" &lt;&lt; p.second &lt;&lt; endl;\n\nأو باستخدام المؤشرات (iterators):\n\nfor (auto it = myMap.begin(); it != myMap.end(); it++)\n    cout &lt;&lt; it-&gt;first &lt;&lt; \": \" &lt;&lt; it-&gt;second &lt;&lt; endl;\n\nfirst = المفتاح، second = القيمة.\n\n\n\n\n\n\n\n\n\n\n\n\n\nالنوع\nيحافظ على الترتيب؟\nيسمح بالمفاتيح المكررة؟\nالسرعة (متوسط)\nملاحظات\n\n\n\n\nmap\nنعم\nلا\nO(log n)\nيخزن المفاتيح مرتبة (شجرة متوازنة)\n\n\nunordered_map\nلا\nلا\nO(1) متوسط\nسريع، لكن الترتيب عشوائي\n\n\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nint main() {\n    unordered_map&lt;string, int&gt; age;\n\n    age[\"Bob\"] = 30;\n    age[\"Alice\"] = 25;\n    age[\"Tom\"] = 28;\n\n    for (auto p : age)\n        cout &lt;&lt; p.first &lt;&lt; \": \" &lt;&lt; p.second &lt;&lt; endl;\n}\n\nالناتج:\n\n(الترتيب قد يكون عشوائي)\nBob: 30\nTom: 28\nAlice: 25\n\nلذلك unordered_map عادة أسرع، لكنه لا يقوم بترتيب المفاتيح.",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "الخرائط (Maps)"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#إنشاء-خريطة-creating-a-map",
    "href": "b1/cpp/maps.html#إنشاء-خريطة-creating-a-map",
    "title": "الخرائط (Maps)",
    "section": "",
    "text": "لاستخدام الخريطة، قم بتضمين:\n\n#include &lt;map&gt;\n\nثم يمكنك إعلانها هكذا:\n\nmap&lt;int, string&gt; students;     // المفتاح: int، القيمة: string\nmap&lt;string, double&gt; prices;    // المفتاح: string، القيمة: double\nmap&lt;char, int&gt; frequency;      // المفتاح: char، القيمة: int",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "الخرائط (Maps)"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#إضافة-والوصول-للعناصر",
    "href": "b1/cpp/maps.html#إضافة-والوصول-للعناصر",
    "title": "الخرائط (Maps)",
    "section": "",
    "text": "map&lt;string, int&gt; scores;\n\nscores[\"Mark\"] = 90;          // الإضافة باستخدام [] \n\ncout &lt;&lt; scores[\"Mark\"];       // يطبع 90\n\nإذا حاولت الوصول لمفتاح غير موجود باستخدام []، سيتم إنشاؤه تلقائيًا بقيمة افتراضية (مثل 0).\n\ncout &lt;&lt; scores[\"Unknown\"];  // ينشئ \"Unknown\" بقيمة 0\n\nإذا كنت لا تريد هذا السلوك، استخدم count() للتحقق أولًا من وجود المفتاح.\n\nif (scores.count(\"Tom\"))\n    cout &lt;&lt; \"Tom found!\";",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "الخرائط (Maps)"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#العمليات-الشائعة",
    "href": "b1/cpp/maps.html#العمليات-الشائعة",
    "title": "الخرائط (Maps)",
    "section": "",
    "text": "العملية\nالمثال\nالوصف\n\n\n\n\nm[key]\nm[\"Bob\"]\nالوصول إلى العنصر أو إنشاؤه\n\n\nerase(key)\nm.erase(\"Bob\")\nإزالة المفتاح والقيمة\n\n\ncount(key)\nif (m.count(\"Bob\"))\n1 إذا كان المفتاح موجود، 0 إذا لم يكن\n\n\nsize()\nm.size();\nإعادة عدد العناصر\n\n\nclear()\nm.clear();\nحذف جميع العناصر\n\n\nempty()\nm.empty();\nالتحقق مما إذا كانت الخريطة فارغة",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "الخرائط (Maps)"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#مثال-عد-تكرار-الكلمات",
    "href": "b1/cpp/maps.html#مثال-عد-تكرار-الكلمات",
    "title": "الخرائط (Maps)",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string text = \"apple banana apple orange banana apple\";\n    map&lt;string, int&gt; freq;\n\n    string word;\n    for (auto c : text) {\n        if (c == ' ') {\n            if (!word.empty()) freq[word]++;\n            word.clear();\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) freq[word]++; // آخر كلمة\n\n    for (auto p : freq)\n        cout &lt;&lt; p.first &lt;&lt; \": \" &lt;&lt; p.second &lt;&lt; endl;\n}\n\nالناتج:\n\napple: 3\nbanana: 2\norange: 1",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "الخرائط (Maps)"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#التكرار-عبر-الخريطة",
    "href": "b1/cpp/maps.html#التكرار-عبر-الخريطة",
    "title": "الخرائط (Maps)",
    "section": "",
    "text": "يمكنك التكرار باستخدام حلقة for بنطاق:\n\nfor (auto p : myMap)\n    cout &lt;&lt; p.first &lt;&lt; \" -&gt; \" &lt;&lt; p.second &lt;&lt; endl;\n\nأو باستخدام المؤشرات (iterators):\n\nfor (auto it = myMap.begin(); it != myMap.end(); it++)\n    cout &lt;&lt; it-&gt;first &lt;&lt; \": \" &lt;&lt; it-&gt;second &lt;&lt; endl;\n\nfirst = المفتاح، second = القيمة.",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "الخرائط (Maps)"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#أنواع-الخرائط",
    "href": "b1/cpp/maps.html#أنواع-الخرائط",
    "title": "الخرائط (Maps)",
    "section": "",
    "text": "النوع\nيحافظ على الترتيب؟\nيسمح بالمفاتيح المكررة؟\nالسرعة (متوسط)\nملاحظات\n\n\n\n\nmap\nنعم\nلا\nO(log n)\nيخزن المفاتيح مرتبة (شجرة متوازنة)\n\n\nunordered_map\nلا\nلا\nO(1) متوسط\nسريع، لكن الترتيب عشوائي",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "الخرائط (Maps)"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#مثال-unordered_map",
    "href": "b1/cpp/maps.html#مثال-unordered_map",
    "title": "الخرائط (Maps)",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nint main() {\n    unordered_map&lt;string, int&gt; age;\n\n    age[\"Bob\"] = 30;\n    age[\"Alice\"] = 25;\n    age[\"Tom\"] = 28;\n\n    for (auto p : age)\n        cout &lt;&lt; p.first &lt;&lt; \": \" &lt;&lt; p.second &lt;&lt; endl;\n}\n\nالناتج:\n\n(الترتيب قد يكون عشوائي)\nBob: 30\nTom: 28\nAlice: 25\n\nلذلك unordered_map عادة أسرع، لكنه لا يقوم بترتيب المفاتيح.",
    "crumbs": [
      "المرحلة 2",
      "C++",
      "الخرائط (Maps)"
    ]
  },
  {
    "objectID": "b1/greedy.html",
    "href": "b1/greedy.html",
    "title": "الخوارزميات الجشعة (Greedy Algorithms)",
    "section": "",
    "text": "الخوارزمية الجشعة تبني الحل خطوة بخطوة، وفي كل خطوة تختار أفضل خيار متاح الآن بدون التفكير في العواقب المستقبلية.\nتخيل أنك دائمًا تأخذ أكبر بسكوتة أولًا — على أمل أن يقودك ذلك لأفضل نتيجة ممكنة.\n\n\nكلمة “Greedy” تعني محليًا أمثل — أي أنك في كل خطوة تختار القرار الذي يبدو الأفضل في اللحظة الحالية.\nأحيانًا هذا يصل إلى الحل الأمثل (أفضل حل ممكن)، وأحيانًا يفشل. السر هو معرفة متى تعمل الاستراتيجية الجشعة ومتى لا تعمل.\n\n\n\n\nلديك هدف (مثل تقليل التكلفة أو زيادة القيمة).\nفي كل خطوة تأخذ الخيار الذي يبدو الأفضل الآن.\nتستمر حتى تُكمل الحل.\n\nلا تعود لتعديل قراراتك السابقة أبدًا.\nالنمط العام:\n\nwhile (المشكلة لم تُحل) {\n    اختر أفضل خيار في الوقت الحالي;\n    حدّث حالة المشكلة;\n}\n\n\n\n\n\n\n\n\n\nCoin change\n\n\n\n\n\nمعك عملات: 1، 5، 10، 25 أوجد أقل عدد عملات لصنع المبلغ 63.\n\n\n\n\n\nSolution\n\nالفكرة الجشعة: اخذ أكبر عملة ممكنة دائمًا.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int amount = 63;\n    vector&lt;int&gt; coins = {25, 10, 5, 1};\n    int count = 0;\n\n    for (int c : coins) {\n        count += amount / c;\n        amount %= c;\n    }\n    cout &lt;&lt; count; // 6 coins\n}\n\nالاختيارات: 25 + 25 + 10 + 1 + 1 + 1 = 63 النتيجة = 6 عملات.\nهذه الطريقة تعمل في أغلب أنظمة العملات الحقيقية.\n\n\n\n\n\n\n\nActivity selection\n\n\n\n\n\nمعك مجموعة نشاطات، كل نشاط له وقت بداية ونهاية، ولا يمكنك القيام إلا بنشاط واحد في نفس الوقت. ما هو أكبر عدد نشاطات يمكنك إنهاؤها؟\n\n\n\n\n\nSolution\n\nالفكرة الجشعة: اختر النشاط الذي ينتهي أولًا.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;pair&lt;int, int&gt;&gt; act = {{1, 3}, {2, 5}, {4, 6}, {6, 8}, {5, 7}};\n    sort(act.begin(), act.end(), [](auto &a, auto &b){ return a.second &lt; b.second; });\n\n    int count = 0, end = 0;\n    for (auto &p : act) {\n        if (p.first &gt;= end) {\n            count++;\n            end = p.second;\n        }\n    }\n    cout &lt;&lt; count; // 3\n}\n\nنختار دائمًا النشاط الذي ينتهي مبكرًا — لأنه يترك مساحة للأنشطة الأخرى.\n\n\n\n\n\nتنجح عندما يكون الاختيار المحلي الأفضل يقود دائمًا إلى الحل الأفضل عالميًا.\nهذا يحدث عندما تمتلك المشكلة:\n\nخاصية الاختيار الجشع\nخاصية البنية المثلى (optimal substructure)\n\nلا تحتاج لحفظ هذه المصطلحات — فقط اختبر إذا كانت الجشع يعمل في كل الحالات.\n\n\n\nنظام العملات (1، 2، 5) → الأكبر أولًا يعطي دائمًا العدد الأدنى.\nجدولة المهام القصيرة أولًا — يسمح بإنهاء أكبر عدد منها.\nاختيار أكبر القيم عندما توجد حدود معينة.\n\n\n\n\n\nالعملات {1، 3، 4} والمبلغ 6:\n\nالجشع: 4 + 1 + 1 = 3 عملات\nالأفضل: 3 + 3 = 2 عملات → الجشع يفشل هنا\n\nترتيب العناصر الكبيرة أولًا عند محاولة تعبئة حقيبة — قد يمنع حلولًا أفضل.\n\n\n\n\n\n\nقم بترتيب شيء (حسب القيمة، الوقت، النسبة، …).\nمرّ على العناصر بالترتيب.\nاختر أفضل اختيار صالح في كل مرة.\nحدّث الحالة (الوقت المتبقي، السعة المتبقية، …).\n\nنمط شائع:\n\nsort(items.begin(), items.end(), rule);\nfor (auto &item : items) {\n    if (can_take(item)) take(item);\n}\n\n\n\n\n\nسريعة جدًا وبسيطة\nغالبًا \\(O(n log n)\\) أو أفضل\nسهلة الفهم\nمناسبة لمشاكل الجدولة والاختيار\n\n\n\n\n\nلا تعطي دائمًا الحل الأمثل\nالقرارات المبكرة قد تدمّر الحل لاحقًا\nيجب اختبارها أو إثباتها بعناية\n\n\n\n\n\nدائمًا اسأل: هل هذا الاختيار قد يمنع حلولًا أفضل لاحقًا؟\nجرّب بناء أمثلة مضادة.\nكثير من مسائل الجشع تعتمد على فرز + اختيار.\n\n\n\n\n\nالجشع = اختيار أفضل قرار محلي في كل خطوة\nيعمل فقط عندما تضمن هذه القرارات الحل الأمثل\nشائع في الجدولة، الرسوم البيانية، توزيع الموارد\nبسيط وسريع في التنفيذ والبرمجة",
    "crumbs": [
      "المرحلة 2",
      "الخوارزميات الجشعة (Greedy Algorithms)"
    ]
  },
  {
    "objectID": "b1/greedy.html#ماذا-يعني-greedy",
    "href": "b1/greedy.html#ماذا-يعني-greedy",
    "title": "الخوارزميات الجشعة (Greedy Algorithms)",
    "section": "",
    "text": "كلمة “Greedy” تعني محليًا أمثل — أي أنك في كل خطوة تختار القرار الذي يبدو الأفضل في اللحظة الحالية.\nأحيانًا هذا يصل إلى الحل الأمثل (أفضل حل ممكن)، وأحيانًا يفشل. السر هو معرفة متى تعمل الاستراتيجية الجشعة ومتى لا تعمل.",
    "crumbs": [
      "المرحلة 2",
      "الخوارزميات الجشعة (Greedy Algorithms)"
    ]
  },
  {
    "objectID": "b1/greedy.html#الفكرة-العامة",
    "href": "b1/greedy.html#الفكرة-العامة",
    "title": "الخوارزميات الجشعة (Greedy Algorithms)",
    "section": "",
    "text": "لديك هدف (مثل تقليل التكلفة أو زيادة القيمة).\nفي كل خطوة تأخذ الخيار الذي يبدو الأفضل الآن.\nتستمر حتى تُكمل الحل.\n\nلا تعود لتعديل قراراتك السابقة أبدًا.\nالنمط العام:\n\nwhile (المشكلة لم تُحل) {\n    اختر أفضل خيار في الوقت الحالي;\n    حدّث حالة المشكلة;\n}",
    "crumbs": [
      "المرحلة 2",
      "الخوارزميات الجشعة (Greedy Algorithms)"
    ]
  },
  {
    "objectID": "b1/greedy.html#coin-change",
    "href": "b1/greedy.html#coin-change",
    "title": "الخوارزميات الجشعة (Greedy Algorithms)",
    "section": "",
    "text": "Coin change\n\n\n\n\n\nمعك عملات: 1، 5، 10، 25 أوجد أقل عدد عملات لصنع المبلغ 63.",
    "crumbs": [
      "المرحلة 2",
      "الخوارزميات الجشعة (Greedy Algorithms)"
    ]
  },
  {
    "objectID": "b1/greedy.html#activity-selection",
    "href": "b1/greedy.html#activity-selection",
    "title": "الخوارزميات الجشعة (Greedy Algorithms)",
    "section": "",
    "text": "Activity selection\n\n\n\n\n\nمعك مجموعة نشاطات، كل نشاط له وقت بداية ونهاية، ولا يمكنك القيام إلا بنشاط واحد في نفس الوقت. ما هو أكبر عدد نشاطات يمكنك إنهاؤها؟",
    "crumbs": [
      "المرحلة 2",
      "الخوارزميات الجشعة (Greedy Algorithms)"
    ]
  },
  {
    "objectID": "b1/greedy.html#متى-تنجح-الخوارزميات-الجشعة",
    "href": "b1/greedy.html#متى-تنجح-الخوارزميات-الجشعة",
    "title": "الخوارزميات الجشعة (Greedy Algorithms)",
    "section": "",
    "text": "تنجح عندما يكون الاختيار المحلي الأفضل يقود دائمًا إلى الحل الأفضل عالميًا.\nهذا يحدث عندما تمتلك المشكلة:\n\nخاصية الاختيار الجشع\nخاصية البنية المثلى (optimal substructure)\n\nلا تحتاج لحفظ هذه المصطلحات — فقط اختبر إذا كانت الجشع يعمل في كل الحالات.\n\n\n\nنظام العملات (1، 2، 5) → الأكبر أولًا يعطي دائمًا العدد الأدنى.\nجدولة المهام القصيرة أولًا — يسمح بإنهاء أكبر عدد منها.\nاختيار أكبر القيم عندما توجد حدود معينة.\n\n\n\n\n\nالعملات {1، 3، 4} والمبلغ 6:\n\nالجشع: 4 + 1 + 1 = 3 عملات\nالأفضل: 3 + 3 = 2 عملات → الجشع يفشل هنا\n\nترتيب العناصر الكبيرة أولًا عند محاولة تعبئة حقيبة — قد يمنع حلولًا أفضل.",
    "crumbs": [
      "المرحلة 2",
      "الخوارزميات الجشعة (Greedy Algorithms)"
    ]
  },
  {
    "objectID": "b1/greedy.html#خطوات-تصميم-خوارزمية-جشعة",
    "href": "b1/greedy.html#خطوات-تصميم-خوارزمية-جشعة",
    "title": "الخوارزميات الجشعة (Greedy Algorithms)",
    "section": "",
    "text": "قم بترتيب شيء (حسب القيمة، الوقت، النسبة، …).\nمرّ على العناصر بالترتيب.\nاختر أفضل اختيار صالح في كل مرة.\nحدّث الحالة (الوقت المتبقي، السعة المتبقية، …).\n\nنمط شائع:\n\nsort(items.begin(), items.end(), rule);\nfor (auto &item : items) {\n    if (can_take(item)) take(item);\n}",
    "crumbs": [
      "المرحلة 2",
      "الخوارزميات الجشعة (Greedy Algorithms)"
    ]
  },
  {
    "objectID": "b1/greedy.html#المميزات",
    "href": "b1/greedy.html#المميزات",
    "title": "الخوارزميات الجشعة (Greedy Algorithms)",
    "section": "",
    "text": "سريعة جدًا وبسيطة\nغالبًا \\(O(n log n)\\) أو أفضل\nسهلة الفهم\nمناسبة لمشاكل الجدولة والاختيار",
    "crumbs": [
      "المرحلة 2",
      "الخوارزميات الجشعة (Greedy Algorithms)"
    ]
  },
  {
    "objectID": "b1/greedy.html#العيوب",
    "href": "b1/greedy.html#العيوب",
    "title": "الخوارزميات الجشعة (Greedy Algorithms)",
    "section": "",
    "text": "لا تعطي دائمًا الحل الأمثل\nالقرارات المبكرة قد تدمّر الحل لاحقًا\nيجب اختبارها أو إثباتها بعناية",
    "crumbs": [
      "المرحلة 2",
      "الخوارزميات الجشعة (Greedy Algorithms)"
    ]
  },
  {
    "objectID": "b1/greedy.html#نصائح",
    "href": "b1/greedy.html#نصائح",
    "title": "الخوارزميات الجشعة (Greedy Algorithms)",
    "section": "",
    "text": "دائمًا اسأل: هل هذا الاختيار قد يمنع حلولًا أفضل لاحقًا؟\nجرّب بناء أمثلة مضادة.\nكثير من مسائل الجشع تعتمد على فرز + اختيار.",
    "crumbs": [
      "المرحلة 2",
      "الخوارزميات الجشعة (Greedy Algorithms)"
    ]
  },
  {
    "objectID": "b1/greedy.html#خلاصة-سريعة",
    "href": "b1/greedy.html#خلاصة-سريعة",
    "title": "الخوارزميات الجشعة (Greedy Algorithms)",
    "section": "",
    "text": "الجشع = اختيار أفضل قرار محلي في كل خطوة\nيعمل فقط عندما تضمن هذه القرارات الحل الأمثل\nشائع في الجدولة، الرسوم البيانية، توزيع الموارد\nبسيط وسريع في التنفيذ والبرمجة",
    "crumbs": [
      "المرحلة 2",
      "الخوارزميات الجشعة (Greedy Algorithms)"
    ]
  },
  {
    "objectID": "b1/problems/digit-queries.html",
    "href": "b1/problems/digit-queries.html",
    "title": "",
    "section": "",
    "text": "Digit Queries\n\nCSES\nmedium\n\n\n\nاعتبر السلسلة اللانهائية الناتجة عن لصق جميع الأعداد الصحيحة الموجبة بالترتيب:\n[ 1234567891011121314]\nلدينا \\(q\\) استعلامات. في كل استعلام، يُعطى لك موقع \\(k\\) (مرقّم بداية من 1) داخل هذه السلسلة اللانهائية. مهمتك هي طباعة الخانة (digit) الموجودة في الموقع \\(k\\).\nالقيود:\n\n\\(1 \\le q \\le 1000\\)\n\\(1 \\le k \\le 10^{18}\\)\n\n\n\n\n\n\nSolution\n\nلا يمكننا بناء السلسلة اللانهائية فعليًا (ولا حتى بادئة بطول \\(10^{18}\\)). بدلًا من ذلك، نفكّر في كتل من الأعداد ذات نفس عدد الخانات.\n\n\n\nالأعداد ذات الخانة الواحدة: من 1 إلى 9\n\nعدد الأعداد: \\(9\\)\nعدد الخانات الكلي: \\(9 \\cdot 1\\)\n\nالأعداد ذات الخانتين: من 10 إلى 99\n\nالعدد: \\(90\\)\nالخانات: \\(90 \\cdot 2 = 180\\)\n\nالأعداد ذات الثلاث خانات: من 100 إلى 999\n\nالعدد: \\(900\\)\nالخانات: \\(900 \\cdot 3 = 2700\\)\n\n\nبشكل عام، للأعداد ذات \\(d\\) خانات:\n\nأول عدد له \\(d\\) خانات هو \\(10^{d-1}\\)\nيوجد \\(9 \\cdot 10^{d-1}\\) عددًا كهذا\nتساهم هذه الكتلة بعدد إجمالي من الخانات يساوي \\(9 \\cdot d \\cdot 10^{d-1}\\)\n\nلأي موضع \\(k\\):\n\nنبدأ بعدد خانات \\(d = 1\\) وبـ base = 1 (وهي \\(10^{d-1}\\)).\nنحسب block_len = 9 * base * d وهو عدد الخانات الكلي في كتلة الأعداد ذات \\(d\\) خانات.\nإذا كان k &gt; block_len، فهذا يعني أن الموضع ليس في هذه الكتلة، فنطرح حجمها وننتقل للكتلة التالية:\n\nk -= block_len\nنزيد d++، ونضرب base *= 10 (ننتقل إلى أعداد ذات d+1 خانات)\n\nنتوقف عندما يصبح k &lt;= block_len، أي أن الموضع داخل الكتلة الحالية.\n\nالآن نعلم أن:\n\nالخانة المطلوبة تقع ضمن كتلة الأعداد ذات \\(d\\) خانات،\nبداية هذه الكتلة هي start = base = 10^{d-1}.\n\n\n\n\nداخل كتلة الأعداد ذات \\(d\\) خانات:\n\nنستخدم ترقيمًا يبدأ من الصفر داخل الكتلة:\n\nk0 = k - 1 (موضع 0-based داخل الكتلة)\nindex_of_number = k0 / d (أي عدد داخل الكتلة)\nindex_in_number = k0 % d (أي خانة داخل هذا العدد)\n\nالعدد الفعلي هو:\n\nnum = start + index_of_number\n\nلاستخراج الخانة المطلوبة:\n\nنحوّل num إلى نص ونأخذ الحرف رقم index_in_number، أو\nنستخدم عمليات القسمة والباقي لاستخراج الخانة.\n\n\nضمن القيود المعطاة، استخدام تحويل num إلى سلسلة نصية في ++C مقبول تمامًا.\n\n\n\n\nلكل استعلام:\n\nقيمة d لن تتجاوز تقريبًا 17 (لأن \\(k \\le 10^{18}\\))، لذا حلقة البحث عن الكتلة تعمل في زمن ثابت تقريبًا.\nكل العمليات على نوع long long وسلاسل نصية قصيرة.\n\nإجمالي التعقيد: \\(O(q)\\).\n\n\n\n\n\n\nNoteمنطق كتل الخانات (لكل استعلام)\n\n\n\n\nنجد \\(d\\) بحيث يقع \\(k\\) ضمن كتلة الأعداد ذات \\(d\\) خانات:\n\nنكرر:\n\nblock_len = 9 * base * d\nإذا كان k &gt; block_len:\n\nk -= block_len\nd++\nbase *= 10\n\n\n\nثم نحسب:\n\nk0 = k - 1\nindex_of_number = k0 / d\nindex_in_number = k0 % d\nnum = base + index_of_number\nالجواب = الخانة رقم index_in_number من العدد num.\n\n\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int q;\n    cin &gt;&gt; q;\n\n    while (q--) {\n        long long k;\n        cin &gt;&gt; k;\n\n        long long d = 1;       // current digit length\n        long long base = 1;    // 10^(d-1)\n\n        // Step 1: find the block (digit length d) that contains position k\n        while (true) {\n            long long count_numbers = 9 * base;      // how many d-digit numbers\n            long long block_len = count_numbers * d; // total digits in this block\n\n            if (k &gt; block_len) {\n                k -= block_len;\n                d++;\n                base *= 10;\n            } else {\n                break; // k is inside this block\n            }\n        }\n\n        // Step 2: find the exact number and digit within this d-digit block\n        long long k0 = k - 1;                 // 0-based index within this block\n        long long index_of_number = k0 / d;   // which number in this block\n        long long index_in_number = k0 % d;   // which digit inside that number\n\n        long long num = base + index_of_number;\n\n        // Convert number to string and pick the right digit\n        string s = to_string(num);\n        char answer_digit = s[index_in_number];\n\n        cout &lt;&lt; answer_digit &lt;&lt; endl;\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nCautionحذر من تجاوز السعة\n\n\n\n\nاستخدم نوع long long لكل من k وbase وblock_len.\nفي هذه المسألة، لا نحتاج أن يتجاوز d القيمة 17 عندما \\(k \\le 10^{18}\\)، لذا فإن القيمة 9 * base * d تبقى ضمن حدود نوع long long.",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Digit Queries"
    ]
  },
  {
    "objectID": "b1/problems/digit-queries.html#digit-queries",
    "href": "b1/problems/digit-queries.html#digit-queries",
    "title": "",
    "section": "",
    "text": "Digit Queries\n\nCSES\nmedium\n\n\n\nاعتبر السلسلة اللانهائية الناتجة عن لصق جميع الأعداد الصحيحة الموجبة بالترتيب:\n[ 1234567891011121314]\nلدينا \\(q\\) استعلامات. في كل استعلام، يُعطى لك موقع \\(k\\) (مرقّم بداية من 1) داخل هذه السلسلة اللانهائية. مهمتك هي طباعة الخانة (digit) الموجودة في الموقع \\(k\\).\nالقيود:\n\n\\(1 \\le q \\le 1000\\)\n\\(1 \\le k \\le 10^{18}\\)",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Digit Queries"
    ]
  },
  {
    "objectID": "b1/problems/sum-of-three-values.html",
    "href": "b1/problems/sum-of-three-values.html",
    "title": "",
    "section": "",
    "text": "Sum of Three Values\n\nCSES\nmedium\n\n\n\nيُعطى لك مصفوفة من \\(n\\) أعداد صحيحة، ومهمتك هي إيجاد ثلاث قيم في مواقع مختلفة يكون مجموعها \\(x\\).\nالإدخال:\n\nالسطر الأول: عددان صحيحان \\(n\\) و \\(x\\) — حجم المصفوفة والمجموع المطلوب.\nالسطر الثاني: \\(n\\) عددًا \\(a_1,a_2,\\dots,a_n\\) — قيم المصفوفة.\n\nالمخرجات:\nاطبع ثلاثة أعداد صحيحة: مواقع القيم المختارة (مرقّمة من 1). إذا كان هناك أكثر من ثلاثية صالحة، يمكنك طباعة أي منها. إذا لم توجد أي ثلاثية تحقق الشرط، فاطبع\nIMPOSSIBLE\nالقيود:\n\n\\(1 \\le n \\le 5000\\)\n\\(1 \\le x, a_i \\le 10^9\\)\n\nمثال:\nالإدخال:\n4 8\n2 7 5 1\nالمخرجات:\n1 3 4\n\n\n\n\n\nSolution\n\nنريد إيجاد ثلاثة مؤشرات مختلفة \\(i, j, k\\) بحيث a_i + a_j + a_k = x.\nالحل العنيف بالكامل يفحص جميع الثلاثيات في زمن \\(O(n^3)\\)، وهذا أبطأ من اللازم عندما يكون \\(n = 5000\\).\nبدلًا من ذلك نستخدم الفكرة الكلاسيكية:\n\nنُثبّت عنصرين ونبحث عن الثالث باستخدام البحث الثنائي.\n\n\n\n\nأولًا نخزن كل عنصر مع موقعه الأصلي، ثم نفرز حسب القيمة:\n\nنبني مصفوفة أزواج: \\((a_i, i)\\).\nنفرز حسب \\(a_i\\).\n\nبهذا يمكننا استخدام البحث الثنائي على القيم، مع القدرة على استرجاع المواقع الأصلية عند الطباعة.\n\n\n\n\nبعد الفرز:\n\nنكرّر على جميع الأزواج \\((i, j)\\) بحيث \\(0 \\le i &lt; j &lt; n\\):\n\nنحسب need = x - a_i - a_j.\nنريد الآن أن نرى هل يوجد \\(k &gt; j\\) بحيث \\(a_k = \\text{need}\\).\nبما أن المصفوفة مرتّبة، يمكننا استخدام البحث الثنائي عن need في المجال [j+1, n-1].\n\n\nإذا وجدنا مثل هذا k:\n\nنطبع المواقع الأصلية لـ \\(a_i, a_j, a_k\\).\n\nإذا أنهينا كل الأزواج بدون نجاح، نطبع IMPOSSIBLE.\nبما أننا نبحث دائمًا فقط في مواقع أكبر من j، فإن المواقع الثلاثة ستكون مختلفة تلقائيًا.\n\n\n\n\n\nالفرز: \\(O(n \\log n)\\)\nالحلقة المزدوجة على \\((i, j)\\): عددها \\(O(n^2)\\)\nلكل زوج، بحث ثنائي واحد: \\(O(\\log n)\\)\n\nإذًا الزمن الكلي:\nO(n^2 log n)\nوهو مناسب تمامًا لـ \\(n \\le 5000\\). استخدام الذاكرة هو \\(O(n)\\) لتخزين مصفوفة الأزواج.\n\n\n\n\n\n\nNoteملاحظة: مخطط الخوارزمية\n\n\n\n\nنقرأ \\(n\\)، \\(x\\)، والمصفوفة.\nنبني vector&lt;(value, original_index)&gt; ونفرزه حسب القيمة.\nلكل i من 0 حتى n-1:\n\nولكل j من i+1 حتى n-1:\n\nنحسب need = x - value[i] - value[j].\nنبحث ثنائيًا عن need في المجال [j+1, n-1].\nإذا وجدناه عند k، نطبع المؤشرات الأصلية الثلاثة وننهي البرنامج.\n\n\nإذا لم نجد أي ثلاثية، نطبع IMPOSSIBLE.\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    long long x;\n    cin &gt;&gt; n &gt;&gt; x;\n\n    vector&lt;pair&lt;long long,int&gt;&gt; a(n);\n    for (int i = 0; i &lt; n; ++i) {\n        long long v;\n        cin &gt;&gt; v;\n        a[i] = {v, i + 1}; // store value and original 1-based index\n    }\n\n    sort(a.begin(), a.end()); // sort by value\n\n    // Fix two indices (i, j) and binary search for the third\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = i + 1; j &lt; n; ++j) {\n            long long need = x - a[i].first - a[j].first;\n\n            int lo = j + 1, hi = n - 1;\n            while (lo &lt;= hi) {\n                int mid = (lo + hi) / 2;\n                if (a[mid].first == need) {\n                    // Found a valid triple\n                    cout &lt;&lt; a[i].second &lt;&lt; \" \"\n                         &lt;&lt; a[j].second &lt;&lt; \" \"\n                         &lt;&lt; a[mid].second &lt;&lt; \"\\n\";\n                    return 0;\n                } else if (a[mid].first &lt; need) {\n                    lo = mid + 1;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n        }\n    }\n\n    cout &lt;&lt; \"IMPOSSIBLE\\n\";\n    return 0;\n}\n\n\n\n\n\n\n\n\nCautionحذر: نوع المتغيّرات\n\n\n\n\nاستخدم long long للقيم ولـ x، لأن \\(x\\) و \\(a_i\\) قد يصلان إلى \\(10^9\\)، والمجموع قد يصل إلى \\(3 \\cdot 10^9\\).\nتأكّد دائمًا من أن البحث يكون في المجال [j+1, n-1] لضمان أن المواقع الثلاثة مختلفة.",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Sum Of Three Values"
    ]
  },
  {
    "objectID": "b1/problems/sum-of-three-values.html#sum-of-three-values",
    "href": "b1/problems/sum-of-three-values.html#sum-of-three-values",
    "title": "",
    "section": "",
    "text": "Sum of Three Values\n\nCSES\nmedium\n\n\n\nيُعطى لك مصفوفة من \\(n\\) أعداد صحيحة، ومهمتك هي إيجاد ثلاث قيم في مواقع مختلفة يكون مجموعها \\(x\\).\nالإدخال:\n\nالسطر الأول: عددان صحيحان \\(n\\) و \\(x\\) — حجم المصفوفة والمجموع المطلوب.\nالسطر الثاني: \\(n\\) عددًا \\(a_1,a_2,\\dots,a_n\\) — قيم المصفوفة.\n\nالمخرجات:\nاطبع ثلاثة أعداد صحيحة: مواقع القيم المختارة (مرقّمة من 1). إذا كان هناك أكثر من ثلاثية صالحة، يمكنك طباعة أي منها. إذا لم توجد أي ثلاثية تحقق الشرط، فاطبع\nIMPOSSIBLE\nالقيود:\n\n\\(1 \\le n \\le 5000\\)\n\\(1 \\le x, a_i \\le 10^9\\)\n\nمثال:\nالإدخال:\n4 8\n2 7 5 1\nالمخرجات:\n1 3 4",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Sum Of Three Values"
    ]
  },
  {
    "objectID": "b1/problems/twins.html",
    "href": "b1/problems/twins.html",
    "title": "",
    "section": "",
    "text": "Twins\n\nCodeforces\neasy\n\n\n\nلديك مصفوفة \\(A\\) تحتوي على \\(N\\) أعداد صحيحة، حدد أقل عدد من العناصر التي يجب اختيارها من \\(A\\) بحيث يكون مجموع العناصر المختارة أكبر من مجموعة العناصر المتبقية.\n\n\n\n\n\nSolution\n\nأولاً، احسب مجموع المصفوفة، والذي سنسميه total_sum.\nبما أننا نريد اختيار الحد الأدنى من العناصر، نريد أخذ أكبر العناصر أولاً. للقيام بذلك، نقوم بترتيب المصفوفة بترتيب تصاعدي نقوم بالمرور عليها بشكل عكسي (من n - 1 إلى 0) مع الحفاظ على قيمتين:\n\nselected_sum — مجموع العناصر التي اخترناها حتى الآن\n\ncnt — عدد العناصر المختارة\n\nفي كل خطوة، نتحقق مما إذا كان selected_sum &gt; total_sum - selected_sum. إذا تحقق الشرط، نطبع cnt ونتوقف عن البرنامج.\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int a[n];\n    int total_sum = 0;\n\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; a[i];\n        total_sum += a[i];\n    }\n\n    sort(a, a + n);\n\n    int selected_sum = 0;\n    int cnt = 0;\n\n    for (int i = n - 1; i &gt;= 0; i--) {\n        selected_sum += a[i];\n        cnt++;\n\n        if (selected_sum &gt; total_sum - selected_sum) {\n            cout &lt;&lt; cnt &lt;&lt; endl;\n            break;\n        }\n    }\n}",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Twins"
    ]
  },
  {
    "objectID": "b1/problems/twins.html#twins",
    "href": "b1/problems/twins.html#twins",
    "title": "",
    "section": "",
    "text": "Twins\n\nCodeforces\neasy\n\n\n\nلديك مصفوفة \\(A\\) تحتوي على \\(N\\) أعداد صحيحة، حدد أقل عدد من العناصر التي يجب اختيارها من \\(A\\) بحيث يكون مجموع العناصر المختارة أكبر من مجموعة العناصر المتبقية.",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Twins"
    ]
  },
  {
    "objectID": "b1/problems/domino-piling.html",
    "href": "b1/problems/domino-piling.html",
    "title": "",
    "section": "",
    "text": "Domino piling\n\nCodeforces\neasy\n\n\n\nتوجد مصفوفة ثنائية الأبعاد مكوّنة من \\(N\\) صف و \\(M\\) عمود. لديك عدد غير محدود من القطع ذات الحجم 2 × 1، وتريد وضع أكبر عدد ممكن من هذه القطع في المصفوفة بحيث:\n\nكل قطعة تغطي خانين كاملين.\nجميع القطع لا تتقاطع.\nجميع القطع تكون داخل المصفوفة بشكل كامل.\n\n\n\n\n\n\nSolution\n\nفي هذه المسألة لدينا 3 حالات. لنحللها:\n\n\\(N\\) عدد زوجي (N % 2 == 0):\nيمكننا تغطية المصفوفة كاملة بوضع القطع بشكل عمودي.\nعدد القطع المستخدمة سيكون\n\\[ \\frac{N \\times M}{2} \\]\nلأن المصفوفة تحتوي على \\(N \\times M\\) خانة وكل قطعة تغطي خانتين.\n\\(M\\) عدد زوجي (M % 2 == 0):\nيمكننا تغطية المصفوفة كاملة بوضع القطع بشكل أفقي.\nعدد القطع سيكون\n\\[ \\frac{N \\times M}{2} \\]\nكلا من \\(N\\) و \\(M\\) عددان فرديان (N % 2 == 1 و M % 2 == 1):\nأولًا، نضع القطع بشكل عمودي ابتداء من الصف الأول، مما يترك صفًا كاملًا غير مغطى (لأن \\(N\\) فردي).\nفي ذلك الصف نضع القطع بشكل أفقي، فتتبقى خانة واحدة فقط غير مغطاة (لأن \\(M\\) فردي).\nبالتالي عدد القطع المستخدمة سيكون\n\\[ \\frac{N \\times M - 1}{2} \\]\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin &gt;&gt; N &gt;&gt; M;\n\n    if (N % 2 == 0) {\n        cout &lt;&lt; (N * M) / 2 &lt;&lt; endl;\n    }\n    else if (M % 2 == 0) {\n        cout &lt;&lt; (N * M) / 2 &lt;&lt; endl;\n    }\n    else {\n        cout &lt;&lt; (N * M - 1) / 2 &lt;&lt; endl;\n    }\n}",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Domino piling"
    ]
  },
  {
    "objectID": "b1/problems/domino-piling.html#domino-piling",
    "href": "b1/problems/domino-piling.html#domino-piling",
    "title": "",
    "section": "",
    "text": "Domino piling\n\nCodeforces\neasy\n\n\n\nتوجد مصفوفة ثنائية الأبعاد مكوّنة من \\(N\\) صف و \\(M\\) عمود. لديك عدد غير محدود من القطع ذات الحجم 2 × 1، وتريد وضع أكبر عدد ممكن من هذه القطع في المصفوفة بحيث:\n\nكل قطعة تغطي خانين كاملين.\nجميع القطع لا تتقاطع.\nجميع القطع تكون داخل المصفوفة بشكل كامل.",
    "crumbs": [
      "المرحلة 2",
      "Problems",
      "Domino piling"
    ]
  },
  {
    "objectID": "b1/sorting.html",
    "href": "b1/sorting.html",
    "title": "الترتيب (Sorting)",
    "section": "",
    "text": "الترتيب يعني ترتيب العناصر في تسلسل محدد، عادة من الأصغر إلى الأكبر، أو أبجديًا إذا كانت عناصر نصية.\nالترتيب يجعل البيانات أسهل للبحث والمقارنة والمعالجة بكفاءة. العديد من الخوارزميات، مثل البحث الثنائي، تعمل فقط إذا كانت البيانات مرتبة.\n\n\n\n\nترتيب الاختيار يجد بشكل متكرر أصغر عنصر من الجزء غير المرتب من المصفوفة وينقله إلى البداية.\nخطوة بخطوة:\n\nإيجاد أصغر عنصر في المصفوفة.\nتبديله مع العنصر الأول.\nإيجاد الأصغر التالي وتبديله مع العنصر الثاني.\nالاستمرار حتى تصبح المصفوفة مرتبة.\n\n\n\n\nلنفترض أن لدينا:\n\n[5, 8, 3, 4, 2]\n\nنجد أصغر عنصر وهو \\(2\\). ثم نقوم بتبديله مع أول عنصر في المصفوفة، وهو \\(5\\). تصبح المصفوفة:\n\n[2, 8, 3, 4, 5]\n\nالآن نريد وضع ثاني أصغر عنصر في الموقع الثاني. نجد الأصغر بين \\([8,3,4,5]\\)، وهو \\(3\\)، ونتبادله مع العنصر الثاني \\(8\\). تصبح المصفوفة:\n\n[2, 3, 8, 4, 5]\n\nالتالي، نجد ثالث أصغر عنصر بين \\([8,4,5]\\)، وهو \\(4\\). نبدله مع العنصر الثالث \\(8\\):\n\n[2, 3, 4, 8, 5]\n\nفي الخطوة الأخيرة، نريد رابع أصغر عنصر بين \\([5,8]\\)، وهو \\(5\\). نبدله مع العنصر الرابع \\(8\\):\n\n[2, 3, 4, 5, 8]\n\nالمصفوفة أصبحت مرتبة.\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {5, 8, 3, 4, 2};\n    int n = arr.size();\n\n    for (int i = 0; i &lt; n - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (arr[j] &lt; arr[minIndex])\n                minIndex = j;\n        }\n        swap(arr[i], arr[minIndex]);\n    }\n\n    for (int x : arr) \n        cout &lt;&lt; x &lt;&lt; ' ';\n    cout &lt;&lt; '\\n';\n}\n\nالمخرجات:\n\n2 3 4 5 8\n\nترتيب الاختيار سهل الفهم، لكنه غير فعال جدًا.\n\n\n\n\nهناك حلقتان متداخلتان.\nلذا يستغرق تقريبًا \\(n \\cdot n\\) خطوة → زمن \\(O(n^2)\\).\n\n\n\n\n\nفي البرامج الحقيقية وبرمجة المسابقات، نادرًا ما نكتب الترتيب يدويًا. C++ توفر دالة ترتيب سريعة جدًا في المكتبة القياسية.\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {5, 8, 3, 4, 2};\n    sort(arr.begin(), arr.end());\n\n    for (int x : arr) \n        cout &lt;&lt; x &lt;&lt; ' ';\n    cout &lt;&lt; '\\n';\n}\n\nالمخرجات:\n\n2 3 4 5 8\n\nالسطر sort(arr.begin(), arr.end()); يرتب الـ vector بأكمله تصاعديًا.\n\n\n\nيمكنك أيضًا استخدام نفس sort مع المصفوفات العادية:\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    int n = 5;\n\n    int arr[] = {5, 8, 3, 4, 2}; \n\n    sort(arr, arr + n);\n\n    for (int i = 0; i &lt; n; i++)\n        cout &lt;&lt; arr[i] &lt;&lt; ' ';\n    cout &lt;&lt; '\\n';\n}\n\nالمخرجات:\n\n2 3 4 5 8\n\nsort(arr, arr + n); يعني: رتب المصفوفة ابتداءً من arr وحتى arr + n (بعد آخر عنصر).\n\n\n\nإذا أردت الترتيب من الأكبر إلى الأصغر، استخدم مقارنة مخصصة:\nلـ vector:\n\nsort(arr.begin(), arr.end(), greater&lt;int&gt;());\n\nأو باستخدام iterators مع العكس:\n\nsort(arr.rbegin(), arr.rend());\n\nللمصفوفة العادية:\n\nsort(arr, arr + n, greater&lt;int&gt;());\n\nالمخرجات:\n\n8 5 4 3 2\n\n\n\n\nالدالة نفسها تعمل مع strings أو doubles أو أي نوع قابل للمقارنة:\n\nvector&lt;string&gt; names = {\"Bob\", \"Alice\", \"Charlie\"};\nsort(names.begin(), names.end());\n\nالمخرجات:\n\nAlice Bob Charlie\n\n\n\n\nيمكنك ترتيب مصفوفة حسب شروط خاصة بكتابة دالة comparator تأخذ عنصرين a و b وتعيد true إذا كان a يجب أن يأتي قبل b.\nمثال: ترتيب النصوص حسب طولها:\n\nbool comparator_by_length(string a, string b){\n    int len_a = a.length();\n    int len_b = b.length();\n\n    if (len_a &lt; len_b)\n        return 1;\n    else\n        return 0;\n}\n\nثم نستخدمها مع sort:\n\nvector&lt;string&gt; names = {\"Bob\", \"Alice\", \"Charlie\"};\nsort(names.begin(), names.end(), comparator_by_length);\n\nالمخرجات:\n\nBob Alice Charlie\n\nملاحظة مهمة: يجب أن تتصرف المقارنة مثل “less than” حقيقي:\n\nلا تتناقض\nلا تحتوي على دورات مثل a &lt; b, b &lt; c, و c &lt; a\n\nإذا كانت المقارنة غير متسقة، فإن sort سيكون سلوكه غير متوقع.\n\n\n\n\nدالة sort في المكتبة تستخدم خوارزمية محسنة. التعقيد الزمني لها \\(O(n \\log n)\\)، أسرع بكثير من \\(O(n^2)\\) للمدخلات الكبيرة.\nمثال:\n\nإذا \\(n = 1,000\\)، ترتيب الاختيار يقوم بحوالي \\(1,000,000\\) عملية.\nإذا \\(n = 1,000\\)، دالة sort تقوم حوالي \\(10,000\\) عملية — أسرع حوالي 100 مرة.",
    "crumbs": [
      "المرحلة 2",
      "الترتيب (Sorting)"
    ]
  },
  {
    "objectID": "b1/sorting.html#ترتيب-الاختيار-selection-sort",
    "href": "b1/sorting.html#ترتيب-الاختيار-selection-sort",
    "title": "الترتيب (Sorting)",
    "section": "",
    "text": "ترتيب الاختيار يجد بشكل متكرر أصغر عنصر من الجزء غير المرتب من المصفوفة وينقله إلى البداية.\nخطوة بخطوة:\n\nإيجاد أصغر عنصر في المصفوفة.\nتبديله مع العنصر الأول.\nإيجاد الأصغر التالي وتبديله مع العنصر الثاني.\nالاستمرار حتى تصبح المصفوفة مرتبة.\n\n\n\n\nلنفترض أن لدينا:\n\n[5, 8, 3, 4, 2]\n\nنجد أصغر عنصر وهو \\(2\\). ثم نقوم بتبديله مع أول عنصر في المصفوفة، وهو \\(5\\). تصبح المصفوفة:\n\n[2, 8, 3, 4, 5]\n\nالآن نريد وضع ثاني أصغر عنصر في الموقع الثاني. نجد الأصغر بين \\([8,3,4,5]\\)، وهو \\(3\\)، ونتبادله مع العنصر الثاني \\(8\\). تصبح المصفوفة:\n\n[2, 3, 8, 4, 5]\n\nالتالي، نجد ثالث أصغر عنصر بين \\([8,4,5]\\)، وهو \\(4\\). نبدله مع العنصر الثالث \\(8\\):\n\n[2, 3, 4, 8, 5]\n\nفي الخطوة الأخيرة، نريد رابع أصغر عنصر بين \\([5,8]\\)، وهو \\(5\\). نبدله مع العنصر الرابع \\(8\\):\n\n[2, 3, 4, 5, 8]\n\nالمصفوفة أصبحت مرتبة.\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {5, 8, 3, 4, 2};\n    int n = arr.size();\n\n    for (int i = 0; i &lt; n - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (arr[j] &lt; arr[minIndex])\n                minIndex = j;\n        }\n        swap(arr[i], arr[minIndex]);\n    }\n\n    for (int x : arr) \n        cout &lt;&lt; x &lt;&lt; ' ';\n    cout &lt;&lt; '\\n';\n}\n\nالمخرجات:\n\n2 3 4 5 8\n\nترتيب الاختيار سهل الفهم، لكنه غير فعال جدًا.\n\n\n\n\nهناك حلقتان متداخلتان.\nلذا يستغرق تقريبًا \\(n \\cdot n\\) خطوة → زمن \\(O(n^2)\\).",
    "crumbs": [
      "المرحلة 2",
      "الترتيب (Sorting)"
    ]
  },
  {
    "objectID": "b1/sorting.html#استخدام-الدالة-المدمجة-sort",
    "href": "b1/sorting.html#استخدام-الدالة-المدمجة-sort",
    "title": "الترتيب (Sorting)",
    "section": "",
    "text": "في البرامج الحقيقية وبرمجة المسابقات، نادرًا ما نكتب الترتيب يدويًا. C++ توفر دالة ترتيب سريعة جدًا في المكتبة القياسية.\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {5, 8, 3, 4, 2};\n    sort(arr.begin(), arr.end());\n\n    for (int x : arr) \n        cout &lt;&lt; x &lt;&lt; ' ';\n    cout &lt;&lt; '\\n';\n}\n\nالمخرجات:\n\n2 3 4 5 8\n\nالسطر sort(arr.begin(), arr.end()); يرتب الـ vector بأكمله تصاعديًا.\n\n\n\nيمكنك أيضًا استخدام نفس sort مع المصفوفات العادية:\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    int n = 5;\n\n    int arr[] = {5, 8, 3, 4, 2}; \n\n    sort(arr, arr + n);\n\n    for (int i = 0; i &lt; n; i++)\n        cout &lt;&lt; arr[i] &lt;&lt; ' ';\n    cout &lt;&lt; '\\n';\n}\n\nالمخرجات:\n\n2 3 4 5 8\n\nsort(arr, arr + n); يعني: رتب المصفوفة ابتداءً من arr وحتى arr + n (بعد آخر عنصر).\n\n\n\nإذا أردت الترتيب من الأكبر إلى الأصغر، استخدم مقارنة مخصصة:\nلـ vector:\n\nsort(arr.begin(), arr.end(), greater&lt;int&gt;());\n\nأو باستخدام iterators مع العكس:\n\nsort(arr.rbegin(), arr.rend());\n\nللمصفوفة العادية:\n\nsort(arr, arr + n, greater&lt;int&gt;());\n\nالمخرجات:\n\n8 5 4 3 2\n\n\n\n\nالدالة نفسها تعمل مع strings أو doubles أو أي نوع قابل للمقارنة:\n\nvector&lt;string&gt; names = {\"Bob\", \"Alice\", \"Charlie\"};\nsort(names.begin(), names.end());\n\nالمخرجات:\n\nAlice Bob Charlie\n\n\n\n\nيمكنك ترتيب مصفوفة حسب شروط خاصة بكتابة دالة comparator تأخذ عنصرين a و b وتعيد true إذا كان a يجب أن يأتي قبل b.\nمثال: ترتيب النصوص حسب طولها:\n\nbool comparator_by_length(string a, string b){\n    int len_a = a.length();\n    int len_b = b.length();\n\n    if (len_a &lt; len_b)\n        return 1;\n    else\n        return 0;\n}\n\nثم نستخدمها مع sort:\n\nvector&lt;string&gt; names = {\"Bob\", \"Alice\", \"Charlie\"};\nsort(names.begin(), names.end(), comparator_by_length);\n\nالمخرجات:\n\nBob Alice Charlie\n\nملاحظة مهمة: يجب أن تتصرف المقارنة مثل “less than” حقيقي:\n\nلا تتناقض\nلا تحتوي على دورات مثل a &lt; b, b &lt; c, و c &lt; a\n\nإذا كانت المقارنة غير متسقة، فإن sort سيكون سلوكه غير متوقع.",
    "crumbs": [
      "المرحلة 2",
      "الترتيب (Sorting)"
    ]
  },
  {
    "objectID": "b1/sorting.html#التعقيد",
    "href": "b1/sorting.html#التعقيد",
    "title": "الترتيب (Sorting)",
    "section": "",
    "text": "دالة sort في المكتبة تستخدم خوارزمية محسنة. التعقيد الزمني لها \\(O(n \\log n)\\)، أسرع بكثير من \\(O(n^2)\\) للمدخلات الكبيرة.\nمثال:\n\nإذا \\(n = 1,000\\)، ترتيب الاختيار يقوم بحوالي \\(1,000,000\\) عملية.\nإذا \\(n = 1,000\\)، دالة sort تقوم حوالي \\(10,000\\) عملية — أسرع حوالي 100 مرة.",
    "crumbs": [
      "المرحلة 2",
      "الترتيب (Sorting)"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html",
    "href": "b1/modular-arithmetics.html",
    "title": "الحسابيات المعيارية (Modular Arithmetic)",
    "section": "",
    "text": "الحسابيات المعيارية هي طريقة للقيام بالعمليات الحسابية حيث “تدور” الأعداد بعد الوصول إلى قيمة معينة — تسمى المعامل (modulus).\nفكر بها مثل الساعة. بعد 24 ساعة، تعود الساعة لنفس الوقت مرة أخرى. هذه هي عملية mod 24!\n\n\n\nعندما نقول a mod m، فهذا يعني الباقي عند قسمة a على m.\nمثال:\n\n\n\n\n\n\n\n\nالتعبير\nالمعنى\nالنتيجة\n\n\n\n\n7 mod 3\n7 ÷ 3 → الباقي\n1\n\n\n10 mod 4\n10 ÷ 4 → الباقي\n2\n\n\n15 mod 6\n15 ÷ 6 → الباقي\n3\n\n\n12 mod 12\n12 ÷ 12 → الباقي\n0\n\n\n\nفي C++ نستخدم %:\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; 7 % 3 &lt;&lt; endl;   // 1\n    cout &lt;&lt; 10 % 4 &lt;&lt; endl;  // 2\n    cout &lt;&lt; 10 % 5 &lt;&lt; endl;  // 0\n}\n\n\n\n\n\nعند التعامل مع أعداد كبيرة جدًا (مثلًا في التوافقيات أو التشفير)، قد تصبح النتائج أكبر من أن تتسع لأنواع البيانات العادية. الحل: نأخذ كل شيء mod لنبقي النتائج صغيرة.\nالمعامل الشائع في البرمجة التنافسية:\n\nconst int MOD = 1'000'000'007; // عدد أولي كبير\n\nلماذا نستخدمه:\n\nيناسب الأعداد 64-بت بأمان.\nتجنب تجاوز السعة عند الجمع.\nلأنه عدد أولي، له خصائص رياضية مفيدة.\n\n\n\n\n\n\nالجمع\n\n\n(a + b) % m = (a % m + b % m) % m\n\n\nالطرح\n\n\n(a - b) % m = ((a % m - b % m) + m) % m\n\nنضيف +m لضمان عدم الحصول على عدد سالب.\n\nالضرب\n\n\n(a * b) % m = (a % m * b % m) % m\n\nمثال:\n\nint a = 7, b = 5, m = 3;\ncout &lt;&lt; (a + b) % m &lt;&lt; endl;   // 0\ncout &lt;&lt; (a * b) % m &lt;&lt; endl;   // 2\n\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    const int MOD = 1'000'000'007;\n    long long a = 1e12, b = 1e12;\n    cout &lt;&lt; (a + b) % MOD &lt;&lt; endl;\n}\n\nالناتج:\n\n999999979\n\n\n\n\n\n\nفي C++، % قد يعطي نتيجة سالبة:\n\ncout &lt;&lt; (-5) % 3; // -2\n\nلحل هذه المشكلة:\n\n((a % m) + m) % m\n\nمثال:\n\nint a = -5, m = 3;\ncout &lt;&lt; ((a % m) + m) % m; // 1\n\n\n\n\n\nلحساب (a^b m) بطريقة سريعة، لا تضرب (a) (b) مرة. استخدم الأس السريع:\n\nإذا كان \\((b)\\) زوجيًا: \\((a^b = (a^{b/2})^2)\\)\nإذا كان \\((b)\\) فرديًا: \\((a^b = a \\cdot (a^{b/2})^2)\\)\n\n\nlong long modpow(long long a, long long b, long long m) {\n    if (b == 0) return 1;\n\n    long long half = modpow(a, b / 2, m);\n    long long res = (half * half) % m;\n\n    if (b % 2 == 1)\n        res = (res * (a % m)) % m;\n    \n    return res;\n}\n\nنظرًا لأن \\(b\\) يتم تقسيمه إلى النصف في كل مرة يتم فيها استدعاء التكرار، فإن العدد الإجمالي للمكالمات التكرارية هو \\(\\lfloor \\log_2 b \\rfloor + 1\\)، وبالتالي فإن التعقيد الزمني لهذه الدالة هو \\(O(\\log b)\\).\nمثال للاستخدام:\n\ncout &lt;&lt; modpow(2, 10, 1000); // الناتج 24\n\n\n\n\n\nعند الحاجة للقيام بالقسمة تحت المودولو، نستخدم المعكوس المعياري.\nإذا كان MOD أوليًا، معكوس a:\n\\(a^{-1} \\equiv a^{MOD-2} \\mod MOD\\)\n\nint inverse = modpow(a, MOD - 2, MOD);\n\nالقسمة تصبح:\n\n(a * modpow(b, MOD - 2, MOD)) % MOD\n\n\n\n\n\n\nعند التعامل مع أعداد كبيرة جدًا\nعندما يحتاج الناتج فقط “mod 1e9+7”\nعند تنفيذ خوارزميات رياضية (أس، معكوس، توافقيات)\n\n\n\n\n\n\n% يعطي الباقي عند القسمة\nاستخدم (a + b) % MOD, (a * b) % MOD, و ((a - b) % MOD + MOD) % MOD\nللأسس الكبيرة استخدم الأس السريع (modular exponentiation)\nللقسمة استخدم المعكوس المعياري إذا كان المودولو أوليًا",
    "crumbs": [
      "المرحلة 2",
      "الحسابيات المعيارية (Modular Arithmetic)"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#معنى-mod",
    "href": "b1/modular-arithmetics.html#معنى-mod",
    "title": "الحسابيات المعيارية (Modular Arithmetic)",
    "section": "",
    "text": "عندما نقول a mod m، فهذا يعني الباقي عند قسمة a على m.\nمثال:\n\n\n\n\n\n\n\n\nالتعبير\nالمعنى\nالنتيجة\n\n\n\n\n7 mod 3\n7 ÷ 3 → الباقي\n1\n\n\n10 mod 4\n10 ÷ 4 → الباقي\n2\n\n\n15 mod 6\n15 ÷ 6 → الباقي\n3\n\n\n12 mod 12\n12 ÷ 12 → الباقي\n0\n\n\n\nفي C++ نستخدم %:\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; 7 % 3 &lt;&lt; endl;   // 1\n    cout &lt;&lt; 10 % 4 &lt;&lt; endl;  // 2\n    cout &lt;&lt; 10 % 5 &lt;&lt; endl;  // 0\n}",
    "crumbs": [
      "المرحلة 2",
      "الحسابيات المعيارية (Modular Arithmetic)"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#استخدام-الحسابيات-المعيارية-في-البرمجة",
    "href": "b1/modular-arithmetics.html#استخدام-الحسابيات-المعيارية-في-البرمجة",
    "title": "الحسابيات المعيارية (Modular Arithmetic)",
    "section": "",
    "text": "عند التعامل مع أعداد كبيرة جدًا (مثلًا في التوافقيات أو التشفير)، قد تصبح النتائج أكبر من أن تتسع لأنواع البيانات العادية. الحل: نأخذ كل شيء mod لنبقي النتائج صغيرة.\nالمعامل الشائع في البرمجة التنافسية:\n\nconst int MOD = 1'000'000'007; // عدد أولي كبير\n\nلماذا نستخدمه:\n\nيناسب الأعداد 64-بت بأمان.\nتجنب تجاوز السعة عند الجمع.\nلأنه عدد أولي، له خصائص رياضية مفيدة.",
    "crumbs": [
      "المرحلة 2",
      "الحسابيات المعيارية (Modular Arithmetic)"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#قواعد-أساسية",
    "href": "b1/modular-arithmetics.html#قواعد-أساسية",
    "title": "الحسابيات المعيارية (Modular Arithmetic)",
    "section": "",
    "text": "الجمع\n\n\n(a + b) % m = (a % m + b % m) % m\n\n\nالطرح\n\n\n(a - b) % m = ((a % m - b % m) + m) % m\n\nنضيف +m لضمان عدم الحصول على عدد سالب.\n\nالضرب\n\n\n(a * b) % m = (a % m * b % m) % m\n\nمثال:\n\nint a = 7, b = 5, m = 3;\ncout &lt;&lt; (a + b) % m &lt;&lt; endl;   // 0\ncout &lt;&lt; (a * b) % m &lt;&lt; endl;   // 2\n\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    const int MOD = 1'000'000'007;\n    long long a = 1e12, b = 1e12;\n    cout &lt;&lt; (a + b) % MOD &lt;&lt; endl;\n}\n\nالناتج:\n\n999999979",
    "crumbs": [
      "المرحلة 2",
      "الحسابيات المعيارية (Modular Arithmetic)"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#التعامل-مع-الأعداد-السالبة",
    "href": "b1/modular-arithmetics.html#التعامل-مع-الأعداد-السالبة",
    "title": "الحسابيات المعيارية (Modular Arithmetic)",
    "section": "",
    "text": "في C++، % قد يعطي نتيجة سالبة:\n\ncout &lt;&lt; (-5) % 3; // -2\n\nلحل هذه المشكلة:\n\n((a % m) + m) % m\n\nمثال:\n\nint a = -5, m = 3;\ncout &lt;&lt; ((a % m) + m) % m; // 1",
    "crumbs": [
      "المرحلة 2",
      "الحسابيات المعيارية (Modular Arithmetic)"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#الأسس-المعيارية-modular-exponentiation",
    "href": "b1/modular-arithmetics.html#الأسس-المعيارية-modular-exponentiation",
    "title": "الحسابيات المعيارية (Modular Arithmetic)",
    "section": "",
    "text": "لحساب (a^b m) بطريقة سريعة، لا تضرب (a) (b) مرة. استخدم الأس السريع:\n\nإذا كان \\((b)\\) زوجيًا: \\((a^b = (a^{b/2})^2)\\)\nإذا كان \\((b)\\) فرديًا: \\((a^b = a \\cdot (a^{b/2})^2)\\)\n\n\nlong long modpow(long long a, long long b, long long m) {\n    if (b == 0) return 1;\n\n    long long half = modpow(a, b / 2, m);\n    long long res = (half * half) % m;\n\n    if (b % 2 == 1)\n        res = (res * (a % m)) % m;\n    \n    return res;\n}\n\nنظرًا لأن \\(b\\) يتم تقسيمه إلى النصف في كل مرة يتم فيها استدعاء التكرار، فإن العدد الإجمالي للمكالمات التكرارية هو \\(\\lfloor \\log_2 b \\rfloor + 1\\)، وبالتالي فإن التعقيد الزمني لهذه الدالة هو \\(O(\\log b)\\).\nمثال للاستخدام:\n\ncout &lt;&lt; modpow(2, 10, 1000); // الناتج 24",
    "crumbs": [
      "المرحلة 2",
      "الحسابيات المعيارية (Modular Arithmetic)"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#المعكوس-المعياري-modular-inverse",
    "href": "b1/modular-arithmetics.html#المعكوس-المعياري-modular-inverse",
    "title": "الحسابيات المعيارية (Modular Arithmetic)",
    "section": "",
    "text": "عند الحاجة للقيام بالقسمة تحت المودولو، نستخدم المعكوس المعياري.\nإذا كان MOD أوليًا، معكوس a:\n\\(a^{-1} \\equiv a^{MOD-2} \\mod MOD\\)\n\nint inverse = modpow(a, MOD - 2, MOD);\n\nالقسمة تصبح:\n\n(a * modpow(b, MOD - 2, MOD)) % MOD",
    "crumbs": [
      "المرحلة 2",
      "الحسابيات المعيارية (Modular Arithmetic)"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#متى-نستخدم-الحسابيات-المعيارية",
    "href": "b1/modular-arithmetics.html#متى-نستخدم-الحسابيات-المعيارية",
    "title": "الحسابيات المعيارية (Modular Arithmetic)",
    "section": "",
    "text": "عند التعامل مع أعداد كبيرة جدًا\nعندما يحتاج الناتج فقط “mod 1e9+7”\nعند تنفيذ خوارزميات رياضية (أس، معكوس، توافقيات)",
    "crumbs": [
      "المرحلة 2",
      "الحسابيات المعيارية (Modular Arithmetic)"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#الملخص-السريع",
    "href": "b1/modular-arithmetics.html#الملخص-السريع",
    "title": "الحسابيات المعيارية (Modular Arithmetic)",
    "section": "",
    "text": "% يعطي الباقي عند القسمة\nاستخدم (a + b) % MOD, (a * b) % MOD, و ((a - b) % MOD + MOD) % MOD\nللأسس الكبيرة استخدم الأس السريع (modular exponentiation)\nللقسمة استخدم المعكوس المعياري إذا كان المودولو أوليًا",
    "crumbs": [
      "المرحلة 2",
      "الحسابيات المعيارية (Modular Arithmetic)"
    ]
  },
  {
    "objectID": "b1/casework.html",
    "href": "b1/casework.html",
    "title": "العمل على الحالات",
    "section": "",
    "text": "مشاكل العمل على الحالات هي تلك التي يُوجد حلها عبر تقسيم المشكلة إلى حالات مختلفة، حل كل واحدة منها بشكل منفصل، ثم دمج النتائج.\n\n\nفي العديد من المسائل قد تحاول كتابة صيغة واحدة أو حلقة واحدة تغطي كل شيء. في مسائل العمل على الحالات، تلاحظ أن المواقف المختلفة تتصرف بشكل مختلف. لذا بدلًا من قاعدة واحدة عامة، تقول:\n\nإذا حدثت الحالة A، افعل هذا.\nإذا حدثت الحالة B، افعل ذاك.\nوربما أيضًا الحالة C، الحالة D، إلخ.\n\nثم إما تجمع إجابات كل الحالات، أو تختار الأفضل بينها.\n\n\n\n\nيسمح لك بالتعامل مع الحالات الخاصة بوضوح (عندما لا تكفي المنطقية البسيطة).\nيساعدك في تقسيم مشكلة صعبة إلى أجزاء سهلة التعامل.\nيظهر كثيرًا في مسائل العد أو المسائل ذات النتائج المتعددة.\n\n\n\n\n\nاقرأ المشكلة بعناية وابحث عن الأماكن التي يحدث فيها تغيير (مثل صغير/كبير، موجب/سالب، زوجي/فردي).\nحدد جميع الحالات المختلفة التي تغطي كل الاحتمالات دون تداخل.\nلكل حالة، اكتشف كيف تحسب النتيجة.\nاجمع النتائج إن لزم الأمر (إما جمعها أو أخذ الأصغر/الأكبر).\nتأكد أنك لم تفوّت أي حالة أو تحسب شيئًا مرتين.\n\n\n\n\n\n\n\n\n\nEven or odd sum\n\n\n\n\n\nلديك عددان \\(a\\) و \\(b\\). احسب عدد الأزواج \\((i, j)\\) بحيث \\(1 \\leq i \\leq a\\) و \\(1 \\leq j \\leq b\\) ويكون \\(i + j\\) زوجيًا.\n\n\n\n\n\nSolution\n\nملاحظة: يكون \\(i + j\\) زوجيًا إذا كان كلاهما زوجيًا أو كلاهما فرديًا.\nإذًا هناك حالتان:\n\nالحالة 1: \\(i\\) زوجي و \\(j\\) زوجي\nالحالة 2: \\(i\\) فردي و \\(j\\) فردي\n\nاحسب كل حالة واجمعهما معًا.\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    int evenA = a / 2;\n    int oddA = a - evenA;\n    int evenB = b / 2;\n    int oddB = b - evenB;\n\n    int pairs = evenA * evenB + oddA * oddB;\n    cout &lt;&lt; pairs;\n}\n\n\n\n\n\n\n\n\nTriangle validity\n\n\n\n\n\nمعطى لك ثلاثة أطوال أضلاع \\(a, b, c\\)، حدّد إن كانت تستطيع تشكيل مثلث.\n\n\n\n\n\nSolution\n\nيمكننا اختبار كل حالة عبر التحقق من أن مجموع أي ضلعين أكبر من الضلع الثالث\n\n\\(b + c &gt; a\\)\n\\(c + a &gt; b\\)\n\\(a + b &gt; c\\)\n\nإذا كانت جميع هذه المتباينات صحيحة، فإن تكوين مثلث ممكن. سنقوم بالتحقق من كل واحدة من هذه المتباينات، وفي حال أي متباينة لم تتحقق، فالإجابة هي “no”، وإلا فالإجابة هي “yes”.\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b, c;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\n    bool ok = true;\n    if (b + c &lt;= a) ok = false;\n    if (a + c &lt;= b) ok = false;\n    if (a + b &lt;= c) ok = false;\n\n    cout &lt;&lt; (ok ? \"YES\" : \"NO\");\n}\n\nهذا يفحص كل حالة بشكل مستقل — مثال مباشر على العمل على الحالات.\n\n\n\n\n\n\n\nCoordinate quadrant\n\n\n\n\n\nمعطى \\((x, y)\\)، اطبع أي ربع ينتمي إليه النقطة.\n\n\n\n\n\nSolution\n\nالحالات:\n\n\\(x &gt; 0, y &gt; 0\\) ← Quadrant I\n\\(x &lt; 0, y &gt; 0\\) ← Quadrant II\n\\(x &lt; 0, y &lt; 0\\) ← Quadrant III\n\\(x &gt; 0, y &lt; 0\\) ← Quadrant IV\nإذا كان \\(x = 0\\) أو \\(y = 0\\) ← على المحور\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x, y;\n    cin &gt;&gt; x &gt;&gt; y;\n\n    if (x &gt; 0 && y &gt; 0) cout &lt;&lt; \"Quadrant I\";\n    else if (x &lt; 0 && y &gt; 0) cout &lt;&lt; \"Quadrant II\";\n    else if (x &lt; 0 && y &lt; 0) cout &lt;&lt; \"Quadrant III\";\n    else if (x &gt; 0 && y &lt; 0) cout &lt;&lt; \"Quadrant IV\";\n    else cout &lt;&lt; \"On an axis\";\n}\n\n\n\n\n\n\n\nتأكد أن حالاتك لا تتداخل.\nتأكد أن كل الاحتمالات مغطاة.\nانتبه للحدود (مثل 0 أو المساواة).\nحافظ على المنطق واضحًا وبسيطًا.\n\n\n\n\n\nالعمل على الحالات يعني تقسيم المشكلة إلى مواقف أبسط.\nحل كل حالة مستقلًا ثم دمج النتائج.\nهو أسلوب تفكير، ليس خوارزمية خاصة.\nممتاز لمراحل البداية في حل المشاكل.\n\n\nنصيحة: عندما تكون غير متأكد من البداية، فكر: “ما هي الحالات الممكنة؟” — هذه بداية العمل على الحالات.",
    "crumbs": [
      "المرحلة 2",
      "العمل على الحالات"
    ]
  },
  {
    "objectID": "b1/casework.html#ما-هو-العمل-على-الحالات",
    "href": "b1/casework.html#ما-هو-العمل-على-الحالات",
    "title": "العمل على الحالات",
    "section": "",
    "text": "في العديد من المسائل قد تحاول كتابة صيغة واحدة أو حلقة واحدة تغطي كل شيء. في مسائل العمل على الحالات، تلاحظ أن المواقف المختلفة تتصرف بشكل مختلف. لذا بدلًا من قاعدة واحدة عامة، تقول:\n\nإذا حدثت الحالة A، افعل هذا.\nإذا حدثت الحالة B، افعل ذاك.\nوربما أيضًا الحالة C، الحالة D، إلخ.\n\nثم إما تجمع إجابات كل الحالات، أو تختار الأفضل بينها.",
    "crumbs": [
      "المرحلة 2",
      "العمل على الحالات"
    ]
  },
  {
    "objectID": "b1/casework.html#لماذا-نستخدم-العمل-على-الحالات",
    "href": "b1/casework.html#لماذا-نستخدم-العمل-على-الحالات",
    "title": "العمل على الحالات",
    "section": "",
    "text": "يسمح لك بالتعامل مع الحالات الخاصة بوضوح (عندما لا تكفي المنطقية البسيطة).\nيساعدك في تقسيم مشكلة صعبة إلى أجزاء سهلة التعامل.\nيظهر كثيرًا في مسائل العد أو المسائل ذات النتائج المتعددة.",
    "crumbs": [
      "المرحلة 2",
      "العمل على الحالات"
    ]
  },
  {
    "objectID": "b1/casework.html#كيف-نقوم-بالعمل-على-الحالات",
    "href": "b1/casework.html#كيف-نقوم-بالعمل-على-الحالات",
    "title": "العمل على الحالات",
    "section": "",
    "text": "اقرأ المشكلة بعناية وابحث عن الأماكن التي يحدث فيها تغيير (مثل صغير/كبير، موجب/سالب، زوجي/فردي).\nحدد جميع الحالات المختلفة التي تغطي كل الاحتمالات دون تداخل.\nلكل حالة، اكتشف كيف تحسب النتيجة.\nاجمع النتائج إن لزم الأمر (إما جمعها أو أخذ الأصغر/الأكبر).\nتأكد أنك لم تفوّت أي حالة أو تحسب شيئًا مرتين.",
    "crumbs": [
      "المرحلة 2",
      "العمل على الحالات"
    ]
  },
  {
    "objectID": "b1/casework.html#even-or-odd-sum",
    "href": "b1/casework.html#even-or-odd-sum",
    "title": "العمل على الحالات",
    "section": "",
    "text": "Even or odd sum\n\n\n\n\n\nلديك عددان \\(a\\) و \\(b\\). احسب عدد الأزواج \\((i, j)\\) بحيث \\(1 \\leq i \\leq a\\) و \\(1 \\leq j \\leq b\\) ويكون \\(i + j\\) زوجيًا.",
    "crumbs": [
      "المرحلة 2",
      "العمل على الحالات"
    ]
  },
  {
    "objectID": "b1/casework.html#triangle-validity",
    "href": "b1/casework.html#triangle-validity",
    "title": "العمل على الحالات",
    "section": "",
    "text": "Triangle validity\n\n\n\n\n\nمعطى لك ثلاثة أطوال أضلاع \\(a, b, c\\)، حدّد إن كانت تستطيع تشكيل مثلث.",
    "crumbs": [
      "المرحلة 2",
      "العمل على الحالات"
    ]
  },
  {
    "objectID": "b1/casework.html#coordinate-quadrant",
    "href": "b1/casework.html#coordinate-quadrant",
    "title": "العمل على الحالات",
    "section": "",
    "text": "Coordinate quadrant\n\n\n\n\n\nمعطى \\((x, y)\\)، اطبع أي ربع ينتمي إليه النقطة.",
    "crumbs": [
      "المرحلة 2",
      "العمل على الحالات"
    ]
  },
  {
    "objectID": "b1/casework.html#نصائح-للعمل-على-الحالات",
    "href": "b1/casework.html#نصائح-للعمل-على-الحالات",
    "title": "العمل على الحالات",
    "section": "",
    "text": "تأكد أن حالاتك لا تتداخل.\nتأكد أن كل الاحتمالات مغطاة.\nانتبه للحدود (مثل 0 أو المساواة).\nحافظ على المنطق واضحًا وبسيطًا.",
    "crumbs": [
      "المرحلة 2",
      "العمل على الحالات"
    ]
  },
  {
    "objectID": "b1/casework.html#خلاصة-سريعة",
    "href": "b1/casework.html#خلاصة-سريعة",
    "title": "العمل على الحالات",
    "section": "",
    "text": "العمل على الحالات يعني تقسيم المشكلة إلى مواقف أبسط.\nحل كل حالة مستقلًا ثم دمج النتائج.\nهو أسلوب تفكير، ليس خوارزمية خاصة.\nممتاز لمراحل البداية في حل المشاكل.\n\n\nنصيحة: عندما تكون غير متأكد من البداية، فكر: “ما هي الحالات الممكنة؟” — هذه بداية العمل على الحالات.",
    "crumbs": [
      "المرحلة 2",
      "العمل على الحالات"
    ]
  },
  {
    "objectID": "b2/backtracking.html",
    "href": "b2/backtracking.html",
    "title": "Backtracking",
    "section": "",
    "text": "backtracking هو أسلوب يستكشف جميع الحلول الممكنة لمشكلة معينة. يقوم الـbacktracking ببناء الحلول خطوة بخطوة يتراجع عن الخطوات كلما انتهت من استكشاف اتجاه معين.\n\n\nتبدأ خوارزمية backtracking بحل فارغ. في كل خطوة، تحاول الخوارزمية كل الطرق الممكنة. بعد استكشاف جميع الطرق، تتراجع الخوارزمية إلى الخطوة السابقة عن طريق التراجع عن اخر خطوة. يمكن تلخيص الخوارزمية كما يلي:\n\nابدأ بحل فارغ.\nقم بتمديد الحل خطوة بخطوة.\nاستكشف بشكل متكرر جميع الطرق المختلفة التي يمكن أن يُبنى بها الحل.\nتراجع عن آخر خطوة تم تنفيذها.\n\n\n\n\nلتوليد جميع المجموعات الجزئية لمصفوفة باستخدام backtracking، ابدأ بحل فارغ. في كل خطوة، لديك الموقع i حاول كلا الاحتمالين: إضافة a[i] في المجموعة الجزئية أو استبعاده. بعد استكشاف كل طريقة، تراجع عن آخر تغيير. عندما يصبح i خارج المصفوفة، اطبع المجموعة الجزئية الحالية. مثال على كود يطبع جميع المجموعات الجزئية الممكنة كما يلي:\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n = 3;\nint a[3] = {5, 3, 1};\nvector&lt;int&gt; v;\n\nvoid backtracking(int i) {\n\n    // تم المرور على جميع العناصر، اطبع المجموعة الجزئية الحالية i == n إذا \n    if (i == n) {\n        cout &lt;&lt; \"subset: \";\n        for (int j = 0; j &lt; v.size(); j++) {\n            cout &lt;&lt; v[j] &lt;&lt; ' ';\n        }\n        cout &lt;&lt; \"\\n\";\n        return;\n    }\n\n    // إلى المجموعة الجزئية a[i] حاول إضافة\n    v.push_back(a[i]);   // v أضفها إلى \n    backtracking(i + 1); // v موجودة في  a[i] حاول جميع الحلول حيث \n\n    // من المجموعة الجزئية a[i] حاول إستبعاد\n    v.pop_back();        // a[i] تراجع عن إضافة\n    backtracking(i + 1); // v غير موجودة في  a[i] حاول جميع الحلول حيث \n\n    // لا نحتاج لأي تراجع لأننا لم نغيز شيء في آخر خطوة\n}\n\nint main() {\n\n    backtracking(0);\n}\n\n\n\n\n\n\n\n\n\nApple Division\n\nCSES\n\n\n\nلديك مصفوفة a من \\(n\\) عنصر. نريد تقسيم العناصر إلى مجموعتين بحيث يكون الفرق بين مجموع كل المجموعتين صغيرًا أصغر ما يمكن. المطلوب عو طباعة أصغر فرق ممكن.\n\n\n\n\n\nSolution\n\nسنستخدم backtracking لتجربة كل التقسيمات الممكنة وطباعة الحل الذي يعطي أصغر فرق.\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint n;\nint a[20];\nlong long sum1 = 0;         // مجموع المجموعة الإولى\nlong long sum2 = 0;         // مجموع المجموعة الإولى\nlong long ans = 2000000000; // الحل رقم كبير جدا مبدئيا\n\nvoid backtracking(int i) {\n    // حدث الحل الحالي i == n إذا\n    if (i == n) {\n        ans = min(ans, abs(sum1 - sum2));\n        return;\n    }\n    //حاول جميع الاختيارات الممكنة\n\n    // للمجموعة الأولى a[i] حاول إضافة\n    sum1 += a[i];\n    backtracking(i + 1);\n    sum1 -= a[i];\n\n    // للمجموعة الثانية a[i] حاول إضافة\n    sum2 += a[i];\n    backtracking(i + 1);\n    sum2 -= a[i];\n\n}\n\nint main() {\n\n    cin &gt;&gt; n;\n\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; a[i];\n    }\n\n    backtracking(0);\n\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n}",
    "crumbs": [
      "المرحلة 3",
      "<span dir=\"ltr\">Backtracking</span>"
    ]
  },
  {
    "objectID": "b2/backtracking.html#كيف-تعمل",
    "href": "b2/backtracking.html#كيف-تعمل",
    "title": "Backtracking",
    "section": "",
    "text": "تبدأ خوارزمية backtracking بحل فارغ. في كل خطوة، تحاول الخوارزمية كل الطرق الممكنة. بعد استكشاف جميع الطرق، تتراجع الخوارزمية إلى الخطوة السابقة عن طريق التراجع عن اخر خطوة. يمكن تلخيص الخوارزمية كما يلي:\n\nابدأ بحل فارغ.\nقم بتمديد الحل خطوة بخطوة.\nاستكشف بشكل متكرر جميع الطرق المختلفة التي يمكن أن يُبنى بها الحل.\nتراجع عن آخر خطوة تم تنفيذها.",
    "crumbs": [
      "المرحلة 3",
      "<span dir=\"ltr\">Backtracking</span>"
    ]
  },
  {
    "objectID": "b2/backtracking.html#توليد-المجموعات-الجزئية",
    "href": "b2/backtracking.html#توليد-المجموعات-الجزئية",
    "title": "Backtracking",
    "section": "",
    "text": "لتوليد جميع المجموعات الجزئية لمصفوفة باستخدام backtracking، ابدأ بحل فارغ. في كل خطوة، لديك الموقع i حاول كلا الاحتمالين: إضافة a[i] في المجموعة الجزئية أو استبعاده. بعد استكشاف كل طريقة، تراجع عن آخر تغيير. عندما يصبح i خارج المصفوفة، اطبع المجموعة الجزئية الحالية. مثال على كود يطبع جميع المجموعات الجزئية الممكنة كما يلي:\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n = 3;\nint a[3] = {5, 3, 1};\nvector&lt;int&gt; v;\n\nvoid backtracking(int i) {\n\n    // تم المرور على جميع العناصر، اطبع المجموعة الجزئية الحالية i == n إذا \n    if (i == n) {\n        cout &lt;&lt; \"subset: \";\n        for (int j = 0; j &lt; v.size(); j++) {\n            cout &lt;&lt; v[j] &lt;&lt; ' ';\n        }\n        cout &lt;&lt; \"\\n\";\n        return;\n    }\n\n    // إلى المجموعة الجزئية a[i] حاول إضافة\n    v.push_back(a[i]);   // v أضفها إلى \n    backtracking(i + 1); // v موجودة في  a[i] حاول جميع الحلول حيث \n\n    // من المجموعة الجزئية a[i] حاول إستبعاد\n    v.pop_back();        // a[i] تراجع عن إضافة\n    backtracking(i + 1); // v غير موجودة في  a[i] حاول جميع الحلول حيث \n\n    // لا نحتاج لأي تراجع لأننا لم نغيز شيء في آخر خطوة\n}\n\nint main() {\n\n    backtracking(0);\n}",
    "crumbs": [
      "المرحلة 3",
      "<span dir=\"ltr\">Backtracking</span>"
    ]
  },
  {
    "objectID": "b2/backtracking.html#apple-division",
    "href": "b2/backtracking.html#apple-division",
    "title": "Backtracking",
    "section": "",
    "text": "Apple Division\n\nCSES\n\n\n\nلديك مصفوفة a من \\(n\\) عنصر. نريد تقسيم العناصر إلى مجموعتين بحيث يكون الفرق بين مجموع كل المجموعتين صغيرًا أصغر ما يمكن. المطلوب عو طباعة أصغر فرق ممكن.",
    "crumbs": [
      "المرحلة 3",
      "<span dir=\"ltr\">Backtracking</span>"
    ]
  },
  {
    "objectID": "b2/cpp/bitwise-operations.html",
    "href": "b2/cpp/bitwise-operations.html",
    "title": "العمليات على مستوى البِت (Bitwise Operations)",
    "section": "",
    "text": "تسمح لك العمليات على مستوى البِت بالعمل مع البِتّات الفردية داخل العدد الصحيح. هذه العمليات قوية جدًّا في التعامل مع البِتّات، وحيل التحسين (optimization)، وأشياء مثل توليد جميع المجموعات الجزئية لمجموعة معيّنة.\n\n\nتقوم الحواسيب بتخزين الأعداد الصحيحة في صورة ثنائية — باستخدام 0 و1 فقط. نقول إن البِت مُعيَّن (set) إذا كانت قيمته 1. كل موضع (بِت) يمثّل قوة من قوى العدد 2:\n\nBit position:  7  6  5  4  3  2  1  0\nValue:       128 64 32 16  8  4  2  1\n\nللحصول على قيمة عدد ثنائي، نقوم بجمع قوى العدد 2 في الأماكن التي يكون فيها البِت مساويًا لـ1.\n\n\n\n00000110  =  4 + 2       = 6\n00001010  =  8 + 2       = 10\n00001100  =  8 + 4       = 12\n00000001  =  1           = 1\n00000000  =  0           = 0\n\nإذًا عندما نجري عمليات على مستوى البِت (&, |, ^، إلخ)، فنحن في الواقع ندمج أو نعدّل هذه البِتّات الفردية.\n\n\n\n\nحتى الآن تحدّثنا فقط عن الأعداد غير السالبة. لكن في C++ (وفي معظم المعالجات الحديثة)، تُخزَّن الأعداد الصحيحة ذات الإشارة في صيغة تُسمّى المتمّم الثنائي (two’s complement).\nالفكرة:\n\nاستخدام البِت الأعلى (أكثر بِت أهمية) كبِت إشارة.\n\nلنفرض أن لدينا أعدادًا صحيحة موقّعة مكوّنة من 8 بِتّات:\n\nBit position:  7  6  5  4   3  2  1  0\nValue:       -128 64 32 16  8  4  2  1\n\nمدى الأعداد ذات الإشارة على 8 بِتّات هو:\n\n-128 ... +127\n\n\n\nالأعداد الموجبة (والصفر) تكون كما هي في النظام الثنائي العادي:\n\n00000101 = 5\n00000000 = 0\n00001010 = 10\n\n\n\n\nللحصول على -x في نظام المتمّم الثنائي:\n\nنكتب x بالثنائي.\nنقلب كل البِتّات (0 -&gt; 1، 1 -&gt; 0).\nنضيف 1.\n\nمثال: تمثيل -5 على 8 بِتّات:\n\n+5        = 00000101\nflip      = 11111010\n+ 1       = 11111011  = -5\n\nفحص -1:\n\n+1        = 00000001\nflip      = 11111110\n+ 1       = 11111111  = -1\n\nإذًا:\n\n11111111 = -1\n11111011 = -5\n10000000 = -128\n\n\n\n\nباستخدام المتمّم الثنائي:\n\nجمع الأعداد الثنائية العادي يعمل أيضًا مع الأعداد السالبة دون تغيير.\nلا يوجد سوى تمثيل واحد للصفر.\nعملية الطرح يمكن تنفيذها كـ a + (-b) فقط.\n\n\n\n\nبالنسبة للأنواع غير الموقّعة (unsigned)، فإن &gt;&gt; يقوم دائمًا بإزاحة البِتّات لليمين مع إدخال بِتّات 0 من اليسار.\nأما للأنواع الموقّعة، فمعظم المترجمات تقوم بإزاحة حسابية لليمين (arithmetic right shift):\n\nحيث يتم نسخ بِت الإشارة (أعلى بِت)، وبالتالي تظل الأعداد السالبة سالبة أثناء الإزاحة.\n\nمثال (مع افتراض الإزاحة الحسابية):\n\nx  = -4   -&gt; 11111100 (8-bit view)\nx &gt;&gt; 1    -&gt; 11111110 (still negative: -2)\n\nلهذا السبب، عندما نهتم بالبِتّات الخام فقط، يكون من الأكثر أمانًا غالبًا استخدام الأنواع غير الموقّعة مثل uint32_t وunsigned long long، إلخ.\n\n\n\n\nكل هذه العوامل تعمل على الأنواع الصحيحة (int, long long، إلخ):\n\n\n\n\n\n\n\n\n\nالعامل\nالاسم\nما يفعله على مستوى البِتّات\n\n\n\n\n\n&\nAND\nيساوي 1 إذا كان كلا البِتّين 1، وإلا 0\n\n\n\n|\nOR\nيساوي 1 إذا كان على الأقل أحد البِتّين 1، وإلا 0\n\n\n\n^\nXOR\nيساوي 1 إذا كان البِتّان مختلفين، وإلا 0\n\n\n\n~\nNOT / complement\nيقلب كل البِتّات (1 → 0، 0 → 1)\n\n\n\n&lt;&lt;\nإزاحة لليسار\nيزيح البِتّات لليسار (يشبه الضرب بقوى العدد 2)\n\n\n\n&gt;&gt;\nإزاحة لليمين\nيزيح البِتّات لليمين (يشبه القسمة على قوى العدد 2)\n\n\n\n\n\n\n\nلنستخدم أعدادًا صغيرة ونفترض أنها مكوّنة من 8 بِتّات لزيادة الوضوح:\n\na = 6   -&gt; 00000110\nb = 10  -&gt; 00001010\n\n\n\n\na & b   -&gt; 00000110\n           00001010\n           --------\n           00000010  = 2\n\n\n\n\n\na | b   -&gt; 00000110\n           00001010\n           --------\n           00001110  = 14\n\n\n\n\n\na ^ b   -&gt; 00000110\n           00001010\n           --------\n           00001100  = 12   (bits that are different become 1)\n\n\n\n\n\n~a      -&gt; 11111001 (على 8 بِتّات، لكن في C++ الحقيقية تُطبَّق العملية على عرض النوع الكامل للعدد)\n\n\n\n\n\na &lt;&lt; 1  -&gt; 00001100  = 12   (6 * 2)\na &lt;&lt; 2  -&gt; 00011000  = 24   (6 * 4)\n\nb &gt;&gt; 1  -&gt; 00000101  = 5    (10 / 2)\nb &gt;&gt; 2  -&gt; 00000010  = 2    (10 / 4, integer division)\n\n\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid printBits(int x) {\n    for (int i = 7; i &gt;= 0; i--) {\n        cout &lt;&lt; ((x &gt;&gt; i) & 1);\n    }\n}\n\nint main() {\n    int a = 6;   // 00000110\n    int b = 10;  // 00001010\n\n    cout &lt;&lt; \"a = \"; printBits(a); cout &lt;&lt; \" (\" &lt;&lt; a &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"b = \"; printBits(b); cout &lt;&lt; \" (\" &lt;&lt; b &lt;&lt; \")\\n\\n\";\n\n    cout &lt;&lt; \"a & b = \"; printBits(a & b); cout &lt;&lt; \" (\" &lt;&lt; (a & b) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"a | b = \"; printBits(a | b); cout &lt;&lt; \" (\" &lt;&lt; (a | b) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"a ^ b = \"; printBits(a ^ b); cout &lt;&lt; \" (\" &lt;&lt; (a ^ b) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"~a    = \"; printBits((unsigned char)~a); cout &lt;&lt; \" (only low 8 bits)\\n\";\n\n    cout &lt;&lt; \"a &lt;&lt; 1 = \"; printBits(a &lt;&lt; 1); cout &lt;&lt; \" (\" &lt;&lt; (a &lt;&lt; 1) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"b &gt;&gt; 1 = \"; printBits(b &gt;&gt; 1); cout &lt;&lt; \" (\" &lt;&lt; (b &gt;&gt; 1) &lt;&lt; \")\\n\";\n}\n\nتقوم الدالة printBits بالمرور على جميع مواضع البِتّات i (من 7 إلى 0)، وتنفّذ x &gt;&gt; i، أي تُزِيح قيمة x بمقدار i خانة إلى اليمين. هذا يجعل البِت الموجود في الموضع i ينتقل إلى أقصى اليمين. بعدها نأخذ:\n& 1\nأي نُجري عملية AND مع 00000001، والتي تؤدي إلى الإبقاء على البِت الأيمن فقط وإلغاء باقي البِتّات. إذًا مجموع العمليتين (x &gt;&gt; i) & 1 هو استخراج البِت الموجود في الموضع i وعرضه على الشاشة.",
    "crumbs": [
      "المرحلة 3",
      "C++",
      "العمليات على مستوى البِت (Bitwise Operations)"
    ]
  },
  {
    "objectID": "b2/cpp/bitwise-operations.html#الأعداد-الثنائية-binary-numbers",
    "href": "b2/cpp/bitwise-operations.html#الأعداد-الثنائية-binary-numbers",
    "title": "العمليات على مستوى البِت (Bitwise Operations)",
    "section": "",
    "text": "تقوم الحواسيب بتخزين الأعداد الصحيحة في صورة ثنائية — باستخدام 0 و1 فقط. نقول إن البِت مُعيَّن (set) إذا كانت قيمته 1. كل موضع (بِت) يمثّل قوة من قوى العدد 2:\n\nBit position:  7  6  5  4  3  2  1  0\nValue:       128 64 32 16  8  4  2  1\n\nللحصول على قيمة عدد ثنائي، نقوم بجمع قوى العدد 2 في الأماكن التي يكون فيها البِت مساويًا لـ1.\n\n\n\n00000110  =  4 + 2       = 6\n00001010  =  8 + 2       = 10\n00001100  =  8 + 4       = 12\n00000001  =  1           = 1\n00000000  =  0           = 0\n\nإذًا عندما نجري عمليات على مستوى البِت (&, |, ^، إلخ)، فنحن في الواقع ندمج أو نعدّل هذه البِتّات الفردية.",
    "crumbs": [
      "المرحلة 3",
      "C++",
      "العمليات على مستوى البِت (Bitwise Operations)"
    ]
  },
  {
    "objectID": "b2/cpp/bitwise-operations.html#المتمم-الثنائي-twos-complement-والأعداد-السالبة",
    "href": "b2/cpp/bitwise-operations.html#المتمم-الثنائي-twos-complement-والأعداد-السالبة",
    "title": "العمليات على مستوى البِت (Bitwise Operations)",
    "section": "",
    "text": "حتى الآن تحدّثنا فقط عن الأعداد غير السالبة. لكن في C++ (وفي معظم المعالجات الحديثة)، تُخزَّن الأعداد الصحيحة ذات الإشارة في صيغة تُسمّى المتمّم الثنائي (two’s complement).\nالفكرة:\n\nاستخدام البِت الأعلى (أكثر بِت أهمية) كبِت إشارة.\n\nلنفرض أن لدينا أعدادًا صحيحة موقّعة مكوّنة من 8 بِتّات:\n\nBit position:  7  6  5  4   3  2  1  0\nValue:       -128 64 32 16  8  4  2  1\n\nمدى الأعداد ذات الإشارة على 8 بِتّات هو:\n\n-128 ... +127\n\n\n\nالأعداد الموجبة (والصفر) تكون كما هي في النظام الثنائي العادي:\n\n00000101 = 5\n00000000 = 0\n00001010 = 10\n\n\n\n\nللحصول على -x في نظام المتمّم الثنائي:\n\nنكتب x بالثنائي.\nنقلب كل البِتّات (0 -&gt; 1، 1 -&gt; 0).\nنضيف 1.\n\nمثال: تمثيل -5 على 8 بِتّات:\n\n+5        = 00000101\nflip      = 11111010\n+ 1       = 11111011  = -5\n\nفحص -1:\n\n+1        = 00000001\nflip      = 11111110\n+ 1       = 11111111  = -1\n\nإذًا:\n\n11111111 = -1\n11111011 = -5\n10000000 = -128\n\n\n\n\nباستخدام المتمّم الثنائي:\n\nجمع الأعداد الثنائية العادي يعمل أيضًا مع الأعداد السالبة دون تغيير.\nلا يوجد سوى تمثيل واحد للصفر.\nعملية الطرح يمكن تنفيذها كـ a + (-b) فقط.\n\n\n\n\nبالنسبة للأنواع غير الموقّعة (unsigned)، فإن &gt;&gt; يقوم دائمًا بإزاحة البِتّات لليمين مع إدخال بِتّات 0 من اليسار.\nأما للأنواع الموقّعة، فمعظم المترجمات تقوم بإزاحة حسابية لليمين (arithmetic right shift):\n\nحيث يتم نسخ بِت الإشارة (أعلى بِت)، وبالتالي تظل الأعداد السالبة سالبة أثناء الإزاحة.\n\nمثال (مع افتراض الإزاحة الحسابية):\n\nx  = -4   -&gt; 11111100 (8-bit view)\nx &gt;&gt; 1    -&gt; 11111110 (still negative: -2)\n\nلهذا السبب، عندما نهتم بالبِتّات الخام فقط، يكون من الأكثر أمانًا غالبًا استخدام الأنواع غير الموقّعة مثل uint32_t وunsigned long long، إلخ.",
    "crumbs": [
      "المرحلة 3",
      "C++",
      "العمليات على مستوى البِت (Bitwise Operations)"
    ]
  },
  {
    "objectID": "b2/cpp/bitwise-operations.html#أهم-العوامل-operators-على-مستوى-البت",
    "href": "b2/cpp/bitwise-operations.html#أهم-العوامل-operators-على-مستوى-البت",
    "title": "العمليات على مستوى البِت (Bitwise Operations)",
    "section": "",
    "text": "كل هذه العوامل تعمل على الأنواع الصحيحة (int, long long، إلخ):\n\n\n\n\n\n\n\n\n\nالعامل\nالاسم\nما يفعله على مستوى البِتّات\n\n\n\n\n\n&\nAND\nيساوي 1 إذا كان كلا البِتّين 1، وإلا 0\n\n\n\n|\nOR\nيساوي 1 إذا كان على الأقل أحد البِتّين 1، وإلا 0\n\n\n\n^\nXOR\nيساوي 1 إذا كان البِتّان مختلفين، وإلا 0\n\n\n\n~\nNOT / complement\nيقلب كل البِتّات (1 → 0، 0 → 1)\n\n\n\n&lt;&lt;\nإزاحة لليسار\nيزيح البِتّات لليسار (يشبه الضرب بقوى العدد 2)\n\n\n\n&gt;&gt;\nإزاحة لليمين\nيزيح البِتّات لليمين (يشبه القسمة على قوى العدد 2)",
    "crumbs": [
      "المرحلة 3",
      "C++",
      "العمليات على مستوى البِت (Bitwise Operations)"
    ]
  },
  {
    "objectID": "b2/cpp/bitwise-operations.html#رؤية-العمليات-على-مستوى-البت-في-صورة-ثنائية",
    "href": "b2/cpp/bitwise-operations.html#رؤية-العمليات-على-مستوى-البت-في-صورة-ثنائية",
    "title": "العمليات على مستوى البِت (Bitwise Operations)",
    "section": "",
    "text": "لنستخدم أعدادًا صغيرة ونفترض أنها مكوّنة من 8 بِتّات لزيادة الوضوح:\n\na = 6   -&gt; 00000110\nb = 10  -&gt; 00001010\n\n\n\n\na & b   -&gt; 00000110\n           00001010\n           --------\n           00000010  = 2\n\n\n\n\n\na | b   -&gt; 00000110\n           00001010\n           --------\n           00001110  = 14\n\n\n\n\n\na ^ b   -&gt; 00000110\n           00001010\n           --------\n           00001100  = 12   (bits that are different become 1)\n\n\n\n\n\n~a      -&gt; 11111001 (على 8 بِتّات، لكن في C++ الحقيقية تُطبَّق العملية على عرض النوع الكامل للعدد)\n\n\n\n\n\na &lt;&lt; 1  -&gt; 00001100  = 12   (6 * 2)\na &lt;&lt; 2  -&gt; 00011000  = 24   (6 * 4)\n\nb &gt;&gt; 1  -&gt; 00000101  = 5    (10 / 2)\nb &gt;&gt; 2  -&gt; 00000010  = 2    (10 / 4, integer division)",
    "crumbs": [
      "المرحلة 3",
      "C++",
      "العمليات على مستوى البِت (Bitwise Operations)"
    ]
  },
  {
    "objectID": "b2/cpp/bitwise-operations.html#مثال-بسيط-في-c",
    "href": "b2/cpp/bitwise-operations.html#مثال-بسيط-في-c",
    "title": "العمليات على مستوى البِت (Bitwise Operations)",
    "section": "",
    "text": "#include &lt;iostream&gt;\nusing namespace std;\n\nvoid printBits(int x) {\n    for (int i = 7; i &gt;= 0; i--) {\n        cout &lt;&lt; ((x &gt;&gt; i) & 1);\n    }\n}\n\nint main() {\n    int a = 6;   // 00000110\n    int b = 10;  // 00001010\n\n    cout &lt;&lt; \"a = \"; printBits(a); cout &lt;&lt; \" (\" &lt;&lt; a &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"b = \"; printBits(b); cout &lt;&lt; \" (\" &lt;&lt; b &lt;&lt; \")\\n\\n\";\n\n    cout &lt;&lt; \"a & b = \"; printBits(a & b); cout &lt;&lt; \" (\" &lt;&lt; (a & b) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"a | b = \"; printBits(a | b); cout &lt;&lt; \" (\" &lt;&lt; (a | b) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"a ^ b = \"; printBits(a ^ b); cout &lt;&lt; \" (\" &lt;&lt; (a ^ b) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"~a    = \"; printBits((unsigned char)~a); cout &lt;&lt; \" (only low 8 bits)\\n\";\n\n    cout &lt;&lt; \"a &lt;&lt; 1 = \"; printBits(a &lt;&lt; 1); cout &lt;&lt; \" (\" &lt;&lt; (a &lt;&lt; 1) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"b &gt;&gt; 1 = \"; printBits(b &gt;&gt; 1); cout &lt;&lt; \" (\" &lt;&lt; (b &gt;&gt; 1) &lt;&lt; \")\\n\";\n}\n\nتقوم الدالة printBits بالمرور على جميع مواضع البِتّات i (من 7 إلى 0)، وتنفّذ x &gt;&gt; i، أي تُزِيح قيمة x بمقدار i خانة إلى اليمين. هذا يجعل البِت الموجود في الموضع i ينتقل إلى أقصى اليمين. بعدها نأخذ:\n& 1\nأي نُجري عملية AND مع 00000001، والتي تؤدي إلى الإبقاء على البِت الأيمن فقط وإلغاء باقي البِتّات. إذًا مجموع العمليتين (x &gt;&gt; i) & 1 هو استخراج البِت الموجود في الموضع i وعرضه على الشاشة.",
    "crumbs": [
      "المرحلة 3",
      "C++",
      "العمليات على مستوى البِت (Bitwise Operations)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html",
    "href": "b2/dynamic-programming.html",
    "title": "البرمجة الديناميكية (Dynamic Programming - DP)",
    "section": "",
    "text": "البرمجة الديناميكية (DP) هي طريقة لحل المسائل التي:\n\nتتكرر فيها نفس المسائل الفرعية عدة مرات، و\nيمكن بناء حل المسألة الكبيرة من حلول مسائل أصغر.\n\nالفكرة الأساسية:\nلا تعيد حساب نفس الشيء مرارًا وتكرارًا. بدلًا من ذلك، خزّن (memoize) النتائج في مصفوفة أو خريطة (array أو map) وأعد استخدامها.\n\n\n\nنعرّف متتالية فيبوناتشي كالتالي:\n\nF(0) = 0\nF(1) = 1\nF(n) = F(n-1) + F(n-2) عندما n ≥ 2\n\n\n\n\nint fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    return fib(n - 1) + fib(n - 2);\n}\n\nما المشكلة هنا؟\n\nfib(5) تستدعي fib(4) و fib(3)\nfib(4) تستدعي fib(3) و fib(2)\nالدالة fib(3) مثلًا تُستدعى مرات كثيرة مكررة\n\nعدد الاستدعاءات يصبح أُسّيًا تقريبًا: الزمن ≈ O(2^n)، وهذا بطيء جدًّا للقيم الكبيرة من n.\n\n\n\n\n\nننشئ مصفوفة dp[] بحيث:\n\ndp[n] تخزن قيمة fib(n) بعد حسابها مرة واحدة.\n\nقبل حساب fib(n) نتحقق أولًا: هل dp[n] محسوبة مسبقًا أم لا.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;long long&gt; dp;\n\nlong long fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    if (dp[n] != -1) return dp[n]; // already computed\n\n    dp[n] = fib(n - 1) + fib(n - 2);\n    return dp[n];\n}\n\nint main() {\n    int n = 50;\n    dp.assign(n + 1, -1);\n\n    cout &lt;&lt; \"F(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; fib(n) &lt;&lt; \"\\n\";\n}\n\nبهذا الشكل، كل fib(k) تُحسب مرة واحدة فقط، وأي استدعاء لاحق لنفس k يعيد القيمة المخزنة بدلًا من إعادة الحساب، فيصبح الزمن O(n) بدلًا من O(2^n).\n\n\n\n\nنستخدم إطار SRTBOT لتنظيم التفكير في أي مسألة برمجة ديناميكية.\n\n\nماذا تمثّل dp[i]؟\n\ndp[i] = F(i)، أي عدد فيبوناتشي رقم i.\n\n\n\n\n\nكيف نبني الحالة الكبيرة من حالات أصغر؟\n\ndp[i] = dp[i-1] + dp[i-2] عندما i ≥ 2\n\n\n\n\n\nللوصول إلى dp[i] ننتقل من الحالتين:\n\ndp[i-1]\nو dp[i-2]\n\nأي أن dp[i] يعتمد على هاتين الحالتين فقط.\n\n\n\n\nنحدد أول قيمتين:\n\ndp[0] = 0\ndp[1] = 1\n\nبدون هذه القيم لا يمكننا بدء الحساب.\n\n\n\n\nفي الأسلوب من أسفل لأعلى (Bottom-Up)، نحسب القيم من الأصغر إلى الأكبر:\n\nfor (int i = 2; i &lt;= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n}\n\nأي من 0 ← 1 ← 2 ← ... ← n.\n\n\n\n\n\nالزمن: نحسب كل dp[i] مرة واحدة → O(n)\nالذاكرة: نخزّن dp[0..n] → O(n) ويمكن تقليلها إلى O(1) إذا احتفظنا بآخر قيمتين فقط بدل المصفوفة كاملة.\n\n\n\n\n\n\nالمسألة:\nمعطاة مصفوفة cost[0..n-1] حيث cost[i] هي الكلفة التي تدفعها عند الوقوف على الموقع i.\nأنت تبدأ قبل المصفوفة وتريد الوصول إلى بعد آخر عنصر (الموقع n). من الموقع i يمكنك الانتقال إلى:\n\ni + 1\nأو i + 2\n\nويمكنك أن تبدأ من 0 أو من 1.\nالهدف: إيجاد أقل كلفة كلية للوصول إلى الموقع n.\nمثال:\n\ncost = [1, 100, 1, 1]\n\nPossible ways:\n\nStart at 0:\n  0 -&gt; 2 -&gt; n\n  cost = cost[0] + cost[2] = 1 + 1 = 2\n\nStart at 1:\n  1 -&gt; 3 -&gt; n\n  cost = 100 + 1 = 101\n\nAnswer = 2\n\n\n\n\nنعرّف دالة:\n\nsolve(i) = أقل كلفة للوصول من الموقع i إلى النهاية (الموقع n).\n\nمن i:\n\nندفع cost[i]،\nثم نختار الذهاب إلى i+1 أو i+2.\n\n\nint n;\nvector&lt;int&gt; cost;\n\nint solve(int i) {\n    if (i &gt;= n) return 0;\n\n    int take1 = solve(i + 1);\n    int take2 = solve(i + 2);\n    return cost[i] + min(take1, take2);\n}\n\nint main() {\n    cost = {1, 100, 1, 1};\n    n = cost.size();\n\n    int ans = min(solve(0), solve(1));  // can start from 0 or 1\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n}\n\nلماذا هذا الحل بطيء؟\n\nsolve(i) تستدعي solve(i+1) و solve(i+2).\nنفس القيمة لـ i تُحسب مرات عديدة (مسائل فرعية متداخلة ومتكررة).\nالزمن يصبح تقريبًا O(2^n).\n\n\n\n\n\n\nنستخدم مصفوفة dp[i] لتخزين أقل كلفة من الموقع i إلى النهاية:\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint n;\nvector&lt;int&gt; cost;\nvector&lt;int&gt; dp;\n\nint solve(int i) {\n    if (i &gt;= n) return 0;\n\n    if (dp[i] != -1) return dp[i]; // already computed\n\n    int take1 = solve(i + 1);\n    int take2 = solve(i + 2);\n    dp[i] = cost[i] + min(take1, take2);\n    return dp[i];\n}\n\nint main() {\n    cost = {1, 100, 1, 1};\n    n = cost.size();\n    dp.assign(n, -1);\n\n    int ans = min(solve(0), solve(1));\n    cout &lt;&lt; \"Minimum cost = \" &lt;&lt; ans &lt;&lt; \"\\n\";\n}\n\nالآن:\n\nكل solve(i) تُحسب مرة واحدة فقط.\nالزمن الكلي يصبح O(n) بدلًا من زمن أُسّي.\n\n\n\n\n\nيمكننا أيضًا حل نفس المسألة بشكل تكراري من النهاية إلى البداية.\nنعرّف:\n\ndp[i] = أقل كلفة للانتقال من الموقع i إلى النهاية.\n\nالقواعد:\n\nإذا كان i &gt;= n → الكلفة 0.\nإذا كان i &lt; n:\n\ndp[i] = cost[i] + min(dp[i+1], dp[i+2])\n\n\nغالبًا نستخدم مصفوفة بحجم n+2 لتفادي مشاكل الخروج عن الحدود.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; cost = {1, 100, 1, 1};\n    int n = cost.size();\n\n    vector&lt;int&gt; dp(n + 2, 0); // dp[n] and dp[n+1] = 0 by default\n\n    for (int i = n - 1; i &gt;= 0; i--) {\n        dp[i] = cost[i] + min(dp[i + 1], dp[i + 2]);\n    }\n\n    int ans = min(dp[0], dp[1]); // can start from index 0 or 1\n    cout &lt;&lt; \"Minimum cost = \" &lt;&lt; ans &lt;&lt; \"\\n\";\n}\n\n\n\n\n\n\n\n\ndp[i] = أقل كلفة إجمالية للانتقال من الموقع i حتى الموقع n (أي الوصول أو تجاوز نهاية المصفوفة).\n\n\n\n\n\nمن i:\n\nندفع cost[i]\nثم نقفز إلى i+1 أو i+2\n\nإذًا:\n\ndp[i] = cost[i] + min(dp[i+1], dp[i+2])\n\n\n\n\n\nمن الحالة i الانتقالات الممكنة هي:\n\ni → i+1\ni → i+2\n\nهذه هي جميع الحواف في مخطط الـ DP لهذه المسألة.\n\n\n\n\nنضع:\n\ndp[n] = 0 (وصلنا/تجاوزنا النهاية، لا كلفة إضافية)\ndp[n+1] = 0 (حماية عند استخدام dp[i+2] عندما i = n-1)\n\nوفي النسخة العودية:\n\nإذا كان i &gt;= n نرجع 0.\n\n\n\n\n\nفي Bottom-Up:\n\nنعالج i من n-1 نزولًا إلى 0، بحيث تكون:\n\ndp[i+1] و dp[i+2] محسوبتين مسبقًا عند حساب dp[i].\n\n\n\nfor (int i = n - 1; i &gt;= 0; i--) {\n    dp[i] = cost[i] + min(dp[i + 1], dp[i + 2]);\n}\n\n\n\n\n\n\nالزمن: نحسب dp[i] مرة واحدة لكل i في [0..n-1]، وكل خطوة في O(1) → المجموع O(n).\nالذاكرة: نستخدم مصفوفة dp بحجم n+2 → O(n) (ويمكن تقليلها إلى O(1) بالاكتفاء بآخر قيمتين فقط).\n\n\n\n\n\n\nغالبًا تظهر البرمجة الديناميكية عندما:\n\nتستطيع كتابة حل عودي (Recursive) يقوم بـ:\n\nتركيب الإجابة من حلول مسائل فرعية أصغر،\nلكنه يعيد حساب نفس المسائل الفرعية مرات عديدة.\n\nثم تقوم بـ:\n\nتعريف حالة (dp[...])،\nاشتقاق العلاقة العودية (Recurrence)،\nإضافة التذكار (Memoization) في أسلوب Top-Down، أو ملء جدول في أسلوب Bottom-Up.\n\n\nوإطار SRTBOT يساعدك على تنظيم تفكيرك:\n\nState → Recurrence → Transitions → Base cases → Order of computation → Time/space complexity",
    "crumbs": [
      "المرحلة 3",
      "البرمجة الديناميكية (Dynamic Programming - DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#مثال-تمهيدي-أعداد-فيبوناتشي",
    "href": "b2/dynamic-programming.html#مثال-تمهيدي-أعداد-فيبوناتشي",
    "title": "البرمجة الديناميكية (Dynamic Programming - DP)",
    "section": "",
    "text": "نعرّف متتالية فيبوناتشي كالتالي:\n\nF(0) = 0\nF(1) = 1\nF(n) = F(n-1) + F(n-2) عندما n ≥ 2\n\n\n\n\nint fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    return fib(n - 1) + fib(n - 2);\n}\n\nما المشكلة هنا؟\n\nfib(5) تستدعي fib(4) و fib(3)\nfib(4) تستدعي fib(3) و fib(2)\nالدالة fib(3) مثلًا تُستدعى مرات كثيرة مكررة\n\nعدد الاستدعاءات يصبح أُسّيًا تقريبًا: الزمن ≈ O(2^n)، وهذا بطيء جدًّا للقيم الكبيرة من n.",
    "crumbs": [
      "المرحلة 3",
      "البرمجة الديناميكية (Dynamic Programming - DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#إصلاحها-بالتذكار-memoization-أسلوب-من-أعلى-لأسفل-top-down-dp",
    "href": "b2/dynamic-programming.html#إصلاحها-بالتذكار-memoization-أسلوب-من-أعلى-لأسفل-top-down-dp",
    "title": "البرمجة الديناميكية (Dynamic Programming - DP)",
    "section": "",
    "text": "ننشئ مصفوفة dp[] بحيث:\n\ndp[n] تخزن قيمة fib(n) بعد حسابها مرة واحدة.\n\nقبل حساب fib(n) نتحقق أولًا: هل dp[n] محسوبة مسبقًا أم لا.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;long long&gt; dp;\n\nlong long fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    if (dp[n] != -1) return dp[n]; // already computed\n\n    dp[n] = fib(n - 1) + fib(n - 2);\n    return dp[n];\n}\n\nint main() {\n    int n = 50;\n    dp.assign(n + 1, -1);\n\n    cout &lt;&lt; \"F(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; fib(n) &lt;&lt; \"\\n\";\n}\n\nبهذا الشكل، كل fib(k) تُحسب مرة واحدة فقط، وأي استدعاء لاحق لنفس k يعيد القيمة المخزنة بدلًا من إعادة الحساب، فيصبح الزمن O(n) بدلًا من O(2^n).",
    "crumbs": [
      "المرحلة 3",
      "البرمجة الديناميكية (Dynamic Programming - DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#إطار-srtbot-للـ-dp",
    "href": "b2/dynamic-programming.html#إطار-srtbot-للـ-dp",
    "title": "البرمجة الديناميكية (Dynamic Programming - DP)",
    "section": "",
    "text": "نستخدم إطار SRTBOT لتنظيم التفكير في أي مسألة برمجة ديناميكية.\n\n\nماذا تمثّل dp[i]؟\n\ndp[i] = F(i)، أي عدد فيبوناتشي رقم i.\n\n\n\n\n\nكيف نبني الحالة الكبيرة من حالات أصغر؟\n\ndp[i] = dp[i-1] + dp[i-2] عندما i ≥ 2\n\n\n\n\n\nللوصول إلى dp[i] ننتقل من الحالتين:\n\ndp[i-1]\nو dp[i-2]\n\nأي أن dp[i] يعتمد على هاتين الحالتين فقط.\n\n\n\n\nنحدد أول قيمتين:\n\ndp[0] = 0\ndp[1] = 1\n\nبدون هذه القيم لا يمكننا بدء الحساب.\n\n\n\n\nفي الأسلوب من أسفل لأعلى (Bottom-Up)، نحسب القيم من الأصغر إلى الأكبر:\n\nfor (int i = 2; i &lt;= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n}\n\nأي من 0 ← 1 ← 2 ← ... ← n.\n\n\n\n\n\nالزمن: نحسب كل dp[i] مرة واحدة → O(n)\nالذاكرة: نخزّن dp[0..n] → O(n) ويمكن تقليلها إلى O(1) إذا احتفظنا بآخر قيمتين فقط بدل المصفوفة كاملة.",
    "crumbs": [
      "المرحلة 3",
      "البرمجة الديناميكية (Dynamic Programming - DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#أقل-كلفة-للوصول-إلى-نهاية-المصفوفة",
    "href": "b2/dynamic-programming.html#أقل-كلفة-للوصول-إلى-نهاية-المصفوفة",
    "title": "البرمجة الديناميكية (Dynamic Programming - DP)",
    "section": "",
    "text": "المسألة:\nمعطاة مصفوفة cost[0..n-1] حيث cost[i] هي الكلفة التي تدفعها عند الوقوف على الموقع i.\nأنت تبدأ قبل المصفوفة وتريد الوصول إلى بعد آخر عنصر (الموقع n). من الموقع i يمكنك الانتقال إلى:\n\ni + 1\nأو i + 2\n\nويمكنك أن تبدأ من 0 أو من 1.\nالهدف: إيجاد أقل كلفة كلية للوصول إلى الموقع n.\nمثال:\n\ncost = [1, 100, 1, 1]\n\nPossible ways:\n\nStart at 0:\n  0 -&gt; 2 -&gt; n\n  cost = cost[0] + cost[2] = 1 + 1 = 2\n\nStart at 1:\n  1 -&gt; 3 -&gt; n\n  cost = 100 + 1 = 101\n\nAnswer = 2\n\n\n\n\nنعرّف دالة:\n\nsolve(i) = أقل كلفة للوصول من الموقع i إلى النهاية (الموقع n).\n\nمن i:\n\nندفع cost[i]،\nثم نختار الذهاب إلى i+1 أو i+2.\n\n\nint n;\nvector&lt;int&gt; cost;\n\nint solve(int i) {\n    if (i &gt;= n) return 0;\n\n    int take1 = solve(i + 1);\n    int take2 = solve(i + 2);\n    return cost[i] + min(take1, take2);\n}\n\nint main() {\n    cost = {1, 100, 1, 1};\n    n = cost.size();\n\n    int ans = min(solve(0), solve(1));  // can start from 0 or 1\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n}\n\nلماذا هذا الحل بطيء؟\n\nsolve(i) تستدعي solve(i+1) و solve(i+2).\nنفس القيمة لـ i تُحسب مرات عديدة (مسائل فرعية متداخلة ومتكررة).\nالزمن يصبح تقريبًا O(2^n).",
    "crumbs": [
      "المرحلة 3",
      "البرمجة الديناميكية (Dynamic Programming - DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#إضافة-التذكار-memoization-top-down-dp",
    "href": "b2/dynamic-programming.html#إضافة-التذكار-memoization-top-down-dp",
    "title": "البرمجة الديناميكية (Dynamic Programming - DP)",
    "section": "",
    "text": "نستخدم مصفوفة dp[i] لتخزين أقل كلفة من الموقع i إلى النهاية:\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint n;\nvector&lt;int&gt; cost;\nvector&lt;int&gt; dp;\n\nint solve(int i) {\n    if (i &gt;= n) return 0;\n\n    if (dp[i] != -1) return dp[i]; // already computed\n\n    int take1 = solve(i + 1);\n    int take2 = solve(i + 2);\n    dp[i] = cost[i] + min(take1, take2);\n    return dp[i];\n}\n\nint main() {\n    cost = {1, 100, 1, 1};\n    n = cost.size();\n    dp.assign(n, -1);\n\n    int ans = min(solve(0), solve(1));\n    cout &lt;&lt; \"Minimum cost = \" &lt;&lt; ans &lt;&lt; \"\\n\";\n}\n\nالآن:\n\nكل solve(i) تُحسب مرة واحدة فقط.\nالزمن الكلي يصبح O(n) بدلًا من زمن أُسّي.",
    "crumbs": [
      "المرحلة 3",
      "البرمجة الديناميكية (Dynamic Programming - DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#نسخة-من-أسفل-لأعلى-bottom-up-dp",
    "href": "b2/dynamic-programming.html#نسخة-من-أسفل-لأعلى-bottom-up-dp",
    "title": "البرمجة الديناميكية (Dynamic Programming - DP)",
    "section": "",
    "text": "يمكننا أيضًا حل نفس المسألة بشكل تكراري من النهاية إلى البداية.\nنعرّف:\n\ndp[i] = أقل كلفة للانتقال من الموقع i إلى النهاية.\n\nالقواعد:\n\nإذا كان i &gt;= n → الكلفة 0.\nإذا كان i &lt; n:\n\ndp[i] = cost[i] + min(dp[i+1], dp[i+2])\n\n\nغالبًا نستخدم مصفوفة بحجم n+2 لتفادي مشاكل الخروج عن الحدود.\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; cost = {1, 100, 1, 1};\n    int n = cost.size();\n\n    vector&lt;int&gt; dp(n + 2, 0); // dp[n] and dp[n+1] = 0 by default\n\n    for (int i = n - 1; i &gt;= 0; i--) {\n        dp[i] = cost[i] + min(dp[i + 1], dp[i + 2]);\n    }\n\n    int ans = min(dp[0], dp[1]); // can start from index 0 or 1\n    cout &lt;&lt; \"Minimum cost = \" &lt;&lt; ans &lt;&lt; \"\\n\";\n}",
    "crumbs": [
      "المرحلة 3",
      "البرمجة الديناميكية (Dynamic Programming - DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#srtbot-لمسألة-أقل-كلفة-للوصول-للنهاية",
    "href": "b2/dynamic-programming.html#srtbot-لمسألة-أقل-كلفة-للوصول-للنهاية",
    "title": "البرمجة الديناميكية (Dynamic Programming - DP)",
    "section": "",
    "text": "dp[i] = أقل كلفة إجمالية للانتقال من الموقع i حتى الموقع n (أي الوصول أو تجاوز نهاية المصفوفة).\n\n\n\n\n\nمن i:\n\nندفع cost[i]\nثم نقفز إلى i+1 أو i+2\n\nإذًا:\n\ndp[i] = cost[i] + min(dp[i+1], dp[i+2])\n\n\n\n\n\nمن الحالة i الانتقالات الممكنة هي:\n\ni → i+1\ni → i+2\n\nهذه هي جميع الحواف في مخطط الـ DP لهذه المسألة.\n\n\n\n\nنضع:\n\ndp[n] = 0 (وصلنا/تجاوزنا النهاية، لا كلفة إضافية)\ndp[n+1] = 0 (حماية عند استخدام dp[i+2] عندما i = n-1)\n\nوفي النسخة العودية:\n\nإذا كان i &gt;= n نرجع 0.\n\n\n\n\n\nفي Bottom-Up:\n\nنعالج i من n-1 نزولًا إلى 0، بحيث تكون:\n\ndp[i+1] و dp[i+2] محسوبتين مسبقًا عند حساب dp[i].\n\n\n\nfor (int i = n - 1; i &gt;= 0; i--) {\n    dp[i] = cost[i] + min(dp[i + 1], dp[i + 2]);\n}\n\n\n\n\n\n\nالزمن: نحسب dp[i] مرة واحدة لكل i في [0..n-1]، وكل خطوة في O(1) → المجموع O(n).\nالذاكرة: نستخدم مصفوفة dp بحجم n+2 → O(n) (ويمكن تقليلها إلى O(1) بالاكتفاء بآخر قيمتين فقط).",
    "crumbs": [
      "المرحلة 3",
      "البرمجة الديناميكية (Dynamic Programming - DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#الفكرة-العامة-للـ-dp",
    "href": "b2/dynamic-programming.html#الفكرة-العامة-للـ-dp",
    "title": "البرمجة الديناميكية (Dynamic Programming - DP)",
    "section": "",
    "text": "غالبًا تظهر البرمجة الديناميكية عندما:\n\nتستطيع كتابة حل عودي (Recursive) يقوم بـ:\n\nتركيب الإجابة من حلول مسائل فرعية أصغر،\nلكنه يعيد حساب نفس المسائل الفرعية مرات عديدة.\n\nثم تقوم بـ:\n\nتعريف حالة (dp[...])،\nاشتقاق العلاقة العودية (Recurrence)،\nإضافة التذكار (Memoization) في أسلوب Top-Down، أو ملء جدول في أسلوب Bottom-Up.\n\n\nوإطار SRTBOT يساعدك على تنظيم تفكيرك:\n\nState → Recurrence → Transitions → Base cases → Order of computation → Time/space complexity",
    "crumbs": [
      "المرحلة 3",
      "البرمجة الديناميكية (Dynamic Programming - DP)"
    ]
  },
  {
    "objectID": "b2/problems/dice-combinations.html",
    "href": "b2/problems/dice-combinations.html",
    "title": "",
    "section": "",
    "text": "Dice Combinations\n\nCSES\neasy\n\n\n\nيُعطى لك عدد صحيح \\(n\\). تقوم برمي نرد عادل بستة أوجه (القيم من 1 إلى 6) وتجمع النتائج.\nمهمتك هي حساب عدد الطرق للحصول على مجموع يساوي بالضبط \\(n\\) عن طريق رمي النرد مرة أو أكثر.\nترتيب الرميات مهم. على سبيل المثال، عندما يكون \\(n = 3\\)، فإن التسلسلات الصحيحة هي:\n\n\\(1 + 1 + 1\\)\n\\(1 + 2\\)\n\\(2 + 1\\)\n\\(3\\)\n\nإذًا الجواب هو \\(4\\).\nالإدخال:\n\nعدد صحيح واحد \\(n\\).\n\nالمخرجات:\n\nاطبع عدد الطرق (بتطبيق باقي القسمة على \\(10^9 + 7\\)).\n\nالقيود:\n\n\\(1 \\le n \\le 10^6\\)\n\nمثال:\nالإدخال:\n3\nالمخرجات:\n4\n\n\n\n\n\nSolution\n\nهذه مسألة كلاسيكية في البرمجة الديناميكية أحادية البعد.\nسنستخدم إطار العمل SRTBOT لتصميم الـ DP.\n\n\n\nسنعرّف مصفوفة dp بحيث تمثّل dp[x] عدد الطرق المختلفة للحصول على مجموع يساوي x باستخدام رميات النرد (بترتيب مهم).\nسنملأ قيم dp[x] تصاعديًا من 0 حتى n بناءً على العلاقة العودية.\n\n\n\n\n\n\nنستخدم مصفوفة نسميها dp. لكل عدد صحيح x بين 0 و n:\n\ndp[x] هي عدد الطرق للحصول على مجموع يساوي x باستخدام رميات النرد (مع اعتبار ترتيب الرميات).\n\nفي النهاية نريد قيمة dp[n].\n\n\n\n\nللوصول إلى مجموع x، يمكن أن تكون آخر رمية نرد هي:\n\n1 → كان المجموع السابق x - 1\n2 → كان المجموع السابق x - 2\n…\n6 → كان المجموع السابق x - 6\n\nكل طريقة لصناعة المجموع x تتكوّن من:\n\nطريقة لصناعة x - k ثم رمية نرد تساوي k لبعض k ∈ {1,2,3,4,5,6} (مع شرط أن x - k ≥ 0).\n\nلذلك العلاقة العودية هي:\n \\[\ndp[x] = \\sum_{k=1}^{6} dp[x-k],\n\\] \nمع تجاهل أي حد يكون فيه x - k &lt; 0. كل القيم تُحسب بتطبيق باقي القسمة على \\(10^9 + 7\\).\n\n\n\n\nمن كل حالة x ننظر إلى الحالات السابقة:\n\nالحواف في مخطط الـ DP هي: x ← x-1, x-2, ..., x-6 (طالما أن القيم لا تصبح سالبة).\n\nعمليًا في الكود، لكل x نجمع قيم dp[x-k] لجميع k من 1 إلى 6 بحيث x - k ≥ 0.\n\n\n\n\n\nيوجد بالضبط تسلسل واحد يعطي مجموعًا يساوي صفرًا: التسلسل الفارغ (لا نرمي النرد أبدًا). لذا:\n\ndp[0] = 1.\n\nلأي x &lt; 0 نعامل dp[x] كأنه صفر (لا يوجد أي تسلسل يعطي مجموعًا سالبًا).\n\nجميع قيم dp[x] الأخرى (من 1 حتى n) نحسبها بالعلاقة العودية.\n\n\n\n\nبما أن dp[x] تعتمد فقط على قيم أصغر (dp[x-1] حتى dp[x-6])، فإن الترتيب الطبيعي هو:\n\nنبدأ بـ dp[0].\nثم نحسب:\n\ndp[1], dp[2], ..., dp[n] بهذا الترتيب التصاعدي.\n\n\n\ndp[0] = 1;\nfor (int x = 1; x &lt;= n; x++) {\n    dp[x] = 0;\n    for (int k = 1; k &lt;= 6; k++) {\n        if (x - k &gt;= 0) {\n            dp[x] = (dp[x] + dp[x - k]) % MOD;\n        }\n    }\n}\n\n\n\n\n\n\nلكل x من 1 إلى n، ننظر إلى 6 قيم سابقة كحد أقصى.\nإذن الزمن الكلي:\n\n\\(O(6n) = O(n)\\).\n\nنستخدم مصفوفة dp بحجم n+1:\n\nالذاكرة \\(O(n)\\).\n\n\nوهذا مناسب لقيم \\(n \\le 10^6\\).\n\n\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconst int MOD = 1'000'000'007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin &gt;&gt; n;\n\n    vector&lt;int&gt; dp(n + 1, 0);\n    dp[0] = 1;  // one way to make sum 0: empty sequence\n\n    for (int x = 1; x &lt;= n; x++) {\n        long long ways = 0;\n        for (int k = 1; k &lt;= 6; k++) {\n            if (x - k &gt;= 0) {\n                ways += dp[x - k];\n                if (ways &gt;= MOD) ways -= MOD; // small optimization\n            }\n        }\n        dp[x] = (int)ways;\n    }\n\n    cout &lt;&lt; dp[n] &lt;&lt; '\\n';\n    return 0;\n}\n\n\n\n\n\n\n\n\nCautionالمودولو وأنواع المتغيّرات\n\n\n\n\nيجب دائمًا أخذ النتيجة بتطبيق باقي القسمة على \\(10^9+7\\).\nاستخدم long long أثناء الجمع لتجنّب تجاوز السعة، ثم حوّل النتيجة إلى int.\nيمكن أن تكون مصفوفة dp من نوع vector&lt;int&gt; لأن القيم دائمًا أصغر من MOD.",
    "crumbs": [
      "المرحلة 3",
      "Problems",
      "Dice Combinations"
    ]
  },
  {
    "objectID": "b2/problems/dice-combinations.html#dice-combinations",
    "href": "b2/problems/dice-combinations.html#dice-combinations",
    "title": "",
    "section": "",
    "text": "Dice Combinations\n\nCSES\neasy\n\n\n\nيُعطى لك عدد صحيح \\(n\\). تقوم برمي نرد عادل بستة أوجه (القيم من 1 إلى 6) وتجمع النتائج.\nمهمتك هي حساب عدد الطرق للحصول على مجموع يساوي بالضبط \\(n\\) عن طريق رمي النرد مرة أو أكثر.\nترتيب الرميات مهم. على سبيل المثال، عندما يكون \\(n = 3\\)، فإن التسلسلات الصحيحة هي:\n\n\\(1 + 1 + 1\\)\n\\(1 + 2\\)\n\\(2 + 1\\)\n\\(3\\)\n\nإذًا الجواب هو \\(4\\).\nالإدخال:\n\nعدد صحيح واحد \\(n\\).\n\nالمخرجات:\n\nاطبع عدد الطرق (بتطبيق باقي القسمة على \\(10^9 + 7\\)).\n\nالقيود:\n\n\\(1 \\le n \\le 10^6\\)\n\nمثال:\nالإدخال:\n3\nالمخرجات:\n4",
    "crumbs": [
      "المرحلة 3",
      "Problems",
      "Dice Combinations"
    ]
  },
  {
    "objectID": "b2/rectangular-geometry.html",
    "href": "b2/rectangular-geometry.html",
    "title": "هندسة المستطيلات",
    "section": "",
    "text": "هندسة المستطيلات تتعامل مع المستطيلات التي تكون أضلاعها محاذية لمحاور الإحداثيات. في هذا القسم نركز على الأفكار الأساسية لهذه المستطيلات المحاذية للمحاور.\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nنفترض أن المحور الموجب \\(X\\) يشير لليمين والمحور الموجب \\(Y\\) يشير للأعلى.\n\n\n\n\nيمكن تمثيل المستطيلات بواسطة نقطتين في المستوى الإحداثي، إما الزاويتان العليا اليسرى والسفلى اليمنى أو العليا اليمنى والسفلى اليسرى.\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nفي هذا القسم سنمثل المستطيل باستخدام إحداثيات الزاوية العليا اليمنى و السفلى اليسرى، حيث \\(tr_x\\) و \\(tr_y\\) هي إحداثيات النقطة العليا اليمنى، و \\(bl_x\\) و \\(bl_y\\) هي إحداثيات النقطة السفلى اليسرى.\n\n\n\n\n\n\n\n\\(length\\) هو الطول للمستطيل بينما \\(width\\) هو العرض.\n\\(width = tr_x - bl_x\\)\n\\(length = tr_y - bl_y\\)\n\n\n\nالمساحة (\\(area\\)) للمستطيل هو حاصل ضرب الطول (\\(length\\)) في العرض (\\(width\\)).\n\\(area = length \\cdot width\\)\n\nint area(int bl_x, int bl_y, int tr_x, int tr_y) {\n  int length = tr_y - bl_y;\n  int width = tr_x - bl_x;\n  return length * width;\n}\n\n\n\n\nإذا كان المستطيلان \\(a\\) و \\(b\\) يتقاطعان، يجب أن يتداخلا في كل من البعدين \\(X\\) و \\(Y\\). غالبًا ما يكون من الأسهل التحقق من العكس: تحديد ما إذا كان هناك بعد واحد لا يتقاطعان فيه. إذا لم يتداخلا في أحد البعدين \\(X\\) أو \\(Y\\)، فإن المستطيلان لا يتقاطعان.\nلبعد \\(Y\\):\n\n\\(a_{tr_y} \\le b_{bl_y}\\) أو \\(b_{tr_y} \\le a_{bl_y}\\)\n\nلبعد \\(X\\):\n\n\\(a_{tr_x} \\le b_{bl_x}\\) أو \\(b_{tr_x} \\le a_{bl_x}\\)\n\nإذا تحقق أي من ذلك، المستطيلان لا يتقاطعان، وإلا فإنهما يتقاطعان.\n\nbool are_intersected(int a_tr_x , int a_tr_y, int a_bl_x, int a_bl_y, int b_tr_x , int b_tr_y, int b_bl_x, int b_bl_y) {\n  if(a_tr_y &lt;= b_bl_y || b_tr_y &lt;= a_bl_y || a_tr_x &lt;= b_bl_x || b_tr_x &lt;= a_bl_x) {\n    return false;\n  }\n  else {\n    return true;\n  }\n}\n\n\n\n\nإذا كان مستطيلان \\(a\\) و \\(b\\) يتقاطعان، فإن المستطيل \\(c\\) الذي يمثل التقاطع يكون:\n\\(c_{tr_x} = min(a_{tr_x}, b_{tr_x})\\)\n\\(c_{tr_y} = min(a_{tr_y}, b_{tr_y})\\)\n\\(c_{bl_x} = max(a_{bl_x}, b_{bl_x})\\)\n\\(c_{bl_y} = max(a_{bl_y}, b_{bl_y})\\)\n\n\n\n\nتنطبق هذه الهندسة أيضًا في فضاء أحادي البعد، حيث نعمل مع المحالات بدلاً من المستطيلات. يمثل المجال برقمين، \\(l\\) و \\(r\\)، واللذان يمثلان بداية ونهاية المجال.\n\n\n\n\n\\(length\\) هو المساحة المغطاة بواسطة المجال.\n\\(length = r - l\\)\n\n\n\nلمجالين \\(a\\) و \\(b\\) في بعد واحد، يمكننا التحقق مما إذا لم يتقاطعا. إذا كانت أحد المجالين يقع بالكامل على يسار أو يمين الآخر، فهو لا يتداخل. وإلا، فإن المجالين يتقاطعان:\n\n\\(a_{r} \\le b_{l}\\) أو \\(b_{r} \\le a_{l}\\)\n\n\nbool are_intersected(int a_l , int a_r, int b_l , int b_r) {\n  if(b_l &lt;= a_r || a_l &lt;= b_r) {\n    return false;\n  }\n  else {\n    return true;\n  }\n}\n\n\n\n\nإذا كان المجالين \\(a\\) و \\(b\\) يتقاطعان، فإن المجال \\(c\\) الذي يمثل التقاطع يكون:\n\\(c_{l} = max(a_{l}, b_{r})\\)\n\\(c_{r} = min(a_{l}, b_{tr_y})\\)\n\n\n\n\n\n\n\n\n\n\nFence Painting\n\nUSACO\n\n\n\nلدينا مجالين \\(a\\) و \\(b\\)ويُطلب طباعة المساحة الإجمالية المغطاة من قبل هذين المجالين.\n\n\n\n\n\nSolution\n\nإذا لم يتقاطع المجالين، فإن المساحة المغطاة هي مجموع الطولين. وإلا، فإن الحل يكون مجموع الطولين مطروحًا منه مساحة التقاطع.\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n  // USACO هذين السطرين فقد لأخذ المدخلات وطباعة المخرجات في موقع \n  freopen(\"paint.in\", \"r\", stdin);\n  freopen(\"paint.out\", \"w\", stdout);\n\n  int a_l , a_r, b_l , b_r;\n  \n  cin &gt;&gt; a_l &gt;&gt; a_r &gt;&gt; b_l &gt;&gt; b_r;\n\n  // b و a يمثل التقاطع بين c\n  int c_l = max(a_l, b_l), c_r = min(a_r, b_r);\n\n  int total = (a_r - a_l) + (b_r - b_l);\n  int intersection = (c_r - c_l);\n  \n  // يتقاطعان b و a الآن يجب أن نتحقق ما إذا \n  if(b_l &gt; a_r || a_l &gt; b_r){\n    cout &lt;&lt; total &lt;&lt; \"\\n\";\n  }\n  else{\n    cout &lt;&lt; total - intersection &lt;&lt; \"\\n\";\n  }\n}",
    "crumbs": [
      "المرحلة 3",
      "هندسة المستطيلات"
    ]
  },
  {
    "objectID": "b2/rectangular-geometry.html#تمثيل-المستطيلات",
    "href": "b2/rectangular-geometry.html#تمثيل-المستطيلات",
    "title": "هندسة المستطيلات",
    "section": "",
    "text": "يمكن تمثيل المستطيلات بواسطة نقطتين في المستوى الإحداثي، إما الزاويتان العليا اليسرى والسفلى اليمنى أو العليا اليمنى والسفلى اليسرى.\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nفي هذا القسم سنمثل المستطيل باستخدام إحداثيات الزاوية العليا اليمنى و السفلى اليسرى، حيث \\(tr_x\\) و \\(tr_y\\) هي إحداثيات النقطة العليا اليمنى، و \\(bl_x\\) و \\(bl_y\\) هي إحداثيات النقطة السفلى اليسرى.",
    "crumbs": [
      "المرحلة 3",
      "هندسة المستطيلات"
    ]
  },
  {
    "objectID": "b2/rectangular-geometry.html#المعادلات-الشائعة",
    "href": "b2/rectangular-geometry.html#المعادلات-الشائعة",
    "title": "هندسة المستطيلات",
    "section": "",
    "text": "\\(length\\) هو الطول للمستطيل بينما \\(width\\) هو العرض.\n\\(width = tr_x - bl_x\\)\n\\(length = tr_y - bl_y\\)\n\n\n\nالمساحة (\\(area\\)) للمستطيل هو حاصل ضرب الطول (\\(length\\)) في العرض (\\(width\\)).\n\\(area = length \\cdot width\\)\n\nint area(int bl_x, int bl_y, int tr_x, int tr_y) {\n  int length = tr_y - bl_y;\n  int width = tr_x - bl_x;\n  return length * width;\n}\n\n\n\n\nإذا كان المستطيلان \\(a\\) و \\(b\\) يتقاطعان، يجب أن يتداخلا في كل من البعدين \\(X\\) و \\(Y\\). غالبًا ما يكون من الأسهل التحقق من العكس: تحديد ما إذا كان هناك بعد واحد لا يتقاطعان فيه. إذا لم يتداخلا في أحد البعدين \\(X\\) أو \\(Y\\)، فإن المستطيلان لا يتقاطعان.\nلبعد \\(Y\\):\n\n\\(a_{tr_y} \\le b_{bl_y}\\) أو \\(b_{tr_y} \\le a_{bl_y}\\)\n\nلبعد \\(X\\):\n\n\\(a_{tr_x} \\le b_{bl_x}\\) أو \\(b_{tr_x} \\le a_{bl_x}\\)\n\nإذا تحقق أي من ذلك، المستطيلان لا يتقاطعان، وإلا فإنهما يتقاطعان.\n\nbool are_intersected(int a_tr_x , int a_tr_y, int a_bl_x, int a_bl_y, int b_tr_x , int b_tr_y, int b_bl_x, int b_bl_y) {\n  if(a_tr_y &lt;= b_bl_y || b_tr_y &lt;= a_bl_y || a_tr_x &lt;= b_bl_x || b_tr_x &lt;= a_bl_x) {\n    return false;\n  }\n  else {\n    return true;\n  }\n}\n\n\n\n\nإذا كان مستطيلان \\(a\\) و \\(b\\) يتقاطعان، فإن المستطيل \\(c\\) الذي يمثل التقاطع يكون:\n\\(c_{tr_x} = min(a_{tr_x}, b_{tr_x})\\)\n\\(c_{tr_y} = min(a_{tr_y}, b_{tr_y})\\)\n\\(c_{bl_x} = max(a_{bl_x}, b_{bl_x})\\)\n\\(c_{bl_y} = max(a_{bl_y}, b_{bl_y})\\)",
    "crumbs": [
      "المرحلة 3",
      "هندسة المستطيلات"
    ]
  },
  {
    "objectID": "b2/rectangular-geometry.html#المعادلات-أحادية-البعد",
    "href": "b2/rectangular-geometry.html#المعادلات-أحادية-البعد",
    "title": "هندسة المستطيلات",
    "section": "",
    "text": "تنطبق هذه الهندسة أيضًا في فضاء أحادي البعد، حيث نعمل مع المحالات بدلاً من المستطيلات. يمثل المجال برقمين، \\(l\\) و \\(r\\)، واللذان يمثلان بداية ونهاية المجال.\n\n\n\n\n\\(length\\) هو المساحة المغطاة بواسطة المجال.\n\\(length = r - l\\)\n\n\n\nلمجالين \\(a\\) و \\(b\\) في بعد واحد، يمكننا التحقق مما إذا لم يتقاطعا. إذا كانت أحد المجالين يقع بالكامل على يسار أو يمين الآخر، فهو لا يتداخل. وإلا، فإن المجالين يتقاطعان:\n\n\\(a_{r} \\le b_{l}\\) أو \\(b_{r} \\le a_{l}\\)\n\n\nbool are_intersected(int a_l , int a_r, int b_l , int b_r) {\n  if(b_l &lt;= a_r || a_l &lt;= b_r) {\n    return false;\n  }\n  else {\n    return true;\n  }\n}\n\n\n\n\nإذا كان المجالين \\(a\\) و \\(b\\) يتقاطعان، فإن المجال \\(c\\) الذي يمثل التقاطع يكون:\n\\(c_{l} = max(a_{l}, b_{r})\\)\n\\(c_{r} = min(a_{l}, b_{tr_y})\\)",
    "crumbs": [
      "المرحلة 3",
      "هندسة المستطيلات"
    ]
  },
  {
    "objectID": "b2/rectangular-geometry.html#fence-painting",
    "href": "b2/rectangular-geometry.html#fence-painting",
    "title": "هندسة المستطيلات",
    "section": "",
    "text": "Fence Painting\n\nUSACO\n\n\n\nلدينا مجالين \\(a\\) و \\(b\\)ويُطلب طباعة المساحة الإجمالية المغطاة من قبل هذين المجالين.",
    "crumbs": [
      "المرحلة 3",
      "هندسة المستطيلات"
    ]
  },
  {
    "objectID": "b2/dp-problems/vacation.html",
    "href": "b2/dp-problems/vacation.html",
    "title": "",
    "section": "",
    "text": "Vacation\n\nAtcoder\neasy\n\n\n\nلديك ثلاث مصفوفات \\(a\\)، \\(b\\)، و \\(c\\) من الأعداد الصحيحة، كل منها بطول \\(N\\). في كل موقع \\(i\\) (حيث \\(0 \\le i &lt; N\\)) يجب اختيار عنصر من \\(a_i\\)، \\(b_i\\)، أو \\(c_i\\).\nشرط: لكل موقع \\(i\\) (حيث \\(0 \\le i &lt; N - 1\\))، يجب أن تأتي العناصر المختارة عند المواقع \\(i\\) و \\(i + 1\\) من مصفوفات مختلفة.\nحدد واطبع أكبر مجموع للعناصر المختارة يمكن تحقيقه تحت هذا الشرط.\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nلتبسيط المشكلة، سنمثل المصفوفات الثلاث \\(a\\)، \\(b\\)، و \\(c\\) كمصفوفة ثنائية الأبعاد واحدة \\(d\\) بأبعاد \\(N \\times 3\\).\nالبعد الأول طوله \\(N\\)، والبُعد الثاني طوله \\(3\\)، حيث \\(d_i\\) هو مصفوفة تحتوي القيم [\\(a_i\\), \\(b_i\\), \\(c_i\\)].\n\n\n\n\nSolution\n\nسنحل هذه المشكلة باستخدام البرمجة الديناميكية.\nدعنا نعرف الحالة:\n\\(f(i, type)\\) هو أكبر مجموع ممكن إذا اعتبرنا أول \\(i\\) عنصر وعند الموقع \\(i\\) اخترنا \\(d[i][type]\\).\nبعد ذلك نعرف الانتقال. هناك ثلاث انتقالات مختلفة بناءً على \\(type\\):\n \\(f(i , 0) = max(f(i - 1, 1) , f(i - 1, 2)) + d_{i,0}\\)\n\\(f(i , 1) = max(f(i - 1, 0) , f(i - 1, 2)) + d_{i,1}\\)\n\\(f(i , 2) = max(f(i - 1, 0) , f(i - 1, 1)) + d_{i,2}\\)\n\nالحالة الأساسية:\n\\(f(0, type) = d_{0,type}\\)\nتعقيد المساحة يحدده عدد الحالات، وهو \\(O(N)\\).\nالتعقيد الزمني هو عدد الحالات \\(N\\) مضروبًا في تعقيد كل انتقال \\(O(1)\\)، لذا التعقيد الكلي هو \\(O(N)\\).\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint dp[200000][3];\nint d[200000][3];\n\n\nint f (int i, int type) {\n  \n    if (i == 0) {\n        return d[i][type];\n    }\n\n    if (dp[i][type] != -1) {\n        return dp[i][type];\n    }\n\n  if(type == 0){\n    dp[i][type] = max(f(i - 1, 1), f(i - 1, 2)) + d[i][type];\n  }\n  else if(type == 1){\n    dp[i][type] = max(f(i - 1, 0), f(i - 1, 2)) + d[i][type];\n  }\n  else if(type == 2){\n    dp[i][type] = max(f(i - 1, 0), f(i - 1, 1)) + d[i][type];\n  }\n\n    return dp[i][type];\n}\n\n\nint main() {\n  \n    for (int i = 0; i &lt; 200000; i++) {\n    for (int j = 0; j &lt; 3; j++) {\n          dp[i][j] = -1;\n    }\n    }\n\n    int n;\n    cin &gt;&gt; n;\n\n    for (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; 3; j++) {\n      cin &gt;&gt; d[i][j];\n    }\n    }\n\n    cout &lt;&lt; max(max(f(n - 1, 0), f(n - 1, 1)), f(n - 1, 2)) &lt;&lt; \"\\n\";\n}",
    "crumbs": [
      "المرحلة 3",
      "DP problems",
      "Vacation"
    ]
  },
  {
    "objectID": "b2/dp-problems/vacation.html#vacation",
    "href": "b2/dp-problems/vacation.html#vacation",
    "title": "",
    "section": "",
    "text": "Vacation\n\nAtcoder\neasy\n\n\n\nلديك ثلاث مصفوفات \\(a\\)، \\(b\\)، و \\(c\\) من الأعداد الصحيحة، كل منها بطول \\(N\\). في كل موقع \\(i\\) (حيث \\(0 \\le i &lt; N\\)) يجب اختيار عنصر من \\(a_i\\)، \\(b_i\\)، أو \\(c_i\\).\nشرط: لكل موقع \\(i\\) (حيث \\(0 \\le i &lt; N - 1\\))، يجب أن تأتي العناصر المختارة عند المواقع \\(i\\) و \\(i + 1\\) من مصفوفات مختلفة.\nحدد واطبع أكبر مجموع للعناصر المختارة يمكن تحقيقه تحت هذا الشرط.",
    "crumbs": [
      "المرحلة 3",
      "DP problems",
      "Vacation"
    ]
  },
  {
    "objectID": "b2/generating-subsets-using-bitmasks.html",
    "href": "b2/generating-subsets-using-bitmasks.html",
    "title": "توليد المجموعات الجزئية باستخدام الأقنعة الثنائية",
    "section": "",
    "text": "المجموعة الجزئية لأي مصفوفة هي مجموعة يتم إنشاؤها من بعض عناصر المصفوفة (ربما بدون أي عنصر). على سبيل المثال، بالنسبة للمصفوفة {1, 3, 5, 6, 7}، المجموعات مثل {1, 3}، {3, 5, 7}، و {1, 3, 5, 6, 7} هي مجموعات جزئية من المصفوفة، بينما المجموعات مثل {1, 4}، {2, 7} ليست مجموعات جزئية من المصفوفة.\n\n\nبالنسبة لمصفوفة طولها \\(n\\)، يمكن تمثيل كل مجموعة جزئية باستخدام عدد ثنائي مكون من \\(n\\) بت حيث كل عنصر في المصفوفة لديه بت يقابله في العدد الثنائي. في هذا الترميز، يكون البت قيمته 1 إذا كان العنصر المقابل ضمن المجموعة الجزئية، و0 إذا لم يكن ضمن المجموعة.\nعلى سبيل المثال، المصفوفة {5, 3, 1}. الترميزات الثنائية لمجموعاتها الجزئية هي:\n\n\n\n\n\n\n\n\nمجموعة جزئية من {5, 3, 1}\nالترميز (ثنائي)\nالترميز (عشري)\n\n\n\n\n{}\n000\n0\n\n\n{5}\n001\n1\n\n\n{3}\n010\n2\n\n\n{5, 3}\n011\n3\n\n\n{1}\n100\n4\n\n\n{5, 1}\n101\n5\n\n\n{3, 1}\n110\n6\n\n\n{5, 3, 1}\n111\n7\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nبالنسبة لمصفوفة طولها \\(n\\)، عدد المجموعات الجزئية المختلفة هو \\(2^n\\).\n\n\n\n\n\nيمكننا ملاحظة أنه بالنسبة لمصفوفة طولها \\(n\\)، يمكن ترقيم كل المجموعات الجزئية من 0 إلى \\(2^n - 1\\). باستخدام هذا الترقيم، يمكننا المرور عبر جميع الأعداد الصحيحة من 0 إلى \\(2^n - 1\\) وتوليد كل مجموعة جزئية عن طريق التحقق من البتات.\nعلى سبيل المثال، افترض أننا نريد كتابة برنامج يطبع كل المجموعات الجزئية من المصفوفة a، كل واحدة في سطر منفصل.\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  int n = 3;\n  int a[3] = {5, 3, 1};\n\n  for(int i = 0; i &lt; (1 &lt;&lt; n); i++) {   // 2^n - 1 يمر بجميع الأعداد من 0 إلى\n    cout &lt;&lt; i &lt;&lt; \": \";\n\n    for(int j = 0; j &lt; n; j++) {        // i يتكرر عبر جميع البتات للرقم \n      bool set = (i & (1 &lt;&lt; j)) != 0;   // i قيمته 1 في الرقم  j يتحقق إذا كان البت \n      if(set) {\n        cout &lt;&lt; a[j] &lt;&lt; ' ';\n      }\n    }\n\n    cout &lt;&lt; endl;\n  }\n}\n\nسيطبع هذا البرنامج التالي:\n\n0: \n1: 5 \n2: 3 \n3: 5 3 \n4: 1 \n5: 5 1 \n6: 3 1 \n7: 5 3 1",
    "crumbs": [
      "المرحلة 3",
      "توليد المجموعات الجزئية باستخدام الأقنعة الثنائية"
    ]
  },
  {
    "objectID": "b2/generating-subsets-using-bitmasks.html#ترميز-المجموعات-الجزئية-كأعداد-ثنائية",
    "href": "b2/generating-subsets-using-bitmasks.html#ترميز-المجموعات-الجزئية-كأعداد-ثنائية",
    "title": "توليد المجموعات الجزئية باستخدام الأقنعة الثنائية",
    "section": "",
    "text": "بالنسبة لمصفوفة طولها \\(n\\)، يمكن تمثيل كل مجموعة جزئية باستخدام عدد ثنائي مكون من \\(n\\) بت حيث كل عنصر في المصفوفة لديه بت يقابله في العدد الثنائي. في هذا الترميز، يكون البت قيمته 1 إذا كان العنصر المقابل ضمن المجموعة الجزئية، و0 إذا لم يكن ضمن المجموعة.\nعلى سبيل المثال، المصفوفة {5, 3, 1}. الترميزات الثنائية لمجموعاتها الجزئية هي:\n\n\n\n\n\n\n\n\nمجموعة جزئية من {5, 3, 1}\nالترميز (ثنائي)\nالترميز (عشري)\n\n\n\n\n{}\n000\n0\n\n\n{5}\n001\n1\n\n\n{3}\n010\n2\n\n\n{5, 3}\n011\n3\n\n\n{1}\n100\n4\n\n\n{5, 1}\n101\n5\n\n\n{3, 1}\n110\n6\n\n\n{5, 3, 1}\n111\n7\n\n\n\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nبالنسبة لمصفوفة طولها \\(n\\)، عدد المجموعات الجزئية المختلفة هو \\(2^n\\).",
    "crumbs": [
      "المرحلة 3",
      "توليد المجموعات الجزئية باستخدام الأقنعة الثنائية"
    ]
  },
  {
    "objectID": "b2/generating-subsets-using-bitmasks.html#توليد-المجموعات-الجزئية",
    "href": "b2/generating-subsets-using-bitmasks.html#توليد-المجموعات-الجزئية",
    "title": "توليد المجموعات الجزئية باستخدام الأقنعة الثنائية",
    "section": "",
    "text": "يمكننا ملاحظة أنه بالنسبة لمصفوفة طولها \\(n\\)، يمكن ترقيم كل المجموعات الجزئية من 0 إلى \\(2^n - 1\\). باستخدام هذا الترقيم، يمكننا المرور عبر جميع الأعداد الصحيحة من 0 إلى \\(2^n - 1\\) وتوليد كل مجموعة جزئية عن طريق التحقق من البتات.\nعلى سبيل المثال، افترض أننا نريد كتابة برنامج يطبع كل المجموعات الجزئية من المصفوفة a، كل واحدة في سطر منفصل.\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  int n = 3;\n  int a[3] = {5, 3, 1};\n\n  for(int i = 0; i &lt; (1 &lt;&lt; n); i++) {   // 2^n - 1 يمر بجميع الأعداد من 0 إلى\n    cout &lt;&lt; i &lt;&lt; \": \";\n\n    for(int j = 0; j &lt; n; j++) {        // i يتكرر عبر جميع البتات للرقم \n      bool set = (i & (1 &lt;&lt; j)) != 0;   // i قيمته 1 في الرقم  j يتحقق إذا كان البت \n      if(set) {\n        cout &lt;&lt; a[j] &lt;&lt; ' ';\n      }\n    }\n\n    cout &lt;&lt; endl;\n  }\n}\n\nسيطبع هذا البرنامج التالي:\n\n0: \n1: 5 \n2: 3 \n3: 5 3 \n4: 1 \n5: 5 1 \n6: 3 1 \n7: 5 3 1",
    "crumbs": [
      "المرحلة 3",
      "توليد المجموعات الجزئية باستخدام الأقنعة الثنائية"
    ]
  },
  {
    "objectID": "b3/ds/intro.html",
    "href": "b3/ds/intro.html",
    "title": "هياكل البيانات",
    "section": "",
    "text": "هيكل البيانات هو طريقة لتنظيم وتخزين البيانات داخل حاوية بهدف تحسين الوقت المستخدم والذاكرة المحجوزة لمهام محددة، مثل إدخال العناصر أو الاستعلام عن وجود عنصر أو حذف عناصر.\n\n\n\nهناك عدد من هياكل البيانات التي استخدمناها سابقًا، مثل:\n\nvector: مصفوفة ديناميكية يمكن أن يزداد حجمها أو ينقص.\nset: حاوية لعناصر تتيح الإدخال والحذف والبحث عن عنصر بسرعة، وكل ذلك بزمن \\(O(\\log n)\\).\nmap: حاوية لأزواج (مفتاح وقيمة) تدعم الاسترجاع السريع والإدخال والحذف باستخدام المفتاح، وكل ذلك بزمن \\(O(\\log n)\\).\n\nيتم كتابة هذه هياكل البيانات وتوفيرها من خلال المكتبات الأساسية(Standard Libraries). وقد كنا نستخدمها دون معرفة كيفية كتابتها داخليًا. في هذا القسم سننظر في بعض هياكل البيانات التي سنقوم بكتابتها بأنفسنا ثم نستخدمها في الكود الخاصة بنا.",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "هياكل البيانات"
    ]
  },
  {
    "objectID": "b3/ds/intro.html#التعريف",
    "href": "b3/ds/intro.html#التعريف",
    "title": "هياكل البيانات",
    "section": "",
    "text": "هيكل البيانات هو طريقة لتنظيم وتخزين البيانات داخل حاوية بهدف تحسين الوقت المستخدم والذاكرة المحجوزة لمهام محددة، مثل إدخال العناصر أو الاستعلام عن وجود عنصر أو حذف عناصر.",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "هياكل البيانات"
    ]
  },
  {
    "objectID": "b3/ds/intro.html#مثال",
    "href": "b3/ds/intro.html#مثال",
    "title": "هياكل البيانات",
    "section": "",
    "text": "هناك عدد من هياكل البيانات التي استخدمناها سابقًا، مثل:\n\nvector: مصفوفة ديناميكية يمكن أن يزداد حجمها أو ينقص.\nset: حاوية لعناصر تتيح الإدخال والحذف والبحث عن عنصر بسرعة، وكل ذلك بزمن \\(O(\\log n)\\).\nmap: حاوية لأزواج (مفتاح وقيمة) تدعم الاسترجاع السريع والإدخال والحذف باستخدام المفتاح، وكل ذلك بزمن \\(O(\\log n)\\).\n\nيتم كتابة هذه هياكل البيانات وتوفيرها من خلال المكتبات الأساسية(Standard Libraries). وقد كنا نستخدمها دون معرفة كيفية كتابتها داخليًا. في هذا القسم سننظر في بعض هياكل البيانات التي سنقوم بكتابتها بأنفسنا ثم نستخدمها في الكود الخاصة بنا.",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "هياكل البيانات"
    ]
  },
  {
    "objectID": "b3/ds/sqrt-decomposition.html",
    "href": "b3/ds/sqrt-decomposition.html",
    "title": "تحليل الجذر التربيعي",
    "section": "",
    "text": "تحليل الجذر التربيعي هي تقنية تسمح بحساب استعلامات على مستوى نطاق بزمن \\(O(\\sqrt n)\\)، مما يحسن الأداء مقارنةً بزمن \\(O(n)\\) في المصفوفة العادية.\n\n\n\n\n\n\nNoteملحوظة\n\n\n\nاستعلام على مستوى نطاق هو استعلام يطلب حساب قيمة (مثلًا: المجموع، أو القيمة الصغرى، أو القيمة العظمى) لنطاق من العناصر.\n\n\n\n\nلنعتبر مصفوفة \\(a\\) بطول \\(n\\). لبناء هيكل تحليل الجذر التربيعي، نقوم أولًا بتقسيم \\(a\\) إلى كتل بحجم \\(\\lceil \\sqrt{n} \\rceil\\) (ولنسمِّ هذا الحجم \\(sz\\)). ثم، لكل كتلة، نحسب القيمة المطلوبة ونخزنها في مصفوفة \\(b\\)، حيث يمثّل \\(b_i\\) القيمة المحسوبة للكتلة رقم \\(i\\).\n\n\n\n\n\n\nNoteملحوظة\n\n\n\n\\(\\lceil \\sqrt{n} \\rceil\\) هو \\(\\sqrt n\\) بعد التقريب للأعلى إلى أقرب عدد صحيح.\n\n\nبما أن \\(sz\\) يساوي تقريبًا \\(\\sqrt n\\)، فإن عدد الكتل سيكون تقريبًا \\(\\frac{n}{\\sqrt n}\\) والذي يساوي \\(\\sqrt n\\).\n \\(\\underbrace{a_0, a_1, \\dots, a_{sz-1}}_{b_{0}}, \\underbrace{a_{sz}, a_{sz + 1}, \\dots, a_{2 * sz - 1}}_{b_{1}}, \\dots, \\underbrace{a_{(sz - 1) * sz}, a_{(sz - 1) * sz + 1}, \\dots, a_{n - 1}}_{b_{sz}}\\) \n\n\n\nافترض أننا نريد معالجة استعلام نطاق من \\(l\\) إلى \\(r\\).\nالطريقة البسيطة هي المرور على جميع العناصر من \\(l\\) إلى \\(r\\) وحساب القيمة المطلوبة. يستغرق ذلك زمنًا قدره \\(O(n)\\) في أسوأ الحالات.\nباستخدام هيكل تحليل الجذر التربيعي، نلاحظ أن النطاق \\([l, r]\\) يغطي عادةً عدة كتل بشكل كامل، باستثناء الكتلة الأولى (التي تحتوي على \\(l\\)) والكتلة الأخيرة (التي تحتوي على \\(r\\)).\nللإجابة على الاستعلام بكفاءة، نقوم أولًا بحل الكتلتين المغطاتين جزئيًا كلٌّ على حدة. ثم نمرّ على الكتل المغطاة بالكامل بينهما ونستخدم القيم \\(b_i\\) المحسوبة مسبقًا. هذا يقلل زمن الاستعلام إلى \\(O(\\sqrt{n})\\).\n\n\n\nتطلب بعض المسائل تحديث موقع معيّن \\(j\\) إلى قيمة جديدة \\(v\\). نقوم بتحديث \\(a[j]\\) إلى \\(v\\) بزمن \\(O(1)\\). ثم نعيد حساب قيمة الكتلة التي ينتمي إليها \\(j\\) بزمن \\(O(\\sqrt{n})\\). إذًا التعقيد الكلي للتحديث هو \\(O(\\sqrt{n})\\).\n\n\n\nلنفترض أننا نريد أن نجيب على استعلامات تطلب حساب القيمة العظمى في نطاق. ### الحسابات المسبقة هنا نقوم ببناء الهيكل&lt;\n\nfor (int i = 0; i &lt; n; i++) {\n    b[i / sz] = max(a[i], b[i / sz]); // i/sz ينتمي إلى i عنصر\n}\n\n\n\n\nint queryMax(int l, int r) {\n    int blockL = l / sz;\n    int blockR = r / sz;\n\n    int ans = INT_MIN;\n\n    // حالة خاصة عندما يبدأ النطاق وينتهي في الكتلة نفسها\n    if (blockL == blockR) { \n        for(int i = l; i &lt;= r; i++) {\n            ans = max(ans, a[i]);\n        }\n        return ans;\n    }\n\n    // حساب الكتلة الأولى\n    for (int i = l; i &lt; (blockL + 1) * sz; i++) {\n        ans = max(ans, a[i]);\n    }\n\n    // حساب الكتل البينية\n    for (int i = blockL + 1; i &lt; blockR ; i++) {\n        ans = max(ans, b[i]);\n    }\n\n    // حساب الكتلة الأخيرة\n    for (int i = blockR * sz; i &lt;= r ; i++){\n        ans = max(ans , a[i]);\n    }\n\n    return ans;\n}\n\n\n\n\n\nvoid pointUpdate(int j , int v){\n    int blockJ = j / sz;\n\n    a[j] = v;\n    \n    // b[blockJ] إعادة حساب\n    b[blockJ] = INT_MIN;\n\n    for (int i = blockJ * sz; i &lt; (blockJ + 1) * sz; i++) {\n        b[blockJ] = max(b[blockJ], a[i]);\n    }\n}\n\n\n\n\n\n\n\n\nDynamic Range Minimum Queries\n\nCSES\neasy\n\n\n\nلديك مصفوفة \\(x\\) مكوّنة من \\(n\\) عنصر و \\(q\\) استعلامات. كل استعلام يكون من أحد النوعين التاليين:\n\n“1 \\(k\\) \\(u\\)”: تحديث القيمة في الموقع \\(k\\) إلى \\(u\\).\n“2 \\(a\\) \\(b\\)”: ما هي القيمة الصغرى في النطاق [\\(a\\),\\(b\\)]؟\n\n\n\n\n\n\nSolution\n\nهذه المسألة مشابهة للرنامج السابق، ولكن الآن يُطلب منا حساب القيمة الصغرى. هناك بعض الملاحظات البسيطة التي يجب أخذها بعين الاعتبار:\n\nالمصفوفات معرّفة في النطاق العام ، ولهذا نستخدم MAXN كأكبر قيمة ممكنة لـ \\(n\\).\nفي الاستعلامات، نقوم بكتابة k-- و l-- و r-- لأن المدخلات مرقمة ابتداء من 1، بينما تنفيذنا يستخدم مصفوفات تبدأ من 0.\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;    \n#include &lt;climits&gt;  \n\nusing namespace std;\nconst int MAXN = 200000;\nconst int sz = (int)ceil(sqrt(MAXN));\nint a[MAXN];\nint b[sz]; \n\nint queryMin(int l, int r) {\n    int blockL = l / sz;\n    int blockR = r / sz;\n\n    int ans = INT_MAX;\n\n    if (blockL == blockR) { \n        for(int i = l; i &lt;= r; i++) {\n            ans = min(ans, a[i]);\n        }\n        return ans;\n    }\n\n    for (int i = l; i &lt; (blockL + 1) * sz; i++) {\n        ans = min(ans, a[i]);\n    }\n\n    for (int i = blockL + 1; i &lt; blockR ; i++) {\n        ans = min(ans, b[i]);\n    }\n\n    for (int i = blockR * sz; i &lt;= r ; i++){\n        ans = min(ans , a[i]);\n    }\n\n    return ans;\n}\n\nvoid pointUpdate(int j , int v){\n    int blockJ = j / sz;\n\n    a[j] = v;\n    \n    b[blockJ] = INT_MAX;\n\n    for (int i = blockJ * sz; i &lt; (blockJ + 1) * sz; i++) {\n        b[blockJ] = min(b[blockJ], a[i]);\n    }\n}\n\nint main() {\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q;\n\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; a[i];\n    }\n\n    for (int i = 0 ; i &lt; sz; i++) {\n        b[i] = INT_MAX;\n    }\n\n    for (int i = 0; i &lt; n; i++) {\n        b[i / sz] = min(a[i], b[i / sz]);\n    }\n\n    while (q--){\n        int type;\n        cin &gt;&gt; type;\n\n        if (type == 1){\n            int k , u;\n            cin &gt;&gt; k &gt;&gt; u;\n            k--;\n            pointUpdate(k, u);\n        }\n        else{\n            int l , r;\n            cin &gt;&gt; l &gt;&gt; r;\n            l--; r--;\n            cout &lt;&lt; queryMin(l , r) &lt;&lt; \"\\n\";\n        }\n    }\n}",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "تحليل الجذر التربيعي"
    ]
  },
  {
    "objectID": "b3/ds/sqrt-decomposition.html#هيكل-البيانات",
    "href": "b3/ds/sqrt-decomposition.html#هيكل-البيانات",
    "title": "تحليل الجذر التربيعي",
    "section": "",
    "text": "لنعتبر مصفوفة \\(a\\) بطول \\(n\\). لبناء هيكل تحليل الجذر التربيعي، نقوم أولًا بتقسيم \\(a\\) إلى كتل بحجم \\(\\lceil \\sqrt{n} \\rceil\\) (ولنسمِّ هذا الحجم \\(sz\\)). ثم، لكل كتلة، نحسب القيمة المطلوبة ونخزنها في مصفوفة \\(b\\)، حيث يمثّل \\(b_i\\) القيمة المحسوبة للكتلة رقم \\(i\\).\n\n\n\n\n\n\nNoteملحوظة\n\n\n\n\\(\\lceil \\sqrt{n} \\rceil\\) هو \\(\\sqrt n\\) بعد التقريب للأعلى إلى أقرب عدد صحيح.\n\n\nبما أن \\(sz\\) يساوي تقريبًا \\(\\sqrt n\\)، فإن عدد الكتل سيكون تقريبًا \\(\\frac{n}{\\sqrt n}\\) والذي يساوي \\(\\sqrt n\\).\n \\(\\underbrace{a_0, a_1, \\dots, a_{sz-1}}_{b_{0}}, \\underbrace{a_{sz}, a_{sz + 1}, \\dots, a_{2 * sz - 1}}_{b_{1}}, \\dots, \\underbrace{a_{(sz - 1) * sz}, a_{(sz - 1) * sz + 1}, \\dots, a_{n - 1}}_{b_{sz}}\\)",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "تحليل الجذر التربيعي"
    ]
  },
  {
    "objectID": "b3/ds/sqrt-decomposition.html#حساب-الاستعلامات",
    "href": "b3/ds/sqrt-decomposition.html#حساب-الاستعلامات",
    "title": "تحليل الجذر التربيعي",
    "section": "",
    "text": "افترض أننا نريد معالجة استعلام نطاق من \\(l\\) إلى \\(r\\).\nالطريقة البسيطة هي المرور على جميع العناصر من \\(l\\) إلى \\(r\\) وحساب القيمة المطلوبة. يستغرق ذلك زمنًا قدره \\(O(n)\\) في أسوأ الحالات.\nباستخدام هيكل تحليل الجذر التربيعي، نلاحظ أن النطاق \\([l, r]\\) يغطي عادةً عدة كتل بشكل كامل، باستثناء الكتلة الأولى (التي تحتوي على \\(l\\)) والكتلة الأخيرة (التي تحتوي على \\(r\\)).\nللإجابة على الاستعلام بكفاءة، نقوم أولًا بحل الكتلتين المغطاتين جزئيًا كلٌّ على حدة. ثم نمرّ على الكتل المغطاة بالكامل بينهما ونستخدم القيم \\(b_i\\) المحسوبة مسبقًا. هذا يقلل زمن الاستعلام إلى \\(O(\\sqrt{n})\\).",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "تحليل الجذر التربيعي"
    ]
  },
  {
    "objectID": "b3/ds/sqrt-decomposition.html#تحديث-نقطة",
    "href": "b3/ds/sqrt-decomposition.html#تحديث-نقطة",
    "title": "تحليل الجذر التربيعي",
    "section": "",
    "text": "تطلب بعض المسائل تحديث موقع معيّن \\(j\\) إلى قيمة جديدة \\(v\\). نقوم بتحديث \\(a[j]\\) إلى \\(v\\) بزمن \\(O(1)\\). ثم نعيد حساب قيمة الكتلة التي ينتمي إليها \\(j\\) بزمن \\(O(\\sqrt{n})\\). إذًا التعقيد الكلي للتحديث هو \\(O(\\sqrt{n})\\).",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "تحليل الجذر التربيعي"
    ]
  },
  {
    "objectID": "b3/ds/sqrt-decomposition.html#طريقة-الكتابة",
    "href": "b3/ds/sqrt-decomposition.html#طريقة-الكتابة",
    "title": "تحليل الجذر التربيعي",
    "section": "",
    "text": "لنفترض أننا نريد أن نجيب على استعلامات تطلب حساب القيمة العظمى في نطاق. ### الحسابات المسبقة هنا نقوم ببناء الهيكل&lt;\n\nfor (int i = 0; i &lt; n; i++) {\n    b[i / sz] = max(a[i], b[i / sz]); // i/sz ينتمي إلى i عنصر\n}\n\n\n\n\nint queryMax(int l, int r) {\n    int blockL = l / sz;\n    int blockR = r / sz;\n\n    int ans = INT_MIN;\n\n    // حالة خاصة عندما يبدأ النطاق وينتهي في الكتلة نفسها\n    if (blockL == blockR) { \n        for(int i = l; i &lt;= r; i++) {\n            ans = max(ans, a[i]);\n        }\n        return ans;\n    }\n\n    // حساب الكتلة الأولى\n    for (int i = l; i &lt; (blockL + 1) * sz; i++) {\n        ans = max(ans, a[i]);\n    }\n\n    // حساب الكتل البينية\n    for (int i = blockL + 1; i &lt; blockR ; i++) {\n        ans = max(ans, b[i]);\n    }\n\n    // حساب الكتلة الأخيرة\n    for (int i = blockR * sz; i &lt;= r ; i++){\n        ans = max(ans , a[i]);\n    }\n\n    return ans;\n}\n\n\n\n\n\nvoid pointUpdate(int j , int v){\n    int blockJ = j / sz;\n\n    a[j] = v;\n    \n    // b[blockJ] إعادة حساب\n    b[blockJ] = INT_MIN;\n\n    for (int i = blockJ * sz; i &lt; (blockJ + 1) * sz; i++) {\n        b[blockJ] = max(b[blockJ], a[i]);\n    }\n}",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "تحليل الجذر التربيعي"
    ]
  },
  {
    "objectID": "b3/ds/sqrt-decomposition.html#dynamic-range-minimum-queries",
    "href": "b3/ds/sqrt-decomposition.html#dynamic-range-minimum-queries",
    "title": "تحليل الجذر التربيعي",
    "section": "",
    "text": "Dynamic Range Minimum Queries\n\nCSES\neasy\n\n\n\nلديك مصفوفة \\(x\\) مكوّنة من \\(n\\) عنصر و \\(q\\) استعلامات. كل استعلام يكون من أحد النوعين التاليين:\n\n“1 \\(k\\) \\(u\\)”: تحديث القيمة في الموقع \\(k\\) إلى \\(u\\).\n“2 \\(a\\) \\(b\\)”: ما هي القيمة الصغرى في النطاق [\\(a\\),\\(b\\)]؟",
    "crumbs": [
      "المرحلة 4",
      "Data Structures",
      "تحليل الجذر التربيعي"
    ]
  },
  {
    "objectID": "b3/graphs/bfs.html",
    "href": "b3/graphs/bfs.html",
    "title": "البحث بالعرض على الرسوم البيانية العامة",
    "section": "",
    "text": "خوارزمية BFS (البحث بالعرض) هي اجتياز للرسم البياني مثل DFS، لكنها تستكشف العقد على شكل طبقات حسب المسافة من عقدة البداية.\nBFS فكرتها: “زر كل شيء يبعد خطوة واحدة، ثم خطوتين، ثم ثلاث خطوات…”\n\n\n\nBFS هي الأداة الأساسية لـ:\n\nأقصر مسار في رسم بياني غير موزون (تكلفة كل حرف = 1)\nأقل عدد أحرف من عقدة البداية إلى جميع العقد\nالتحقق من الاتصال / المكونات\n\nالضمان الأساسي:\n\nفي رسم بياني غير موزون، BFS تجد أقصر مسافة (أقل عدد أحرف) من عقدة البداية إلى كل عقدة يمكن الوصول لها.\n\n\n\n\n\nBFS تستخدم طابوراً (queue) حتى تتم معالجة العقد بنفس ترتيب اكتشافها.\nنحافظ على:\n\ndist[v] = أقصر عدد أحرف من البداية إلى v\n(-1 يعني “لم تتم زيارتها بعد”)\n\nالخطوات:\n\nضع عقدة البداية في الطابور، واجعل dist[start] = 0\nاسحب عقدة v من الطابور\nلكل جار to:\n\nإذا كان غير مُزار، اجعل dist[to] = dist[v] + 1\nثم أدخله إلى الطابور\n\n\nبما أن الطابور يعالج الطبقات الأقرب أولاً، فأول مرة تزور فيها عقدة تكون مضمونة عبر أقصر مسار.\n\n\n\n\nنفترض قائمة مجاورات:\n\nint n;\nvector&lt;int&gt; g[n];\n\nBFS من مصدر واحد:\n\nvector&lt;int&gt; dist(n, -1);\nqueue&lt;int&gt; q;\n\nint s = 0;\ndist[s] = 0;\nq.push(s);\n\nwhile (!q.empty()) {\n    int v = q.front(); q.pop();\n    for (int to : g[v]) {\n        if (dist[to] != -1) continue;     // already visited\n        dist[to] = dist[v] + 1;\n        q.push(to);\n    }\n}\n\nالآن dist[v] تكون:\n\n0 لعقدة البداية\n1 للعقد التي تبعد حرفاً واحداً\n2 للعقد التي تبعد حرفين\n…إلخ\n-1 إذا كانت غير قابلة للوصول من s\n\n\n\n\n\nعند تشغيل BFS:\n\nالطابور يحتوي أولاً على جميع العقد ذات المسافة 0\nثم يكبر ليضم جميع العقد ذات المسافة 1\nثم جميع العقد ذات المسافة 2\n…\n\nلذلك إذا تم اكتشاف to من v، فأول مرة تضبط فيها dist[to] لابد أن تكون dist[v] + 1، و v أصلاً في أبكر طبقة ممكنة يمكنها الوصول إليه.\nلهذا السبب BFS تعطي أقصر المسارات في الرسوم البيانية غير الموزونة.\n\n\n\n\nخزن parent[to] عند اكتشاف to.\n\nvector&lt;int&gt; dist(n, -1), parent(n, -1);\nqueue&lt;int&gt; q;\n\nint s = 0;\ndist[s] = 0;\nq.push(s);\n\nwhile (!q.empty()) {\n    int v = q.front(); q.pop();\n    for (int to : g[v]) {\n        if (dist[to] != -1) continue;\n        dist[to] = dist[v] + 1;\n        parent[to] = v;\n        q.push(to);\n    }\n}\n\nإعادة بناء المسار من s إلى t:\n\nvector&lt;int&gt; path;\nint t = 7;\nif (dist[t] != -1) {\n    for (int v = t; v != -1; v = parent[v]) path.push_back(v);\n    reverse(path.begin(), path.end());\n}\n\n\n\n\n\n\nDFS ممتازة لـ:\n\nاستكشاف البنية\nكشف الدورات\nالمكونات المتصلة\nالفرز الطوبولوجي (في الرسوم الموجهة اللا دورية)\n\nBFS ممتازة لـ:\n\nأقصر المسارات في الرسوم غير الموزونة\nمسائل “أقل عدد خطوات”\nالاستكشاف طبقة بطبقة\n\n\n\n\n\n\n\nBFS تستخدم طابوراً (queue)\nتزور العقد بترتيب مسافة متزايدة من البداية\nتعطي أطوال أقصر المسارات في الرسوم غير الموزونة\nباستخدام parent[] يمكنك إعادة بناء أقصر مسار",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "البحث بالعرض على الرسوم البيانية العامة"
    ]
  },
  {
    "objectID": "b3/graphs/bfs.html#فيم-تستخدم-bfs",
    "href": "b3/graphs/bfs.html#فيم-تستخدم-bfs",
    "title": "البحث بالعرض على الرسوم البيانية العامة",
    "section": "",
    "text": "BFS هي الأداة الأساسية لـ:\n\nأقصر مسار في رسم بياني غير موزون (تكلفة كل حرف = 1)\nأقل عدد أحرف من عقدة البداية إلى جميع العقد\nالتحقق من الاتصال / المكونات\n\nالضمان الأساسي:\n\nفي رسم بياني غير موزون، BFS تجد أقصر مسافة (أقل عدد أحرف) من عقدة البداية إلى كل عقدة يمكن الوصول لها.",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "البحث بالعرض على الرسوم البيانية العامة"
    ]
  },
  {
    "objectID": "b3/graphs/bfs.html#الفكرة-الأساسية-طابور-زيارة-مسافة",
    "href": "b3/graphs/bfs.html#الفكرة-الأساسية-طابور-زيارة-مسافة",
    "title": "البحث بالعرض على الرسوم البيانية العامة",
    "section": "",
    "text": "BFS تستخدم طابوراً (queue) حتى تتم معالجة العقد بنفس ترتيب اكتشافها.\nنحافظ على:\n\ndist[v] = أقصر عدد أحرف من البداية إلى v\n(-1 يعني “لم تتم زيارتها بعد”)\n\nالخطوات:\n\nضع عقدة البداية في الطابور، واجعل dist[start] = 0\nاسحب عقدة v من الطابور\nلكل جار to:\n\nإذا كان غير مُزار، اجعل dist[to] = dist[v] + 1\nثم أدخله إلى الطابور\n\n\nبما أن الطابور يعالج الطبقات الأقرب أولاً، فأول مرة تزور فيها عقدة تكون مضمونة عبر أقصر مسار.",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "البحث بالعرض على الرسوم البيانية العامة"
    ]
  },
  {
    "objectID": "b3/graphs/bfs.html#التنفيذ",
    "href": "b3/graphs/bfs.html#التنفيذ",
    "title": "البحث بالعرض على الرسوم البيانية العامة",
    "section": "",
    "text": "نفترض قائمة مجاورات:\n\nint n;\nvector&lt;int&gt; g[n];\n\nBFS من مصدر واحد:\n\nvector&lt;int&gt; dist(n, -1);\nqueue&lt;int&gt; q;\n\nint s = 0;\ndist[s] = 0;\nq.push(s);\n\nwhile (!q.empty()) {\n    int v = q.front(); q.pop();\n    for (int to : g[v]) {\n        if (dist[to] != -1) continue;     // already visited\n        dist[to] = dist[v] + 1;\n        q.push(to);\n    }\n}\n\nالآن dist[v] تكون:\n\n0 لعقدة البداية\n1 للعقد التي تبعد حرفاً واحداً\n2 للعقد التي تبعد حرفين\n…إلخ\n-1 إذا كانت غير قابلة للوصول من s",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "البحث بالعرض على الرسوم البيانية العامة"
    ]
  },
  {
    "objectID": "b3/graphs/bfs.html#حدس-الطبقات-في-bfs-لماذا-تعمل-أقصر-المسارات",
    "href": "b3/graphs/bfs.html#حدس-الطبقات-في-bfs-لماذا-تعمل-أقصر-المسارات",
    "title": "البحث بالعرض على الرسوم البيانية العامة",
    "section": "",
    "text": "عند تشغيل BFS:\n\nالطابور يحتوي أولاً على جميع العقد ذات المسافة 0\nثم يكبر ليضم جميع العقد ذات المسافة 1\nثم جميع العقد ذات المسافة 2\n…\n\nلذلك إذا تم اكتشاف to من v، فأول مرة تضبط فيها dist[to] لابد أن تكون dist[v] + 1، و v أصلاً في أبكر طبقة ممكنة يمكنها الوصول إليه.\nلهذا السبب BFS تعطي أقصر المسارات في الرسوم البيانية غير الموزونة.",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "البحث بالعرض على الرسوم البيانية العامة"
    ]
  },
  {
    "objectID": "b3/graphs/bfs.html#استخراج-أقصر-مسار-فعليا-ليس-فقط-المسافة",
    "href": "b3/graphs/bfs.html#استخراج-أقصر-مسار-فعليا-ليس-فقط-المسافة",
    "title": "البحث بالعرض على الرسوم البيانية العامة",
    "section": "",
    "text": "خزن parent[to] عند اكتشاف to.\n\nvector&lt;int&gt; dist(n, -1), parent(n, -1);\nqueue&lt;int&gt; q;\n\nint s = 0;\ndist[s] = 0;\nq.push(s);\n\nwhile (!q.empty()) {\n    int v = q.front(); q.pop();\n    for (int to : g[v]) {\n        if (dist[to] != -1) continue;\n        dist[to] = dist[v] + 1;\n        parent[to] = v;\n        q.push(to);\n    }\n}\n\nإعادة بناء المسار من s إلى t:\n\nvector&lt;int&gt; path;\nint t = 7;\nif (dist[t] != -1) {\n    for (int v = t; v != -1; v = parent[v]) path.push_back(v);\n    reverse(path.begin(), path.end());\n}",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "البحث بالعرض على الرسوم البيانية العامة"
    ]
  },
  {
    "objectID": "b3/graphs/bfs.html#bfs-مقابل-dfs-فرق-عملي",
    "href": "b3/graphs/bfs.html#bfs-مقابل-dfs-فرق-عملي",
    "title": "البحث بالعرض على الرسوم البيانية العامة",
    "section": "",
    "text": "DFS ممتازة لـ:\n\nاستكشاف البنية\nكشف الدورات\nالمكونات المتصلة\nالفرز الطوبولوجي (في الرسوم الموجهة اللا دورية)\n\nBFS ممتازة لـ:\n\nأقصر المسارات في الرسوم غير الموزونة\nمسائل “أقل عدد خطوات”\nالاستكشاف طبقة بطبقة",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "البحث بالعرض على الرسوم البيانية العامة"
    ]
  },
  {
    "objectID": "b3/graphs/bfs.html#ملخص-سريع",
    "href": "b3/graphs/bfs.html#ملخص-سريع",
    "title": "البحث بالعرض على الرسوم البيانية العامة",
    "section": "",
    "text": "BFS تستخدم طابوراً (queue)\nتزور العقد بترتيب مسافة متزايدة من البداية\nتعطي أطوال أقصر المسارات في الرسوم غير الموزونة\nباستخدام parent[] يمكنك إعادة بناء أقصر مسار",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "البحث بالعرض على الرسوم البيانية العامة"
    ]
  },
  {
    "objectID": "b3/graphs/dfs.html",
    "href": "b3/graphs/dfs.html",
    "title": "البحث في العمق",
    "section": "",
    "text": "هذه خوارزمية تستكشف بشكل تكراري جيران رأس معين حتى تتم زيارة جميع الرؤوس. الرأس الابتدائي يسمى المصدر.\n\n\nيبدأ الاجتياز عند رأس مصدر \\(u\\) ويضع عليه علامة كمُزار، إذا لم تتم زيارة أحد جيران الرأس الحالي ننتقل إلى ذلك الرأس ونكرر العملية. إذا تمت زيارة جميع جيران الرأس الحالي فإننا نعود إلى الرأس الأب.\nالتعقيد الزمني لهذا الاجتياز هو \\(O(N + M)\\) حيث \\(N\\) هو عدد الرؤوس و \\(M\\) هو عدد الأحرف.\n\nconst int maxN = 200'001;\n\nbool vis[maxN];\nvector&lt;int&gt; adj[maxN]; // adjacency list\n\nvoid dfs (int u) {\n    vis[u] = true;\n\n    for (int v : adj[u]) {\n        if (!vis[v]) dfs(v);\n    }\n}\n\n\n  \n\n\n\n\n\n\nPath Finding\n\n\neasy\n\n\n\nمعطى رسم بياني غير موجه \\(G\\) يتكون من \\(N\\) رأساً مرقمة من \\(1\\) إلى \\(N\\) و \\(M\\) حرفاً، تحقق مما إذا كان الرأس \\(1\\) يمكنه الوصول إلى الرأس \\(N\\) واطبع مساراً ممكناً.\n\n\n\n\n\nSolution\n\nإذا بدأنا اجتياز DFS على الرأس \\(1\\)، يمكننا فحص vis[N] لمعرفة ما إذا كان المسار موجوداً أم لا. هدفنا هو استرجاع المسار الذي اتخذه الاجتياز للوصول إلى الرأس \\(N\\).\nلتحقيق ذلك، سنخزن مصفوفة \\(p\\) حيث \\(p_i\\) هو الرأس الذي أدى بـ DFS لاكتشاف الرأس \\(i\\). باستخدام هذا يمكننا تتبع المسار من \\(N\\) عائدين إلى \\(1\\).\n\n\nconst int maxN = 200'001;\nint vis[maxN], p[maxN];\nvector&lt;int&gt; adj[maxN];\n\nvoid dfs (int u) {\n    vis[u] = true;\n    for (int v : adj[u]) {\n        if (!vis[v]) {\n            p[v] = u; // we discovered v through u\n            dfs(v);\n        }\n    }\n}\n\nint main () {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dfs(1);\n\n    if (!vis[n]) cout &lt;&lt; \"No\";\n    else {\n        cout &lt;&lt; \"Yes\\n\";\n\n        vector&lt;int&gt; pth;\n        for (int i = n ; i != 1 ; i = p[i]) { // trace back loop \n            pth.push_back(i);  \n        }\n\n        reverse(pth.begin(), pth.end());\n        cout &lt;&lt; 1 &lt;&lt; ' '; \n        for (int i : pth) cout &lt;&lt; i &lt;&lt; ' ';\n    }\n}\n\n\n\n\n\n\n\n\n\nBuilding Teams\n\nCSES\neasy\n\n\n\nيوجد \\(N\\) تلميذاً في الصف، و \\(M\\) صداقة بينهم. مهمتك هي تقسيم التلاميذ إلى فريقين بحيث لا يكون أي تلميذين في فريق واحد صديقين. يمكنك اختيار أحجام الفرق بحرية.\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\nTip\n\n\n\nإنها حيلة مفيدة أن تحاول تصور العلاقات الثنائية كرؤوس وأحرف.\n\n\nيمكننا القول أن التلاميذ هم رؤوس والصداقة بين تلميذين تربطهم بحرف.\nنلاحظ أنه يجب علينا تعيين لون لكل رأس (مثلاً إما أحمر أو أزرق) بحيث تكون نقاط نهاية كل حرف بألوان مختلفة. هذا يُعرف بـ التلوين الثنائي.\nلأي تعيين صالح، إذا قلبنا لون كل رأس من أحمر إلى أزرق أو العكس، سيظل التعيين صالحاً، لذا يمكننا افتراض أن الرأس \\(1\\) دائماً أحمر.\nمن ذلك يمكننا ملاحظة أن جميع جيرانه يجب أن يكونوا أزرق وبشكل تكراري يمكننا تعيين ألوان لجميع الرؤوس.\n\n\n\n\n\n\nImportant\n\n\n\nإذا لونا رأساً بلون \\(C\\) ثم اكتشفنا أننا سبق ولونا أحد جيرانه \\(C\\) أيضاً فيجب علينا التوقف فوراً لأننا وجدنا تناقضاً.\n\n\nقد يتكون الرسم البياني من عدة مكونات منفصلة لذا يجب علينا الحل لكل واحدة على حدة.\n\n\nconst int maxN = 200'001;\n\nbool vis[maxN], clr[maxN], contradiction = false;\nvector&lt;int&gt; adj[maxN];\n\nvoid dfs (int u) {\n    vis[u] = true;\n\n    for (int v : adj[u]) {\n        if (vis[v]) {\n            if (clr[v] == clr[u]) contradiction = true;\n        } else {\n            clr[v] = !clr[u];\n            dfs(v);\n        }\n    }\n}\n\nint main () { \n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 0 ; i &lt; m ; i++) {\n        int u, v;\n        cin &gt;&gt; u &gt;&gt; v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    for (int i = 1 ; i &lt;= n ; i++) if (!vis[i]) dfs(i);\n\n    if (contradiction) cout &lt;&lt; \"IMPOSSIBLE\";\n    else {\n        for (int i = 1 ; i &lt;= n ; i++) cout &lt;&lt; 1 + clr[i] &lt;&lt; ' ';\n    }\n}",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "البحث في العمق"
    ]
  },
  {
    "objectID": "b3/graphs/dfs.html#كيف-يعمل-dfs",
    "href": "b3/graphs/dfs.html#كيف-يعمل-dfs",
    "title": "البحث في العمق",
    "section": "",
    "text": "يبدأ الاجتياز عند رأس مصدر \\(u\\) ويضع عليه علامة كمُزار، إذا لم تتم زيارة أحد جيران الرأس الحالي ننتقل إلى ذلك الرأس ونكرر العملية. إذا تمت زيارة جميع جيران الرأس الحالي فإننا نعود إلى الرأس الأب.\nالتعقيد الزمني لهذا الاجتياز هو \\(O(N + M)\\) حيث \\(N\\) هو عدد الرؤوس و \\(M\\) هو عدد الأحرف.\n\nconst int maxN = 200'001;\n\nbool vis[maxN];\nvector&lt;int&gt; adj[maxN]; // adjacency list\n\nvoid dfs (int u) {\n    vis[u] = true;\n\n    for (int v : adj[u]) {\n        if (!vis[v]) dfs(v);\n    }\n}",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "البحث في العمق"
    ]
  },
  {
    "objectID": "b3/graphs/dfs.html#path-finding",
    "href": "b3/graphs/dfs.html#path-finding",
    "title": "البحث في العمق",
    "section": "",
    "text": "Path Finding\n\n\neasy\n\n\n\nمعطى رسم بياني غير موجه \\(G\\) يتكون من \\(N\\) رأساً مرقمة من \\(1\\) إلى \\(N\\) و \\(M\\) حرفاً، تحقق مما إذا كان الرأس \\(1\\) يمكنه الوصول إلى الرأس \\(N\\) واطبع مساراً ممكناً.",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "البحث في العمق"
    ]
  },
  {
    "objectID": "b3/graphs/dfs.html#building-teams",
    "href": "b3/graphs/dfs.html#building-teams",
    "title": "البحث في العمق",
    "section": "",
    "text": "Building Teams\n\nCSES\neasy\n\n\n\nيوجد \\(N\\) تلميذاً في الصف، و \\(M\\) صداقة بينهم. مهمتك هي تقسيم التلاميذ إلى فريقين بحيث لا يكون أي تلميذين في فريق واحد صديقين. يمكنك اختيار أحجام الفرق بحرية.",
    "crumbs": [
      "المرحلة 4",
      "Graphs",
      "البحث في العمق"
    ]
  },
  {
    "objectID": "b3/number-theory/divisors-primes.html",
    "href": "b3/number-theory/divisors-primes.html",
    "title": "القواسم والأعداد الأولية",
    "section": "",
    "text": "الآن بعد أن عرفنا كيفية خلط الأعداد (GCD/LCM)، دعونا ننظر داخل عدد واحد.\nنريد الإجابة على سؤالين كبيرين بكفاءة:\n\nما هي الأعداد التي تقسم \\(N\\)؟ (القواسم)\nهل \\(N\\) عدد أولي؟\n\nإذا كان \\(N\\) صغيراً (مثل 50)، فهذا سهل. إذا كان \\(N\\) هو 1,000,000,000، فإن القيام بذلك بالطريقة الخاطئة سيجمد الكود الخاص بك.\n\n\nهذه هي الحيلة الأكثر أهمية في نظرية الأعداد الأساسية.\nإذا كنت تريد إيجاد عوامل 36، دعونا نسردها في أزواج:\n\n\\(1 \\times 36 = 36\\)\n\\(2 \\times 18 = 36\\)\n\\(3 \\times 12 = 36\\)\n\\(4 \\times 9 = 36\\)\n\\(6 \\times 6 = 36\\) &lt;– نقطة التحول (\\(\\sqrt{36}\\))\n\\(9 \\times 4 = 36\\) &lt;– تكرار! رأينا {4, 9} بالفعل\n\\(12 \\times 3 = 36\\) &lt;– تكرار!\n\\(18 \\times 2 = 36\\) &lt;– تكرار!\n\\(36 \\times 1 = 36\\) &lt;– تكرار!\n\nالاستنتاج: العوامل تأتي دائماً في أزواج. إذا كان \\(a \\times b = N\\)، و \\(a\\) صغير، فإن \\(b\\) يجب أن يكون كبيراً. إنهما “يلتقيان” بالضبط عند \\(\\sqrt{N}\\).\nالقاعدة: لا تحتاج أبداً للتحقق من الأعداد الأكبر من \\(\\sqrt{N}\\). إذا لم تجد عاملاً بحلول ذلك الوقت، فإنه غير موجود (أو أنك وجدت شريكه بالفعل).\n\n\n\nالهدف: اطبع جميع قواسم العدد \\(N\\).\n\n\nحلقة من 1 إلى \\(N\\). التعقيد: \\(O(N)\\)\n\n// If N = 10^9, this takes ~10 second (too slow for many problems)\nfor (int i = 1; i &lt;= n; i++) {\n    if (n % i == 0) cout &lt;&lt; i &lt;&lt; \" \";\n}\n\n\n\n\nحلقة من 1 إلى \\(\\sqrt{N}\\). عندما تجد قاسماً \\(i\\)، فإنك تجد تلقائياً شريكه \\(\\frac{n}{i}\\). التعقيد: \\(O(\\sqrt{N})\\).\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt; // for sort\nusing namespace std;\n\nint main() {\n    long long n = 36;\n    vector&lt;long long&gt; divisors;\n\n    // Notice: i * i &lt;= n is better than i &lt;= sqrt(n)\n    // It avoids slow floating-point math.\n    for (long long i = 1; i * i &lt;= n; i++) {\n        if (n % i == 0) {\n            divisors.push_back(i); // Add the small one\n            \n            // Add the big partner, but ONLY if they are different\n            // (Check to avoid adding 6 twice for n=36)\n            if (i != n / i) {\n                divisors.push_back(n / i);\n            }\n        }\n    }\n\n    // Note: The list won't be sorted (e.g., 1, 36, 2, 18...)\n\n    for (long long d : divisors) cout &lt;&lt; d &lt;&lt; \" \";\n}\n\n\n\n\n\nالعدد الأولي هو عدد أكبر من \\(1\\) له بالضبط قاسمان: 1 ونفسه.\n\n\nباستخدام المنطق أعلاه: لإثبات أن عدداً أولي، نحتاج فقط للتحقق من أنه ليس لديه عوامل حتى \\(\\sqrt{N}\\).\n\nbool isPrime(long long n) {\n    if (n &lt;= 1) return false; // 0 and 1 are not prime\n    \n    for (long long i = 2; i * i &lt;= n; i++) {\n        if (n % i == 0) {\n            return false; // Found a divisor! Not prime.\n        }\n    }\n    return true; // Survived the loop? It's prime.\n}\n\n\n\n\n\n\n\n\n\n\nThe Marching Band Formation\n\n\n\n\n\nفرقة موسيقية في مدرسة ثانوية لديها 240 عضواً. مدير الفرقة يريد ترتيب الأعضاء في تشكيل مستطيل للموكب. ومع ذلك، هناك قيود محددة للتشكيل:\n\nيجب تضمين جميع الأعضاء في التشكيل.\nيجب أن يكون التشكيل مستطيلاً صلباً (بدون أماكن فارغة).\nيجب أن يكون هناك 10 صفوف على الأقل.\nلا يمكن أن يكون هناك أكثر من 20 صفاً.\n\nكم عدد التشكيلات المستطيلة المختلفة التي تحقق هذه الشروط؟\n\n\n\n\n\nSolution\n\nلحل هذا، نحتاج لإيجاد قواسم 240. بما أننا نبحث عن أزواج (الصفوف \\(\\times\\) الأعمدة = 240)، يمكننا استخدام طريقة الجذر التربيعي لإيجاد الأزواج بكفاءة.\n\nint findDivisors(int n) {\n    vector&lt;pair&lt;int, int&gt;&gt; divisors;\n    for (int i = 1; i * i &lt;= n; i++) {\n        if (n % i == 0) {\n            if (i * i == n) {\n                divisors.push_back({i, i});\n            } else {\n                divisors.push_back({i, n/i});\n                divisors.push_back({n/i, i}); // Add both combinations of i and n/i\n            }\n        }\n    }\n\n    int count = 0;\n    for (int i = 0; i &lt; (int)divisors.size(); ++i){\n        if (divisors[i].first &gt;= 10 && divisors[i].first &lt;= 20){\n            count++;\n        }\n    }\n\n    return count;\n}\n\nإذا كان \\(N=240\\)، تجد الدالة \\(5\\) حلول. هذه هي: - \\(10\\)، \\(24\\) - \\(12\\)، \\(20\\) - \\(15\\)، \\(16\\) - \\(16\\)، \\(15\\) - \\(20\\)، \\(12\\)\n\n\n\n\n\n\n\nT-Prime\n\n\n\n\n\nنعلم أن الأعداد الأولية هي أعداد صحيحة موجبة لها بالضبط قاسمان موجبان مختلفان. بالمثل، سنسمي عدداً صحيحاً موجباً \\(t\\) أولياً-T، إذا كان لـ \\(t\\) بالضبط ثلاثة قواسم موجبة مختلفة.\nمعطاة مصفوفة من \\(n\\) عدداً صحيحاً موجباً. لكل منهم حدد ما إذا كان أولياً-T أم لا.\n\n\nSolution\n\nيمكن إثبات أن مربعات الأعداد الأولية فقط هي أعداد T-أولية، وأنه لا يوجد الكثير منها. لماذا؟\nإذا كان لدينا عاملان أوليان \\(p\\)، \\(q\\) لعدد \\(t\\)، فإنه سيكون قابلاً للقسمة على الأقل على \\(p\\)، \\(q\\)، \\(pq\\)، \\(1\\) - وهو أكثر من \\(3\\). إذن، يجب أن يكون قوة لعدد أولي. يمكنك أن ترى بسهولة الآن أن \\(t = p\\) أو \\(t = p^3\\) وأعلى، لا يعمل حقاً.\n\nint n;\ncin &gt;&gt; n;\n\nfor (int i = 0; i &lt; n; ++i){\n    int x;\n    cin &gt;&gt; x;\n\n    int y = sqrt(x);\n    if (y * y != x){\n        cout &lt;&lt; \"NO\\n\";\n        continue; //check whether x is a perfect square\n    }\n\n    if (isPrime(y))\n        cout &lt;&lt; \"YES\\n\";\n    else\n        cout &lt;&lt; \"NO\\n\"; \n}",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "القواسم والأعداد الأولية"
    ]
  },
  {
    "objectID": "b3/number-theory/divisors-primes.html#الفكرة-الكبرى-تحسين-الجذر-التربيعي",
    "href": "b3/number-theory/divisors-primes.html#الفكرة-الكبرى-تحسين-الجذر-التربيعي",
    "title": "القواسم والأعداد الأولية",
    "section": "",
    "text": "هذه هي الحيلة الأكثر أهمية في نظرية الأعداد الأساسية.\nإذا كنت تريد إيجاد عوامل 36، دعونا نسردها في أزواج:\n\n\\(1 \\times 36 = 36\\)\n\\(2 \\times 18 = 36\\)\n\\(3 \\times 12 = 36\\)\n\\(4 \\times 9 = 36\\)\n\\(6 \\times 6 = 36\\) &lt;– نقطة التحول (\\(\\sqrt{36}\\))\n\\(9 \\times 4 = 36\\) &lt;– تكرار! رأينا {4, 9} بالفعل\n\\(12 \\times 3 = 36\\) &lt;– تكرار!\n\\(18 \\times 2 = 36\\) &lt;– تكرار!\n\\(36 \\times 1 = 36\\) &lt;– تكرار!\n\nالاستنتاج: العوامل تأتي دائماً في أزواج. إذا كان \\(a \\times b = N\\)، و \\(a\\) صغير، فإن \\(b\\) يجب أن يكون كبيراً. إنهما “يلتقيان” بالضبط عند \\(\\sqrt{N}\\).\nالقاعدة: لا تحتاج أبداً للتحقق من الأعداد الأكبر من \\(\\sqrt{N}\\). إذا لم تجد عاملاً بحلول ذلك الوقت، فإنه غير موجود (أو أنك وجدت شريكه بالفعل).",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "القواسم والأعداد الأولية"
    ]
  },
  {
    "objectID": "b3/number-theory/divisors-primes.html#إيجاد-القواسم",
    "href": "b3/number-theory/divisors-primes.html#إيجاد-القواسم",
    "title": "القواسم والأعداد الأولية",
    "section": "",
    "text": "الهدف: اطبع جميع قواسم العدد \\(N\\).\n\n\nحلقة من 1 إلى \\(N\\). التعقيد: \\(O(N)\\)\n\n// If N = 10^9, this takes ~10 second (too slow for many problems)\nfor (int i = 1; i &lt;= n; i++) {\n    if (n % i == 0) cout &lt;&lt; i &lt;&lt; \" \";\n}\n\n\n\n\nحلقة من 1 إلى \\(\\sqrt{N}\\). عندما تجد قاسماً \\(i\\)، فإنك تجد تلقائياً شريكه \\(\\frac{n}{i}\\). التعقيد: \\(O(\\sqrt{N})\\).\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt; // for sort\nusing namespace std;\n\nint main() {\n    long long n = 36;\n    vector&lt;long long&gt; divisors;\n\n    // Notice: i * i &lt;= n is better than i &lt;= sqrt(n)\n    // It avoids slow floating-point math.\n    for (long long i = 1; i * i &lt;= n; i++) {\n        if (n % i == 0) {\n            divisors.push_back(i); // Add the small one\n            \n            // Add the big partner, but ONLY if they are different\n            // (Check to avoid adding 6 twice for n=36)\n            if (i != n / i) {\n                divisors.push_back(n / i);\n            }\n        }\n    }\n\n    // Note: The list won't be sorted (e.g., 1, 36, 2, 18...)\n\n    for (long long d : divisors) cout &lt;&lt; d &lt;&lt; \" \";\n}",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "القواسم والأعداد الأولية"
    ]
  },
  {
    "objectID": "b3/number-theory/divisors-primes.html#الأعداد-الأولية",
    "href": "b3/number-theory/divisors-primes.html#الأعداد-الأولية",
    "title": "القواسم والأعداد الأولية",
    "section": "",
    "text": "العدد الأولي هو عدد أكبر من \\(1\\) له بالضبط قاسمان: 1 ونفسه.\n\n\nباستخدام المنطق أعلاه: لإثبات أن عدداً أولي، نحتاج فقط للتحقق من أنه ليس لديه عوامل حتى \\(\\sqrt{N}\\).\n\nbool isPrime(long long n) {\n    if (n &lt;= 1) return false; // 0 and 1 are not prime\n    \n    for (long long i = 2; i * i &lt;= n; i++) {\n        if (n % i == 0) {\n            return false; // Found a divisor! Not prime.\n        }\n    }\n    return true; // Survived the loop? It's prime.\n}",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "القواسم والأعداد الأولية"
    ]
  },
  {
    "objectID": "b3/number-theory/divisors-primes.html#the-marching-band-formation",
    "href": "b3/number-theory/divisors-primes.html#the-marching-band-formation",
    "title": "القواسم والأعداد الأولية",
    "section": "",
    "text": "The Marching Band Formation\n\n\n\n\n\nفرقة موسيقية في مدرسة ثانوية لديها 240 عضواً. مدير الفرقة يريد ترتيب الأعضاء في تشكيل مستطيل للموكب. ومع ذلك، هناك قيود محددة للتشكيل:\n\nيجب تضمين جميع الأعضاء في التشكيل.\nيجب أن يكون التشكيل مستطيلاً صلباً (بدون أماكن فارغة).\nيجب أن يكون هناك 10 صفوف على الأقل.\nلا يمكن أن يكون هناك أكثر من 20 صفاً.\n\nكم عدد التشكيلات المستطيلة المختلفة التي تحقق هذه الشروط؟",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "القواسم والأعداد الأولية"
    ]
  },
  {
    "objectID": "b3/number-theory/divisors-primes.html#t-prime",
    "href": "b3/number-theory/divisors-primes.html#t-prime",
    "title": "القواسم والأعداد الأولية",
    "section": "",
    "text": "T-Prime\n\n\n\n\n\nنعلم أن الأعداد الأولية هي أعداد صحيحة موجبة لها بالضبط قاسمان موجبان مختلفان. بالمثل، سنسمي عدداً صحيحاً موجباً \\(t\\) أولياً-T، إذا كان لـ \\(t\\) بالضبط ثلاثة قواسم موجبة مختلفة.\nمعطاة مصفوفة من \\(n\\) عدداً صحيحاً موجباً. لكل منهم حدد ما إذا كان أولياً-T أم لا.\n\n\nSolution\n\nيمكن إثبات أن مربعات الأعداد الأولية فقط هي أعداد T-أولية، وأنه لا يوجد الكثير منها. لماذا؟\nإذا كان لدينا عاملان أوليان \\(p\\)، \\(q\\) لعدد \\(t\\)، فإنه سيكون قابلاً للقسمة على الأقل على \\(p\\)، \\(q\\)، \\(pq\\)، \\(1\\) - وهو أكثر من \\(3\\). إذن، يجب أن يكون قوة لعدد أولي. يمكنك أن ترى بسهولة الآن أن \\(t = p\\) أو \\(t = p^3\\) وأعلى، لا يعمل حقاً.\n\nint n;\ncin &gt;&gt; n;\n\nfor (int i = 0; i &lt; n; ++i){\n    int x;\n    cin &gt;&gt; x;\n\n    int y = sqrt(x);\n    if (y * y != x){\n        cout &lt;&lt; \"NO\\n\";\n        continue; //check whether x is a perfect square\n    }\n\n    if (isPrime(y))\n        cout &lt;&lt; \"YES\\n\";\n    else\n        cout &lt;&lt; \"NO\\n\"; \n}",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "القواسم والأعداد الأولية"
    ]
  },
  {
    "objectID": "b3/number-theory/intro.html",
    "href": "b3/number-theory/intro.html",
    "title": "نظرية الأعداد",
    "section": "",
    "text": "نظرية الأعداد هي مجرد اسم فاخر للعب بالأعداد الصحيحة (الأعداد الكاملة). لا كسور، لا أعداد عشرية - فقط أعداد نقية مثل 1، 5، 42، -10.\nبحلول الآن، يجب أن تكون ملماً بالقسمة، أخذ الباقي عند القسمة، وتحديد الأنماط المتعلقة بهذه العمليات.\n\n\nالقاسم المشترك الأكبر لعددين هو أكبر عدد يقسم كليهما دون ترك باقٍ.\nعلى سبيل المثال:\n\nGCD(12, 18) = 6 (كلاهما يمكن قسمته على 1، 2، 3، 6، ثم 6 هو الأكبر)\nGCD(7, 13) = 1 (لا يشتركان في شيء سوى 1)\n\n\n\nمن السهل نسبياً حساب GCD(a, b) إذا لم نهتم بالكفاءة. يمكن للمرء التكرار من 1 إلى \\(max(a, b)\\) والتحقق من أي عدد كان الأخير في قسمة كلا العددين \\(a\\) و \\(b\\)، دون باقٍ.\nالتعقيد الزمني لهذا الأسلوب هو \\(\\mathcal{O}(max(a, b))\\).\n\n\n\nيمكننا القيام بما هو أفضل بكثير. لا تختبر كل عدد! هناك حيلة عمرها 2000 سنة: GCD(a, b) هو نفسه GCD(b, a % b). تستمر في أخذ الباقي حتى يصبح أحد الأعداد 0.\n\n// Recursive way (The \"standard\" way)\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\n\n\n\n\n\n\nTip\n\n\n\nيمكنك أيضاً استخدام الدالة المدمجة لـ gcd. بالنسبة للإصدارات الأحدث (C++17 وما بعدها)، هناك دالة gcd(int, int). بالنسبة للإصدارات الأقدم من C++، يمكنك استخدام __gcd(int, int).\n\n\n\n\n\n\nالمضاعف المشترك الأصغر هو أصغر عدد يمكن لكلا العددين القسمة عليه.\nفكر فيه على أنه “أول مرة تلتقي مضاعفاتهما”.\n\nمضاعفات 4: 4، 8، 12، 16…\nمضاعفات 6: 6، 12، 18…\nLCM(4, 6) = 12\n\n\n\nلا تحتاج إلى حلقة للعثور على هذا. استخدم GCD!\n\n\\[ \\text{LCM}(a, b) = \\frac{(a \\times b)}{\\text{GCD}(a, b)} \\]\n\n\n\n\n\n\n\nCaution\n\n\n\nلتجنب الفيض (حصول العدد على قيمة كبيرة جداً)، اقسم أولاً: (a / gcd(a,b)) * b.\n\n\n\nint lcm(int a, int b) {\n    if (a == 0 || b == 0) return 0;\n    return (a / gcd(a, b)) * b;\n}\n\n\n\n\n\n\n\n\n\n\nSimplifying Fractions\n\n\n\n\n\nمعطى كسر، لنقل \\(18/24\\). تحتاج لإخراجه بأبسط صورة.\n\n\n\n\n\nSolution\n\nلتبسيط كسر، اقسم كلاً من الأعلى (البسط) والأسفل (المقام) على قاسمهما المشترك الأكبر.\n\n#include &lt;iostream&gt;\n#include &lt;numeric&gt; // for std::gcd\nusing namespace std;\n\nint main() {\n    int num = 18;\n    int den = 24;\n    \n    int common = std::gcd(num, den);\n    \n    num /= common;\n    den /= common;\n    \n    cout &lt;&lt; num &lt;&lt; \"/\" &lt;&lt; den; // Outputs: 3/4\n}\n\nبإزالة أكبر عامل مشترك (6)، نحصل على النسخة الأبسط فوراً.\n\n\n\n\n\n\n\nThe Meeting Point\n\n\n\n\n\nمصباحان يومضان بفترات زمنية مختلفة.\n\nالمصباح A يومض كل 12 ثانية.\nالمصباح B يومض كل 15 ثانية.\n\nلقد ومضا معاً للتو. متى سيومضان معاً مرة أخرى؟\n\n\n\n\n\nSolution\n\nنبحث عن وقت \\(T\\) هو مضاعف لكل من 12 و 15. وتحديداً، أول (أصغر) وقت يحدث فيه ذلك. هذا بالضبط هو LCM.\n\n#include &lt;iostream&gt;\n#include &lt;numeric&gt;\nusing namespace std;\n\nint main() {\n    int a = 12;\n    int b = 15;\n    \n    // LCM formula: (a * b) / GCD(a, b)\n    int meet_time = std::lcm(a, b); \n    \n    cout &lt;&lt; \"They meet again in \" &lt;&lt; meet_time &lt;&lt; \" seconds.\"; \n    // Output: 60 seconds\n}",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "نظرية الأعداد"
    ]
  },
  {
    "objectID": "b3/number-theory/intro.html#القاسم-المشترك-الأكبر-gcd",
    "href": "b3/number-theory/intro.html#القاسم-المشترك-الأكبر-gcd",
    "title": "نظرية الأعداد",
    "section": "",
    "text": "القاسم المشترك الأكبر لعددين هو أكبر عدد يقسم كليهما دون ترك باقٍ.\nعلى سبيل المثال:\n\nGCD(12, 18) = 6 (كلاهما يمكن قسمته على 1، 2، 3، 6، ثم 6 هو الأكبر)\nGCD(7, 13) = 1 (لا يشتركان في شيء سوى 1)\n\n\n\nمن السهل نسبياً حساب GCD(a, b) إذا لم نهتم بالكفاءة. يمكن للمرء التكرار من 1 إلى \\(max(a, b)\\) والتحقق من أي عدد كان الأخير في قسمة كلا العددين \\(a\\) و \\(b\\)، دون باقٍ.\nالتعقيد الزمني لهذا الأسلوب هو \\(\\mathcal{O}(max(a, b))\\).\n\n\n\nيمكننا القيام بما هو أفضل بكثير. لا تختبر كل عدد! هناك حيلة عمرها 2000 سنة: GCD(a, b) هو نفسه GCD(b, a % b). تستمر في أخذ الباقي حتى يصبح أحد الأعداد 0.\n\n// Recursive way (The \"standard\" way)\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\n\n\n\n\n\n\nTip\n\n\n\nيمكنك أيضاً استخدام الدالة المدمجة لـ gcd. بالنسبة للإصدارات الأحدث (C++17 وما بعدها)، هناك دالة gcd(int, int). بالنسبة للإصدارات الأقدم من C++، يمكنك استخدام __gcd(int, int).",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "نظرية الأعداد"
    ]
  },
  {
    "objectID": "b3/number-theory/intro.html#المضاعف-المشترك-الأصغر-lcm",
    "href": "b3/number-theory/intro.html#المضاعف-المشترك-الأصغر-lcm",
    "title": "نظرية الأعداد",
    "section": "",
    "text": "المضاعف المشترك الأصغر هو أصغر عدد يمكن لكلا العددين القسمة عليه.\nفكر فيه على أنه “أول مرة تلتقي مضاعفاتهما”.\n\nمضاعفات 4: 4، 8، 12، 16…\nمضاعفات 6: 6، 12، 18…\nLCM(4, 6) = 12\n\n\n\nلا تحتاج إلى حلقة للعثور على هذا. استخدم GCD!\n\n\\[ \\text{LCM}(a, b) = \\frac{(a \\times b)}{\\text{GCD}(a, b)} \\]\n\n\n\n\n\n\n\nCaution\n\n\n\nلتجنب الفيض (حصول العدد على قيمة كبيرة جداً)، اقسم أولاً: (a / gcd(a,b)) * b.\n\n\n\nint lcm(int a, int b) {\n    if (a == 0 || b == 0) return 0;\n    return (a / gcd(a, b)) * b;\n}",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "نظرية الأعداد"
    ]
  },
  {
    "objectID": "b3/number-theory/intro.html#simplifying-fractions",
    "href": "b3/number-theory/intro.html#simplifying-fractions",
    "title": "نظرية الأعداد",
    "section": "",
    "text": "Simplifying Fractions\n\n\n\n\n\nمعطى كسر، لنقل \\(18/24\\). تحتاج لإخراجه بأبسط صورة.",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "نظرية الأعداد"
    ]
  },
  {
    "objectID": "b3/number-theory/intro.html#the-meeting-point",
    "href": "b3/number-theory/intro.html#the-meeting-point",
    "title": "نظرية الأعداد",
    "section": "",
    "text": "The Meeting Point\n\n\n\n\n\nمصباحان يومضان بفترات زمنية مختلفة.\n\nالمصباح A يومض كل 12 ثانية.\nالمصباح B يومض كل 15 ثانية.\n\nلقد ومضا معاً للتو. متى سيومضان معاً مرة أخرى؟",
    "crumbs": [
      "المرحلة 4",
      "Number Theory",
      "نظرية الأعداد"
    ]
  },
  {
    "objectID": "b3/problems/amicable-numbers.html",
    "href": "b3/problems/amicable-numbers.html",
    "title": "",
    "section": "",
    "text": "Amicable numbers\n\n\nmedium\n\n\n\nتسمى الأعداد الطبيعية \\(A\\) و\\(B\\) أعدادًا صديقة إذا كان \\(B\\) مساويًا لمجموع جميع القواسم الصحيحة لـ \\(A\\) ما عدا \\(A\\) نفسه، و\\(A\\) مساويًا لمجموع جميع القواسم الصحيحة لـ \\(B\\) ما عدا \\(B\\) نفسه.\nعلى سبيل المثال، الأعداد 220 و284 هي أعداد صديقة.\nلديك عدد طبيعي \\(M\\) و\\(M\\) استعلامًا. كل استعلام يحتوي على عدد \\(n_i\\). لكل استعلام، أجب: كم عدد أزواج الأعداد الصديقة موجودة بحيث لا يزيد أي عدد في الزوج عن \\(n_i\\)؟\nالمدخلات:\n\nالسطر الأول يحتوي على العدد الطبيعي \\(M\\).\nالأسطر التالية \\(M\\) تحتوي كل منها على عدد طبيعي \\(n_i\\).\n\nالمخرجات:\n\nلكل استعلام، اطبع عدد أزواج الأعداد الصديقة في سطر جديد.\n\nالمحددات:\n\n\\(1 \\leq M \\leq 10^5\\)\n\\(1 \\leq n \\leq 10^5\\)\n\nإذا كانت هذه المسألة صعبة جدًا عليك، فحاول حلّها عندما\n\n\\(m = 1\\) و\\(n \\leq 10^5\\)\n\nأو، إذا كانت لا تزال صعبة جدًا، فحاول حلّها عندما\n\n\\(m = 1\\) و\\(n \\leq 3000\\)\n\nمثال:\nمدخل:\n1\n2700\nمخرج:\n2",
    "crumbs": [
      "المرحلة 4",
      "Practice Problems",
      "Amicable Numbers"
    ]
  },
  {
    "objectID": "b3/problems/amicable-numbers.html#amicable-numbers",
    "href": "b3/problems/amicable-numbers.html#amicable-numbers",
    "title": "",
    "section": "",
    "text": "Amicable numbers\n\n\nmedium\n\n\n\nتسمى الأعداد الطبيعية \\(A\\) و\\(B\\) أعدادًا صديقة إذا كان \\(B\\) مساويًا لمجموع جميع القواسم الصحيحة لـ \\(A\\) ما عدا \\(A\\) نفسه، و\\(A\\) مساويًا لمجموع جميع القواسم الصحيحة لـ \\(B\\) ما عدا \\(B\\) نفسه.\nعلى سبيل المثال، الأعداد 220 و284 هي أعداد صديقة.\nلديك عدد طبيعي \\(M\\) و\\(M\\) استعلامًا. كل استعلام يحتوي على عدد \\(n_i\\). لكل استعلام، أجب: كم عدد أزواج الأعداد الصديقة موجودة بحيث لا يزيد أي عدد في الزوج عن \\(n_i\\)؟\nالمدخلات:\n\nالسطر الأول يحتوي على العدد الطبيعي \\(M\\).\nالأسطر التالية \\(M\\) تحتوي كل منها على عدد طبيعي \\(n_i\\).\n\nالمخرجات:\n\nلكل استعلام، اطبع عدد أزواج الأعداد الصديقة في سطر جديد.\n\nالمحددات:\n\n\\(1 \\leq M \\leq 10^5\\)\n\\(1 \\leq n \\leq 10^5\\)\n\nإذا كانت هذه المسألة صعبة جدًا عليك، فحاول حلّها عندما\n\n\\(m = 1\\) و\\(n \\leq 10^5\\)\n\nأو، إذا كانت لا تزال صعبة جدًا، فحاول حلّها عندما\n\n\\(m = 1\\) و\\(n \\leq 3000\\)\n\nمثال:\nمدخل:\n1\n2700\nمخرج:\n2",
    "crumbs": [
      "المرحلة 4",
      "Practice Problems",
      "Amicable Numbers"
    ]
  },
  {
    "objectID": "b3/problems/counting-rooms.html",
    "href": "b3/problems/counting-rooms.html",
    "title": "",
    "section": "",
    "text": "Counting Rooms\n\nCSES\neasy\n\n\n\nأُعطيت خريطة لمبنى، ومهمتك حساب عدد الغرف فيه. حجم الخريطة هو n × m مربعات، وكل مربع إما أرضية أو جدار. يمكنك المشي يساراً ويميناً وأعلى وأسفل عبر مربعات الأرضية.\nالمدخل:\n\nالسطر الأول: عددان صحيحان n و m — الارتفاع والعرض.\nثم n أسطر: كل سطر يحتوي m حرفاً:\n\n. أرضية\n# جدار\n\n\nالمخرجات:\n\nاطبع عدداً صحيحاً واحداً: عدد الغرف.\n\nالقيود:\n\n1 ≤ n, m ≤ 1000\n\nمثال:\nالمدخل:\n\n5 8\n########\n#..#...#\n####.#.#\n#..#...#\n########\n\nالمخرجات:\n\n3\n\n\n\n\n\n\nSolution\n\n“الغرفة” هي بالضبط مكوّن متصل من خلايا الأرضية . باستخدام حركات بأربعة اتجاهات.\nإذن تصبح المهمة:\nاحسب كم مكوّناً متصلاً من . موجوداً في الشبكة.\nنمسح الشبكة. كلما وجدنا خلية أرضية غير مُزارة، نبدأ منها BFS/DFS ونعلّم جميع خلايا الأرضية القابلة للوصول على أنها مُزارة. كل بداية كهذه تمثل غرفة واحدة.\n\n\n\nاعتبر كل خلية أرضية عقدة. وأضف أحرفاً بين خلايا الأرضية المتجاورة (أعلى/أسفل/يسار/يمين). حينها كل غرفة هي مكوّن متصل واحد في هذا الرسم البياني.\n\n\n\n\nالمتغير rooms بعد المسح يساوي عدد المكوّنات المتصلة لخلايا .، وهذا بالضبط هو عدد الغرف.\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;queue&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    vector&lt;string&gt; grid(n);\n    for (int i = 0; i &lt; n; i++) cin &gt;&gt; grid[i];\n\n    vector&lt;vector&lt;char&gt;&gt; vis(n, vector&lt;char&gt;(m, 0));\n    int rooms = 0;\n\n    const int dr[4] = {-1, 1, 0, 0};\n    const int dc[4] = {0, 0, -1, 1};\n\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; m; j++) {\n            if (grid[i][j] != '.' || vis[i][j]) continue;\n\n            rooms++;\n            queue&lt;pair&lt;int,int&gt;&gt; q;\n            q.push({i, j});\n            vis[i][j] = 1;\n\n            while (!q.empty()) {\n                auto [r, c] = q.front(); q.pop();\n\n                for (int k = 0; k &lt; 4; k++) {\n                    int nr = r + dr[k];\n                    int nc = c + dc[k];\n                    if (nr &lt; 0 || nr &gt;= n || nc &lt; 0 || nc &gt;= m) continue;\n                    if (grid[nr][nc] != '.' || vis[nr][nc]) continue;\n                    vis[nr][nc] = 1;\n                    q.push({nr, nc});\n                }\n            }\n        }\n    }\n\n    cout &lt;&lt; rooms &lt;&lt; \"\\n\";\n    return 0;\n}",
    "crumbs": [
      "المرحلة 4",
      "Problems",
      "Counting Rooms"
    ]
  },
  {
    "objectID": "b3/problems/counting-rooms.html#counting-rooms",
    "href": "b3/problems/counting-rooms.html#counting-rooms",
    "title": "",
    "section": "",
    "text": "Counting Rooms\n\nCSES\neasy\n\n\n\nأُعطيت خريطة لمبنى، ومهمتك حساب عدد الغرف فيه. حجم الخريطة هو n × m مربعات، وكل مربع إما أرضية أو جدار. يمكنك المشي يساراً ويميناً وأعلى وأسفل عبر مربعات الأرضية.\nالمدخل:\n\nالسطر الأول: عددان صحيحان n و m — الارتفاع والعرض.\nثم n أسطر: كل سطر يحتوي m حرفاً:\n\n. أرضية\n# جدار\n\n\nالمخرجات:\n\nاطبع عدداً صحيحاً واحداً: عدد الغرف.\n\nالقيود:\n\n1 ≤ n, m ≤ 1000\n\nمثال:\nالمدخل:\n\n5 8\n########\n#..#...#\n####.#.#\n#..#...#\n########\n\nالمخرجات:\n\n3",
    "crumbs": [
      "المرحلة 4",
      "Problems",
      "Counting Rooms"
    ]
  },
  {
    "objectID": "b3/problems/product-of-squares.html",
    "href": "b3/problems/product-of-squares.html",
    "title": "",
    "section": "",
    "text": "Product of Squares\n\n\neasy\n\n\n\nلديك عدد صحيح \\(N\\)، يليه \\(N\\) أعداد صحيحة موجبة. لكل عدد \\(A\\) معطى، حدّد ما إذا كان يمكن تمثيله كحاصل ضرب مربعين كاملين لعددين قيمتهما أكبر من 1. بشكل رسمي، تحتاج للتحقق مما إذا كان هناك أعداد صحيحة \\(x &gt; 1\\) و\\(y &gt; 1\\) بحيث:\n\\[A = x^2 \\cdot y^2\\]\nالمدخلات:\n\nالسطر الأول يحتوي على عدد صحيح \\(N\\).\nالأسطر التالية \\(N\\) تحتوي على الأعداد \\(A\\) المطلوب التحقق منها.\n\nالمخرجات:\n\nلكل عدد \\(A\\)، اطبع “YES” إذا كان يحقق الشرط، وإلا اطبع “NO”.\n\nالمحددات:\n\n\\(1 \\leq N \\leq 1000\\)\n\\(1 \\leq A \\leq 10^{18}\\)\n\nإذا كانت هذه المسألة صعبة جدًا عليك، فحاول حلّها عندما\n\n\\(1 \\leq A \\leq 10^9\\)\n\nأو، إذا كانت لا تزال صعبة جدًا، فحاول حلّها عندما\n\n\\(1 \\leq A \\leq 10^4\\)\n\nمثال:\nمدخل:\n3\n9\n144\n234\nمخرج:\nNO \nYES\nNO",
    "crumbs": [
      "المرحلة 4",
      "Practice Problems",
      "Product of Squares"
    ]
  },
  {
    "objectID": "b3/problems/product-of-squares.html#product-of-squares",
    "href": "b3/problems/product-of-squares.html#product-of-squares",
    "title": "",
    "section": "",
    "text": "Product of Squares\n\n\neasy\n\n\n\nلديك عدد صحيح \\(N\\)، يليه \\(N\\) أعداد صحيحة موجبة. لكل عدد \\(A\\) معطى، حدّد ما إذا كان يمكن تمثيله كحاصل ضرب مربعين كاملين لعددين قيمتهما أكبر من 1. بشكل رسمي، تحتاج للتحقق مما إذا كان هناك أعداد صحيحة \\(x &gt; 1\\) و\\(y &gt; 1\\) بحيث:\n\\[A = x^2 \\cdot y^2\\]\nالمدخلات:\n\nالسطر الأول يحتوي على عدد صحيح \\(N\\).\nالأسطر التالية \\(N\\) تحتوي على الأعداد \\(A\\) المطلوب التحقق منها.\n\nالمخرجات:\n\nلكل عدد \\(A\\)، اطبع “YES” إذا كان يحقق الشرط، وإلا اطبع “NO”.\n\nالمحددات:\n\n\\(1 \\leq N \\leq 1000\\)\n\\(1 \\leq A \\leq 10^{18}\\)\n\nإذا كانت هذه المسألة صعبة جدًا عليك، فحاول حلّها عندما\n\n\\(1 \\leq A \\leq 10^9\\)\n\nأو، إذا كانت لا تزال صعبة جدًا، فحاول حلّها عندما\n\n\\(1 \\leq A \\leq 10^4\\)\n\nمثال:\nمدخل:\n3\n9\n144\n234\nمخرج:\nNO \nYES\nNO",
    "crumbs": [
      "المرحلة 4",
      "Practice Problems",
      "Product of Squares"
    ]
  },
  {
    "objectID": "b3/problems/tree-matching.html",
    "href": "b3/problems/tree-matching.html",
    "title": "",
    "section": "",
    "text": "Tree Matching\n\nCSES\nmedium\n\n\n\nأُعطيت شجرة مكوّنة من n عقد.\nالمطابقة (matching) هي مجموعة من الأحرف بحيث تكون كل عقدة طرفاً في حرف واحد على الأكثر. ما هو أكبر عدد ممكن من الأحرف في مطابقة؟\nالمدخل:\n\nالسطر الأول: عدد صحيح n — عدد العقد (1..n).\nثم n-1 سطراً: أحرف a b تصف حرفاً غير موجه في الشجرة.\n\nالمخرجات:\n\nاطبع عدداً صحيحاً واحداً: أكبر حجم لمطابقة.\n\nالقيود:\n\n1 ≤ n ≤ 2 · 10^5\n\nمثال:\nالمدخل:\n\n5\n1 2\n1 3\n3 4\n3 5\n\nالمخرجات:\n\n2\n\nالشرح: إحدى المطابقات الممكنة هي (1,2) و (3,4).\n\n\n\n\n\nSolution\n\nنريد أكبر مجموعة من الأحرف بحيث لا يشترك أي حرفين مختارين في طرف (عقدة) واحدة.\nعلى الشجرة، يمكن حل ذلك باستخدام DP بعد تجذير الشجرة. الفكرة المحلية الأساسية هي: هل العقدة “مُستخدمة” أصلاً لأنها متطابقة مع أبيها؟ لأن ذلك يمنعها من التطابق مع أي ابن.\n\n\n\nنجذر الشجرة عند العقدة 1. لكل عقدة v نحسب:\n\ndp0[v]: أكبر حجم مطابقة داخل الشجرة الفرعية لـ v عندما لا تكون v متطابقة مع أبيها (أي أن v حرة: يمكن أن تتطابق مع ابن واحد على الأكثر، أو لا تتطابق مع أي ابن)\ndp1[v]: أكبر حجم مطابقة داخل الشجرة الفرعية لـ v عندما تكون v متطابقة مع أبيها (أي أن v مستخدمة مسبقاً، ولا يمكنها التطابق مع أي ابن)\n\nالجواب سيكون dp0[root] لأن الجذر ليس له أب.\n\n\n\n\nلتكن children(v) هي الجيران باستثناء الأب.\n\n\nعندها لا يمكن لـ v التطابق مع الأبناء، لذلك يجب أن يكون كل ابن c في حالة “غير متطابق مع الأب”:\n\n\\(dp1[v] = \\sum_{c \\in children(v)} dp0[c]\\)\n\n\n\n\nهناك احتمالان:\n\nv لا تتطابق مع أي ابن عندها كل الأبناء مستقلون في الحالة dp0:\n\n\n\\(base = \\sum_{c} dp0[c]\\)\n\n\nv تتطابق مع ابن واحد بالضبط u اختيار الحرف (v,u) يضيف +1، ويجبر الابن u أن يكون “متطابقاً مع أبيه” أي في الحالة dp1[u]. باقي الأبناء يبقون في dp0.\n\nإذا طابقنا v مع ابن معيّن u فالمجموع:\n\n\\(base - dp0[u] + dp1[u] + 1\\)\n\nنختار أفضل u أو نختار عدم التطابق:\n\n\\(dp0[v] = \\max\\Big(base,\\ \\max_{u \\in children(v)} (base - dp0[u] + dp1[u] + 1)\\Big)\\)\n\n\n\n\n\n\n\n\ndp0[v] = أفضل حجم مطابقة داخل الشجرة الفرعية لـ v عندما تكون v حرة بالنسبة لأبيها. dp1[v] = أفضل حجم مطابقة داخل الشجرة الفرعية لـ v عندما تكون v متطابقة مسبقاً مع أبيها.\nهذه الحالات تغطي كل الاحتمالات لأن التفاعل الوحيد بين الشجرة الفرعية وباقي الشجرة يكون عبر حرف الأب.\n\n\n\n\n\nإذا كانت v مستخدمة بسبب الأب dp1[v] فهي لا يمكن أن تكون طرفاً في أي حرف مطابقة آخر → لا يمكنها التطابق مع الأبناء → مجموع dp0 للأبناء.\nإذا كانت v حرة dp0[v] فيمكنها التطابق مع ابن واحد على الأكثر. إما لا تطابق أحداً base أو تطابق ابناً واحداً u، فنحوّل حالة ذلك الابن فقط إلى dp1[u] ونضيف حرفاً واحداً.\n\nإذن الصيغ السابقة ضرورية وكافية.\n\n\n\n\nنحسب الأبناء أولاً عبر DFS، ثم:\n\nbase = sum(dp0[child])\ndp1[v] = base\ndp0[v] = max(base, max(base - dp0[u] + dp1[u] + 1))\n\n\n\n\n\nلعقدة ورقية v:\n\nلا يوجد أبناء → المجاميع تساوي 0\ndp1[v] = 0 (لا يمكن التطابق مع الأبناء)\ndp0[v] = 0 (لا يوجد ابن لتطابقه)\n\nصحيح.\n\n\n\n\nDFS بترتيب ما بعد الزيارة (Post-order): نحسب DP للأبناء قبل الأب. كل عقدة تستخدم فقط قيم DP للأبناء، لذا التبعيات محققة.\n\n\n\n\nكل حرف يُعالج عدداً ثابتاً من المرات.\n\nالزمن: O(n)\nالذاكرة: O(n) لقائمة المجاورات + DP + الاستدعاء التراجعي.\n\n\n\n\n\n\nاطبع dp0[1] بعد حساب DP من الجذر 1.\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; g;\nvector&lt;long long&gt; dp0, dp1;\n\nvoid dfs(int v, int p) {\n    long long base = 0;\n\n    // First: solve children\n    for (int to : g[v]) {\n        if (to == p) continue;\n        dfs(to, v);\n        base += dp0[to];\n    }\n\n    // If v is matched with parent -&gt; cannot match any child\n    dp1[v] = base;\n\n    // If v is not matched with parent -&gt; either match with no child, or with exactly one child\n    dp0[v] = base;\n\n    for (int u : g[v]) {\n        if (u == p) continue;\n        long long candidate = base - dp0[u] + dp1[u] + 1; // match (v,u)\n        dp0[v] = max(dp0[v], candidate);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin &gt;&gt; n;\n\n    g.assign(n + 1, {});\n    for (int i = 0; i &lt; n - 1; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    dp0.assign(n + 1, 0);\n    dp1.assign(n + 1, 0);\n\n    int root = 1;\n    dfs(root, -1);\n\n    cout &lt;&lt; dp0[root] &lt;&lt; \"\\n\";\n    return 0;\n}",
    "crumbs": [
      "المرحلة 4",
      "Problems",
      "Tree Matching"
    ]
  },
  {
    "objectID": "b3/problems/tree-matching.html#tree-matching",
    "href": "b3/problems/tree-matching.html#tree-matching",
    "title": "",
    "section": "",
    "text": "Tree Matching\n\nCSES\nmedium\n\n\n\nأُعطيت شجرة مكوّنة من n عقد.\nالمطابقة (matching) هي مجموعة من الأحرف بحيث تكون كل عقدة طرفاً في حرف واحد على الأكثر. ما هو أكبر عدد ممكن من الأحرف في مطابقة؟\nالمدخل:\n\nالسطر الأول: عدد صحيح n — عدد العقد (1..n).\nثم n-1 سطراً: أحرف a b تصف حرفاً غير موجه في الشجرة.\n\nالمخرجات:\n\nاطبع عدداً صحيحاً واحداً: أكبر حجم لمطابقة.\n\nالقيود:\n\n1 ≤ n ≤ 2 · 10^5\n\nمثال:\nالمدخل:\n\n5\n1 2\n1 3\n3 4\n3 5\n\nالمخرجات:\n\n2\n\nالشرح: إحدى المطابقات الممكنة هي (1,2) و (3,4).",
    "crumbs": [
      "المرحلة 4",
      "Problems",
      "Tree Matching"
    ]
  },
  {
    "objectID": "b3/trees/intro.html",
    "href": "b3/trees/intro.html",
    "title": "الأشجار",
    "section": "",
    "text": "الشجرة هي بنية مكوّنة من عُقد (نقاط) متصلة بواسطة أحرف (خطوط).\n\n\n\nمثال لشجرة\n\n\n\n\nيكون الرسم البياني شجرة إذا حقق الشرطين معاً:\n\nمتصل: تستطيع الوصول إلى كل عقدة من أي عقدة أخرى عبر الأحرف.\nبلا دورات: لا يمكنك البدء من عقدة، وتتبع أحرفاً، ثم العودة لنفس العقدة دون تكرار أحرف.\n\nقاعدة مكافئة ومفيدة جداً:\n\nبين أي عقدتين، يوجد بالضبط مسار بسيط واحد.\n\nخاصية “المسار الوحيد” هي السبب الرئيسي لظهور الأشجار كثيراً في حل المسائل.\n\n\n\n\n\nإذا كانت الشجرة تحتوي على n عقداً، فإنها تحتوي بالضبط على:\n\nn - 1 حرفاً\n\n\n\n\nإضافة حرف واحد → تُنشئ دورة\nفي الشجرة، يوجد بالضبط مسار واحد بين أي عقدتين u و v.\nإذا أضفت حرفاً جديداً (u, v):\n\nالمسار القديم من u إلى v ما زال موجوداً\nبالإضافة إلى الحرف المباشر الجديد\n\nإذن أصبح لديك حلقة: (المسار القديم u→v) + (الحرف الجديد v→u) → وهذه دورة. وتكون دورة واحدة بالضبط لأن مسار u↔︎v في الشجرة فريد.\nإزالة حرف واحد → تصبح غير متصلة\nكل حرف في الشجرة هو جسر. إذا أزلت حرفاً (u, v):\n\nلا يوجد أي طريق آخر بين u و v (وإلا لكانت هناك دورة)\nلذلك تنقسم الشجرة إلى مكوّنين منفصلين (جزئين).\n\n\n\n\n\nغالباً ما تُعطى الأشجار بأحرف غير موجهة (في الاتجاهين). ولجعل كثير من المسائل أسهل، نختار عقدة واحدة لتكون الجذر.\nبعد اختيار الجذر:\n\nكل عقدة (ما عدا الجذر) لها أب واحد فقط (الجار الأقرب للجذر).\nقد يكون للعقدة عدة أبناء (جيران أبعد عن الجذر).\ndepth[v] = عدد الأحرف من الجذر إلى v.\nsubtree(v) = v وكل ما تحتها (نسلها).\n\nتجذير الشجرة لا يغيّر الشجرة نفسها، لكنه يعطيها اتجاهاً و“هيكل عائلي” يساعدنا في التفكير والحساب.\n\n\n\nسنفترض:\n\nint n;                          // nodes are 0..n-1\nvector&lt;int&gt; g[n];       // adjacency list\n\nكل g[v] تحتوي جميع جيران العقدة v.\n\n\n\n\nvector&lt;int&gt; parent(n, -1), depth(n, 0);\n\nvoid dfs(int v, int p) {\n    parent[v] = p;\n    for (int to : g[v]) {\n        if (to == p) continue;\n        depth[to] = depth[v] + 1;\n        dfs(to, v);\n    }\n}\n\n\n\n\nparent[v]: العقدة التي فوق v في الشجرة المُجذّرة\ndepth[v]: المسافة من الجذر\n\n\n\n\n\nsub[v] = عدد العقد في الشجرة الفرعية لـ v (بما فيها v).\n\nvector&lt;int&gt; sub(n, 1);\n\nvoid dfs_subtree(int v, int p) {\n    sub[v] = 1;\n    for (int to : g[v]) {\n        if (to == p) continue;\n        dfs_subtree(to, v);\n        sub[v] += sub[to];\n    }\n}\n\nاستخدامات شائعة:\n\nحساب حجم فرع معيّن\nحساب كم زوج أو مسار “يمر” عبر حرف\n\n\n\n\n\nالشجرة = متصلة، ولا تحتوي دورات\nيوجد مسار وحيد بين أي عقدتين\nn عقد ⇒ n-1 حرف\nاختر جذراً لتعريف الأب/الأبناء/العمق/الشجرة الفرعية\nDFS تبني parent و depth وأحجام الأشجار الفرعية\n```",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/intro.html#ما-الذي-يجعلها-شجرة",
    "href": "b3/trees/intro.html#ما-الذي-يجعلها-شجرة",
    "title": "الأشجار",
    "section": "",
    "text": "يكون الرسم البياني شجرة إذا حقق الشرطين معاً:\n\nمتصل: تستطيع الوصول إلى كل عقدة من أي عقدة أخرى عبر الأحرف.\nبلا دورات: لا يمكنك البدء من عقدة، وتتبع أحرفاً، ثم العودة لنفس العقدة دون تكرار أحرف.\n\nقاعدة مكافئة ومفيدة جداً:\n\nبين أي عقدتين، يوجد بالضبط مسار بسيط واحد.\n\nخاصية “المسار الوحيد” هي السبب الرئيسي لظهور الأشجار كثيراً في حل المسائل.",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/intro.html#حقائق-مهمة",
    "href": "b3/trees/intro.html#حقائق-مهمة",
    "title": "الأشجار",
    "section": "",
    "text": "إذا كانت الشجرة تحتوي على n عقداً، فإنها تحتوي بالضبط على:\n\nn - 1 حرفاً\n\n\n\n\nإضافة حرف واحد → تُنشئ دورة\nفي الشجرة، يوجد بالضبط مسار واحد بين أي عقدتين u و v.\nإذا أضفت حرفاً جديداً (u, v):\n\nالمسار القديم من u إلى v ما زال موجوداً\nبالإضافة إلى الحرف المباشر الجديد\n\nإذن أصبح لديك حلقة: (المسار القديم u→v) + (الحرف الجديد v→u) → وهذه دورة. وتكون دورة واحدة بالضبط لأن مسار u↔︎v في الشجرة فريد.\nإزالة حرف واحد → تصبح غير متصلة\nكل حرف في الشجرة هو جسر. إذا أزلت حرفاً (u, v):\n\nلا يوجد أي طريق آخر بين u و v (وإلا لكانت هناك دورة)\nلذلك تنقسم الشجرة إلى مكوّنين منفصلين (جزئين).",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/intro.html#تجذير-الشجرة",
    "href": "b3/trees/intro.html#تجذير-الشجرة",
    "title": "الأشجار",
    "section": "",
    "text": "غالباً ما تُعطى الأشجار بأحرف غير موجهة (في الاتجاهين). ولجعل كثير من المسائل أسهل، نختار عقدة واحدة لتكون الجذر.\nبعد اختيار الجذر:\n\nكل عقدة (ما عدا الجذر) لها أب واحد فقط (الجار الأقرب للجذر).\nقد يكون للعقدة عدة أبناء (جيران أبعد عن الجذر).\ndepth[v] = عدد الأحرف من الجذر إلى v.\nsubtree(v) = v وكل ما تحتها (نسلها).\n\nتجذير الشجرة لا يغيّر الشجرة نفسها، لكنه يعطيها اتجاهاً و“هيكل عائلي” يساعدنا في التفكير والحساب.",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/intro.html#تمثيل-الشجرة-في-الكود",
    "href": "b3/trees/intro.html#تمثيل-الشجرة-في-الكود",
    "title": "الأشجار",
    "section": "",
    "text": "سنفترض:\n\nint n;                          // nodes are 0..n-1\nvector&lt;int&gt; g[n];       // adjacency list\n\nكل g[v] تحتوي جميع جيران العقدة v.",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/intro.html#بناء-الأب-والعمق-باستخدام-dfs",
    "href": "b3/trees/intro.html#بناء-الأب-والعمق-باستخدام-dfs",
    "title": "الأشجار",
    "section": "",
    "text": "vector&lt;int&gt; parent(n, -1), depth(n, 0);\n\nvoid dfs(int v, int p) {\n    parent[v] = p;\n    for (int to : g[v]) {\n        if (to == p) continue;\n        depth[to] = depth[v] + 1;\n        dfs(to, v);\n    }\n}\n\n\n\n\nparent[v]: العقدة التي فوق v في الشجرة المُجذّرة\ndepth[v]: المسافة من الجذر",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/intro.html#حجم-الشجرة-الفرعية",
    "href": "b3/trees/intro.html#حجم-الشجرة-الفرعية",
    "title": "الأشجار",
    "section": "",
    "text": "sub[v] = عدد العقد في الشجرة الفرعية لـ v (بما فيها v).\n\nvector&lt;int&gt; sub(n, 1);\n\nvoid dfs_subtree(int v, int p) {\n    sub[v] = 1;\n    for (int to : g[v]) {\n        if (to == p) continue;\n        dfs_subtree(to, v);\n        sub[v] += sub[to];\n    }\n}\n\nاستخدامات شائعة:\n\nحساب حجم فرع معيّن\nحساب كم زوج أو مسار “يمر” عبر حرف",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "الأشجار"
    ]
  },
  {
    "objectID": "b3/trees/intro.html#ملخص-سريع",
    "href": "b3/trees/intro.html#ملخص-سريع",
    "title": "الأشجار",
    "section": "",
    "text": "الشجرة = متصلة، ولا تحتوي دورات\nيوجد مسار وحيد بين أي عقدتين\nn عقد ⇒ n-1 حرف\nاختر جذراً لتعريف الأب/الأبناء/العمق/الشجرة الفرعية\nDFS تبني parent و depth وأحجام الأشجار الفرعية",
    "crumbs": [
      "المرحلة 4",
      "Trees",
      "الأشجار"
    ]
  }
]