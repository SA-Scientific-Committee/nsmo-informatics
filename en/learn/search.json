[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "National Olympiad in Science and Mathematics (NSMO)",
    "section": "",
    "text": "National Olympiad in Science and Mathematics (NSMO)\nThe National Olympiad in Science and Mathematics (NSMO) is an annual national competition organized in collaboration with the Ministry of Education. The competition includes several stages throughout the academic year, targeting Saudi students in general education in the fields of Mathematics, Science, Informatics, Chemistry, Physics, and Biology.\nStages of the competition:\n\nStage 1: City and governorate.\nStage 2: General education administrations.\nStage 3: Selecting students to represent education administrations.\nStega 4: The major national competition at the Kingdom level.\n\n\n\nInformatics (Competitive Programming)\nInformatics is one of the subjects covered within NSMO. This website will prepare you for these contest, stage by stage. It introduces you to the world of competitive programming, no prior experience is required.\nCompetitive programming is a form of mind sport in which participants solve algorithmic problems through programming. These problems are presented in contests that typically last several hours. To solve them, you must design an efficient algorithm and implement it in a programming language.\nWe’ll start by learning C++, the most widely used language in competitive programming. After that, we’ll dive into solving problems and exploring fundamental algorithms and techniques.\nBeing skilled in mathematics goes a long way in competitive programming. As you progress, you’ll find that analytical thinking is the most important skill of all."
  },
  {
    "objectID": "b2/knapsack1.html",
    "href": "b2/knapsack1.html",
    "title": "",
    "section": "",
    "text": "Knapsack 1\n\nAtcoder\nmedium\n\n\n\nGiven a set of \\(N\\) elements, each element \\(i\\) has a weight \\(w_i\\) and value \\(v_i\\). Select a subset of elements such that the total weight does not exceed \\(W\\). Determine the maximum possible total value.",
    "crumbs": [
      "Stage 3",
      "knapsack1.html"
    ]
  },
  {
    "objectID": "b2/knapsack1.html#knapsack-1",
    "href": "b2/knapsack1.html#knapsack-1",
    "title": "",
    "section": "",
    "text": "Knapsack 1\n\nAtcoder\nmedium\n\n\n\nGiven a set of \\(N\\) elements, each element \\(i\\) has a weight \\(w_i\\) and value \\(v_i\\). Select a subset of elements such that the total weight does not exceed \\(W\\). Determine the maximum possible total value.",
    "crumbs": [
      "Stage 3",
      "knapsack1.html"
    ]
  },
  {
    "objectID": "b2/rectangular-geometry.html",
    "href": "b2/rectangular-geometry.html",
    "title": "Rectangular Geometry",
    "section": "",
    "text": "Rectangular geometry deals with rectangles whose sides are aligned with the coordinate axes. In this section we focus on the basic ideas of these axis-parallel rectangles.\n\n\n\n\n\n\nNote\n\n\n\nWe assume the positive \\(X\\)-axis points to the right and the positive \\(Y\\)-axis points upward.\n\n\n\n\nRectangles can be represented by two coordinate points, either the top-left and bottom-right corners or the top-right and bottom-left corners.\n\n\n\n\n\n\nNote\n\n\n\nIn this section we’ll represent a rectangle using its top-right and bottom-left coordinates, where \\(tr_x\\) and \\(tr_y\\) are the coordinates of the top-right point, and \\(bl_x\\) and \\(bl_y\\) are the coordinates of the bottom-left point.\n\n\n\n\n\n\n\n\\(length\\) is the vertical side of the rectangle while \\(width\\) is the horizontal side.\n\\(width = tr_x - bl_x\\)\n\\(length = tr_y - bl_y\\)\n\n\n\nThe \\(area\\) of a rectangle is the product of \\(length\\) and \\(width\\).\n\\(area = length \\cdot width\\)\nint area(int bl_x, int bl_y, int tr_x, int tr_y) {\n  int length = tr_y - bl_y;\n  int width = tr_x - bl_x;\n  return length * width;\n}\n\n\n\nTo determine whether two rectangles \\(a\\) and \\(b\\) intersect, both their \\(X\\)-ranges and \\(Y\\)-ranges must overlap. It is often easier to check the opposite: determine whether at least one dimension doesn’t intersect. If either the \\(X\\) dimension or the \\(Y\\) dimension does not overlap, then the rectangles do not intersect.\nFor \\(Y\\) dimension:\n\n\\(a_{tr_y} \\le b_{bl_y}\\) or \\(b_{tr_y} \\le a_{bl_y}\\)\n\nFor \\(X\\) dimension:\n\n\\(a_{tr_x} \\le b_{bl_x}\\) or \\(b_{tr_x} \\le a_{bl_x}\\)\n\nIf any of those apply, the rectangles doesn’t intersect. otherwise they will intersect.\nbool are_intersected(int a_tr_x , int a_tr_y, int a_bl_x, int a_bl_y, int b_tr_x , int b_tr_y, int b_bl_x, int b_bl_y) {\n  if(a_tr_y &lt;= b_bl_y || b_tr_y &lt;= a_bl_y || a_tr_x &lt;= b_bl_x || b_tr_x &lt;= a_bl_x) {\n    return false;\n  }\n  else {\n    return true;\n  }\n}\n\n\n\nIf two rectangles \\(a\\) and \\(b\\) intersect then the rectangel \\(c\\) that is the intersection of \\(a\\) and \\(b\\) will be:\n\\(c_{tr_x} = min(a_{tr_x}, b_{tr_x})\\)\n\\(c_{tr_y} = min(a_{tr_y}, b_{tr_y})\\)\n\\(c_{bl_x} = max(a_{bl_x}, b_{bl_x})\\)\n\\(c_{bl_y} = max(a_{bl_y}, b_{bl_y})\\)\n\n\n\n\nThis geometry also applies in one-dimensional space, where we work with intervals instead of rectangles. An interval is represented by two numbers, \\(l\\) and \\(r\\), which denote the beginning and end of the interval.\n\n\n\n\n\\(length\\) is the area covered by the interval.\n\\(length = r - l\\)\n\n\n\nFor two intervals \\(a\\) and \\(b\\) in one dimension, we can check whether they do not intersect. If one interval lies entirely to the left or right of the other, they do not overlap. Otherwise, the intervals intersect:\n\n\\(a_{r} \\le b_{l}\\) or \\(b_{r} \\le a_{l}\\)\n\nbool are_intersected(int a_l , int a_r, int b_l , int b_r) {\n  if(b_l &lt;= a_r || a_l &lt;= b_r) {\n    return false;\n  }\n  else {\n    return true;\n  }\n}\n\n\n\nIf two intervals \\(a\\) and \\(b\\) intersect then the interval \\(c\\) that is the intersection of \\(a\\) and \\(b\\) will be:\n\\(c_{l} = max(a_{l}, b_{r})\\)\n\\(c_{r} = min(a_{l}, b_{tr_y})\\)\n\n\n\n\n\nIn the task Fence Painting - USACO we are given two intervals and are asked to print the total length covered by these intervals.\n\n\nIf the two give intervals don’t intersect then the area cover is the sum of both lengths. Otherwise, the solution will be the sum of both lengths subtracted by the intersected area.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n  // these two lines are just to do i/o in USACO\n  freopen(\"paint.in\", \"r\", stdin);\n    freopen(\"paint.out\", \"w\", stdout);\n\n    int a_l , a_r, b_l , b_r;\n  \n  cin &gt;&gt; a_l &gt;&gt; a_r &gt;&gt; b_l &gt;&gt; b_r;\n\n  // c represents the intersection between a and b.\n  int c_l = max(a_l, b_l), c_r = min(a_r, b_r);\n\n  int total = (a_r - a_l) + (b_r - b_l);\n  int intersection = (c_r - c_l);\n  \n  // now we need to check if a and b don't intersect\n  if(b_l &gt; a_r || a_l &gt; b_r){\n    cout &lt;&lt; total &lt;&lt; \"\\n\";\n  }\n  else{\n    cout &lt;&lt; total - intersection &lt;&lt; \"\\n\";\n  }\n}",
    "crumbs": [
      "Stage 3",
      "Rectangular Geometry"
    ]
  },
  {
    "objectID": "b2/rectangular-geometry.html#representing-rectangles",
    "href": "b2/rectangular-geometry.html#representing-rectangles",
    "title": "Rectangular Geometry",
    "section": "",
    "text": "Rectangles can be represented by two coordinate points, either the top-left and bottom-right corners or the top-right and bottom-left corners.\n\n\n\n\n\n\nNote\n\n\n\nIn this section we’ll represent a rectangle using its top-right and bottom-left coordinates, where \\(tr_x\\) and \\(tr_y\\) are the coordinates of the top-right point, and \\(bl_x\\) and \\(bl_y\\) are the coordinates of the bottom-left point.",
    "crumbs": [
      "Stage 3",
      "Rectangular Geometry"
    ]
  },
  {
    "objectID": "b2/rectangular-geometry.html#common-formulas",
    "href": "b2/rectangular-geometry.html#common-formulas",
    "title": "Rectangular Geometry",
    "section": "",
    "text": "\\(length\\) is the vertical side of the rectangle while \\(width\\) is the horizontal side.\n\\(width = tr_x - bl_x\\)\n\\(length = tr_y - bl_y\\)\n\n\n\nThe \\(area\\) of a rectangle is the product of \\(length\\) and \\(width\\).\n\\(area = length \\cdot width\\)\nint area(int bl_x, int bl_y, int tr_x, int tr_y) {\n  int length = tr_y - bl_y;\n  int width = tr_x - bl_x;\n  return length * width;\n}\n\n\n\nTo determine whether two rectangles \\(a\\) and \\(b\\) intersect, both their \\(X\\)-ranges and \\(Y\\)-ranges must overlap. It is often easier to check the opposite: determine whether at least one dimension doesn’t intersect. If either the \\(X\\) dimension or the \\(Y\\) dimension does not overlap, then the rectangles do not intersect.\nFor \\(Y\\) dimension:\n\n\\(a_{tr_y} \\le b_{bl_y}\\) or \\(b_{tr_y} \\le a_{bl_y}\\)\n\nFor \\(X\\) dimension:\n\n\\(a_{tr_x} \\le b_{bl_x}\\) or \\(b_{tr_x} \\le a_{bl_x}\\)\n\nIf any of those apply, the rectangles doesn’t intersect. otherwise they will intersect.\nbool are_intersected(int a_tr_x , int a_tr_y, int a_bl_x, int a_bl_y, int b_tr_x , int b_tr_y, int b_bl_x, int b_bl_y) {\n  if(a_tr_y &lt;= b_bl_y || b_tr_y &lt;= a_bl_y || a_tr_x &lt;= b_bl_x || b_tr_x &lt;= a_bl_x) {\n    return false;\n  }\n  else {\n    return true;\n  }\n}\n\n\n\nIf two rectangles \\(a\\) and \\(b\\) intersect then the rectangel \\(c\\) that is the intersection of \\(a\\) and \\(b\\) will be:\n\\(c_{tr_x} = min(a_{tr_x}, b_{tr_x})\\)\n\\(c_{tr_y} = min(a_{tr_y}, b_{tr_y})\\)\n\\(c_{bl_x} = max(a_{bl_x}, b_{bl_x})\\)\n\\(c_{bl_y} = max(a_{bl_y}, b_{bl_y})\\)",
    "crumbs": [
      "Stage 3",
      "Rectangular Geometry"
    ]
  },
  {
    "objectID": "b2/rectangular-geometry.html#single-dimensional-formulas",
    "href": "b2/rectangular-geometry.html#single-dimensional-formulas",
    "title": "Rectangular Geometry",
    "section": "",
    "text": "This geometry also applies in one-dimensional space, where we work with intervals instead of rectangles. An interval is represented by two numbers, \\(l\\) and \\(r\\), which denote the beginning and end of the interval.\n\n\n\n\n\\(length\\) is the area covered by the interval.\n\\(length = r - l\\)\n\n\n\nFor two intervals \\(a\\) and \\(b\\) in one dimension, we can check whether they do not intersect. If one interval lies entirely to the left or right of the other, they do not overlap. Otherwise, the intervals intersect:\n\n\\(a_{r} \\le b_{l}\\) or \\(b_{r} \\le a_{l}\\)\n\nbool are_intersected(int a_l , int a_r, int b_l , int b_r) {\n  if(b_l &lt;= a_r || a_l &lt;= b_r) {\n    return false;\n  }\n  else {\n    return true;\n  }\n}\n\n\n\nIf two intervals \\(a\\) and \\(b\\) intersect then the interval \\(c\\) that is the intersection of \\(a\\) and \\(b\\) will be:\n\\(c_{l} = max(a_{l}, b_{r})\\)\n\\(c_{r} = min(a_{l}, b_{tr_y})\\)",
    "crumbs": [
      "Stage 3",
      "Rectangular Geometry"
    ]
  },
  {
    "objectID": "b2/rectangular-geometry.html#example-task",
    "href": "b2/rectangular-geometry.html#example-task",
    "title": "Rectangular Geometry",
    "section": "",
    "text": "In the task Fence Painting - USACO we are given two intervals and are asked to print the total length covered by these intervals.\n\n\nIf the two give intervals don’t intersect then the area cover is the sum of both lengths. Otherwise, the solution will be the sum of both lengths subtracted by the intersected area.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n  // these two lines are just to do i/o in USACO\n  freopen(\"paint.in\", \"r\", stdin);\n    freopen(\"paint.out\", \"w\", stdout);\n\n    int a_l , a_r, b_l , b_r;\n  \n  cin &gt;&gt; a_l &gt;&gt; a_r &gt;&gt; b_l &gt;&gt; b_r;\n\n  // c represents the intersection between a and b.\n  int c_l = max(a_l, b_l), c_r = min(a_r, b_r);\n\n  int total = (a_r - a_l) + (b_r - b_l);\n  int intersection = (c_r - c_l);\n  \n  // now we need to check if a and b don't intersect\n  if(b_l &gt; a_r || a_l &gt; b_r){\n    cout &lt;&lt; total &lt;&lt; \"\\n\";\n  }\n  else{\n    cout &lt;&lt; total - intersection &lt;&lt; \"\\n\";\n  }\n}",
    "crumbs": [
      "Stage 3",
      "Rectangular Geometry"
    ]
  },
  {
    "objectID": "b2/backtracking.html",
    "href": "b2/backtracking.html",
    "title": "Backtracking",
    "section": "",
    "text": "Backtracking is a technique that explores all possible solutions to a problem. It builds solutions step by step and undoes choices whenever it finishes exploring a particular direction.\n\n\nA backtracking algorithm starts with an empty solution. In each step the algorithm goes recursively trying every possible step. After exploring all steps backtrack to the previous step by undoing a choice. The algorithm can be summarized as follows\n\nBegin with an empty solution.\nExtend the solution step by step.\nRecursively explore all different ways the solution can be constructed.\nUndo the last step done.\n\n\n\n\nTo generate all subsets of a sequence using backtracking, start with an empty solution. At each step, consider index i and try both possibilities: include a[i] in the subset or exclude it. After exploring each choice, undo the change. When i moves past the end of the sequence, record the current subset. An example of a code that prints all possible subsets is shown as follows:\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n = 3;\nint a[3] = {5, 3, 1};\nvector&lt;int&gt; v;\n\nvoid backtracking(int i) {\n\n    // if i exceeded the array, print the current subset\n    if (i == n) {\n        cout &lt;&lt; \"subset: \";\n        for (int j = 0; j &lt; v.size(); j++) {\n            cout &lt;&lt; v[j] &lt;&lt; ' ';\n        }\n        cout &lt;&lt; \"\\n\";\n        return;\n    }\n\n    // try to include a[i] in v\n    v.push_back(a[i]);\n    backtracking(i + 1); // try all possible solutions while a[i] is included in v\n    v.pop_back();         // undo the step of adding a[i]\n\n    // try to exclude a[i]\n    backtracking(i + 1);\n\n    // no undo needed because we didn't add anything\n}\n\nint main() {\n\n    backtracking(0);\n}\n\n\n\nIn the task Apple Dvision - CSES states: given array p of n elements. we will divide elements into two groups such that their absolute difference is as small as possible. you are asked to print the minimum difference.\n\n\nWe’ll use backtracking to try every possible grouping and print the one with minimum difference\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint n;\nint a[20];\nlong long sum1 = 0;         // sum of the first group\nlong long sum2 = 0;         // sum of the second group\nlong long ans = 2000000000; // very large number initially\n\nvoid backtracking(int i) {\n    // if i exceededs the array, update the solution so far\n    if (i == n) {\n        ans = min(ans, abs(sum1 - sum2));\n        return;\n    }\n    //try all possible choices\n\n    // try to include a[i] in group1\n    sum1 += a[i];\n    backtracking(i + 1);\n    sum1 -= a[i];\n\n    // try to include a[i] in group2\n    sum2 += a[i];\n    backtracking(i + 1);\n    sum2 -= a[i];\n\n}\n\nint main() {\n\n    cin &gt;&gt; n;\n\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; a[i];\n    }\n\n    backtracking(0);\n\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n}",
    "crumbs": [
      "Stage 3",
      "Backtracking"
    ]
  },
  {
    "objectID": "b2/backtracking.html#how-it-works",
    "href": "b2/backtracking.html#how-it-works",
    "title": "Backtracking",
    "section": "",
    "text": "A backtracking algorithm starts with an empty solution. In each step the algorithm goes recursively trying every possible step. After exploring all steps backtrack to the previous step by undoing a choice. The algorithm can be summarized as follows\n\nBegin with an empty solution.\nExtend the solution step by step.\nRecursively explore all different ways the solution can be constructed.\nUndo the last step done.",
    "crumbs": [
      "Stage 3",
      "Backtracking"
    ]
  },
  {
    "objectID": "b2/backtracking.html#generating-subsets",
    "href": "b2/backtracking.html#generating-subsets",
    "title": "Backtracking",
    "section": "",
    "text": "To generate all subsets of a sequence using backtracking, start with an empty solution. At each step, consider index i and try both possibilities: include a[i] in the subset or exclude it. After exploring each choice, undo the change. When i moves past the end of the sequence, record the current subset. An example of a code that prints all possible subsets is shown as follows:\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n = 3;\nint a[3] = {5, 3, 1};\nvector&lt;int&gt; v;\n\nvoid backtracking(int i) {\n\n    // if i exceeded the array, print the current subset\n    if (i == n) {\n        cout &lt;&lt; \"subset: \";\n        for (int j = 0; j &lt; v.size(); j++) {\n            cout &lt;&lt; v[j] &lt;&lt; ' ';\n        }\n        cout &lt;&lt; \"\\n\";\n        return;\n    }\n\n    // try to include a[i] in v\n    v.push_back(a[i]);\n    backtracking(i + 1); // try all possible solutions while a[i] is included in v\n    v.pop_back();         // undo the step of adding a[i]\n\n    // try to exclude a[i]\n    backtracking(i + 1);\n\n    // no undo needed because we didn't add anything\n}\n\nint main() {\n\n    backtracking(0);\n}",
    "crumbs": [
      "Stage 3",
      "Backtracking"
    ]
  },
  {
    "objectID": "b2/backtracking.html#exmaple-problem",
    "href": "b2/backtracking.html#exmaple-problem",
    "title": "Backtracking",
    "section": "",
    "text": "In the task Apple Dvision - CSES states: given array p of n elements. we will divide elements into two groups such that their absolute difference is as small as possible. you are asked to print the minimum difference.\n\n\nWe’ll use backtracking to try every possible grouping and print the one with minimum difference\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint n;\nint a[20];\nlong long sum1 = 0;         // sum of the first group\nlong long sum2 = 0;         // sum of the second group\nlong long ans = 2000000000; // very large number initially\n\nvoid backtracking(int i) {\n    // if i exceededs the array, update the solution so far\n    if (i == n) {\n        ans = min(ans, abs(sum1 - sum2));\n        return;\n    }\n    //try all possible choices\n\n    // try to include a[i] in group1\n    sum1 += a[i];\n    backtracking(i + 1);\n    sum1 -= a[i];\n\n    // try to include a[i] in group2\n    sum2 += a[i];\n    backtracking(i + 1);\n    sum2 -= a[i];\n\n}\n\nint main() {\n\n    cin &gt;&gt; n;\n\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; a[i];\n    }\n\n    backtracking(0);\n\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n}",
    "crumbs": [
      "Stage 3",
      "Backtracking"
    ]
  },
  {
    "objectID": "b2/problems/grid-paths-I.html",
    "href": "b2/problems/grid-paths-I.html",
    "title": "",
    "section": "",
    "text": "Grid Paths I\n\nCSES\neasy\n\n\n\nConsider an \\(n \\times n\\) grid whose squares may have traps. It is not allowed to move to a square with a trap.\nYour task is to calculate the number of paths from the upper-left square to the lower-right square. You can only move right or down.\nInput:\n\nFirst line: integer \\(n\\) — the size of the grid.\nNext \\(n\\) lines: each has \\(n\\) characters:\n\n. denotes an empty cell\n* denotes a trap\n\n\nOutput:\n\nPrint the number of valid paths modulo \\(10^9 + 7\\).\n\nConstraints:\n\n\\(1 \\le n \\le 1000\\)\n\nExample:\nInput:\n4\n....\n.*..\n...*\n*...\nOutput:\n3",
    "crumbs": [
      "Stage 3",
      "Problems",
      "Grid Paths I"
    ]
  },
  {
    "objectID": "b2/problems/grid-paths-I.html#grid-paths-i",
    "href": "b2/problems/grid-paths-I.html#grid-paths-i",
    "title": "",
    "section": "",
    "text": "Grid Paths I\n\nCSES\neasy\n\n\n\nConsider an \\(n \\times n\\) grid whose squares may have traps. It is not allowed to move to a square with a trap.\nYour task is to calculate the number of paths from the upper-left square to the lower-right square. You can only move right or down.\nInput:\n\nFirst line: integer \\(n\\) — the size of the grid.\nNext \\(n\\) lines: each has \\(n\\) characters:\n\n. denotes an empty cell\n* denotes a trap\n\n\nOutput:\n\nPrint the number of valid paths modulo \\(10^9 + 7\\).\n\nConstraints:\n\n\\(1 \\le n \\le 1000\\)\n\nExample:\nInput:\n4\n....\n.*..\n...*\n*...\nOutput:\n3",
    "crumbs": [
      "Stage 3",
      "Problems",
      "Grid Paths I"
    ]
  },
  {
    "objectID": "b2/problems/coin-combinations-I.html",
    "href": "b2/problems/coin-combinations-I.html",
    "title": "",
    "section": "",
    "text": "Coin Combinations I\n\nCSES\nmedium\n\n\n\nConsider a money system consisting of \\(n\\) coins. Each coin has a positive integer value. Your task is to calculate the number of distinct ways you can produce a money sum \\(x\\) using the available coins.\nOrder of coins matters in a combination. For example, if the coins are \\({2,3,5}\\) and the desired sum is \\(9\\), there are 8 ways:\n[ ]\nInput:\n\nThe first input line has two integers \\(n\\) and \\(x\\): the number of coins and the desired sum of money.\nThe second line has \\(n\\) distinct integers \\(c_1, c_2, \\dots, c_n\\): the value of each coin.\n\nOutput:\n\nPrint one integer: the number of ways to form the sum \\(x\\), modulo \\(10^9 + 7\\).\n\nConstraints:\n\n\\(1 \\le n \\le 100\\)\n\\(1 \\le x \\le 10^6\\)\n\\(1 \\le c_i \\le 10^6\\)\n\nExample:\nInput:\n3 9\n2 3 5\nOutput:\n8",
    "crumbs": [
      "Stage 3",
      "Practice Problems",
      "Coin Combinations I"
    ]
  },
  {
    "objectID": "b2/problems/coin-combinations-I.html#coin-combinations-i",
    "href": "b2/problems/coin-combinations-I.html#coin-combinations-i",
    "title": "",
    "section": "",
    "text": "Coin Combinations I\n\nCSES\nmedium\n\n\n\nConsider a money system consisting of \\(n\\) coins. Each coin has a positive integer value. Your task is to calculate the number of distinct ways you can produce a money sum \\(x\\) using the available coins.\nOrder of coins matters in a combination. For example, if the coins are \\({2,3,5}\\) and the desired sum is \\(9\\), there are 8 ways:\n[ ]\nInput:\n\nThe first input line has two integers \\(n\\) and \\(x\\): the number of coins and the desired sum of money.\nThe second line has \\(n\\) distinct integers \\(c_1, c_2, \\dots, c_n\\): the value of each coin.\n\nOutput:\n\nPrint one integer: the number of ways to form the sum \\(x\\), modulo \\(10^9 + 7\\).\n\nConstraints:\n\n\\(1 \\le n \\le 100\\)\n\\(1 \\le x \\le 10^6\\)\n\\(1 \\le c_i \\le 10^6\\)\n\nExample:\nInput:\n3 9\n2 3 5\nOutput:\n8",
    "crumbs": [
      "Stage 3",
      "Practice Problems",
      "Coin Combinations I"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html",
    "href": "b2/dynamic-programming.html",
    "title": "Dynamic Programming (DP)",
    "section": "",
    "text": "Dynamic Programming (DP) is a way to solve problems where:\n\nThe same subproblems repeat many times, and\nThe answer to the big problem can be built from answers to smaller subproblems.\n\nKey idea: Don’t recompute the same thing over and over. Instead, remember (memoize) results in an array or map and reuse them.\n\n\n\nWe define the Fibonacci sequence:\n\nF(0) = 0\nF(1) = 1\nF(n) = F(n-1) + F(n-2) for n ≥ 2\n\n\n\nint fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    return fib(n - 1) + fib(n - 2);\n}\nWhat’s wrong with this?\n\nfib(5) calls fib(4) and fib(3)\nfib(4) calls fib(3) and fib(2)\nfib(3) gets called again and again\n\nThis creates an exponential number of calls: Time ≈ O(2^n) — too slow for large n.\n\n\n\n\n\nWe create an array dp[] where:\n\ndp[n] = the value of fib(n) once computed.\n\nBefore computing fib(n), we check if it was already computed.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;long long&gt; dp;\n\nlong long fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    if (dp[n] != -1) return dp[n]; // already computed\n\n    dp[n] = fib(n - 1) + fib(n - 2);\n    return dp[n];\n}\n\nint main() {\n    int n = 50;\n    dp.assign(n + 1, -1);\n\n    cout &lt;&lt; \"F(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; fib(n) &lt;&lt; \"\\n\";\n}\nNow each fib(k) is computed once. All later calls just reuse the stored answer.\n\n\n\n\nLet’s use SRTBOT to organize our DP thinking:\n\n\nWhat does dp[i] represent?\n\ndp[i] = F(i), the i-th Fibonacci number.\n\n\n\n\n\nHow do we build big states from smaller ones?\n\ndp[i] = dp[i-1] + dp[i-2] for i ≥ 2\n\n\n\n\n\nTo compute dp[i], we use:\n\ndp[i-1]\ndp[i-2]\n\n\n\n\n\nWe must define the first values:\n\ndp[0] = 0\ndp[1] = 1\n\n\n\n\n\nFor bottom-up DP:\nfor (int i = 2; i &lt;= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n}\nWe compute from small to large (0 → 1 → 2 → ... → n).\n\n\n\n\n\nTime: each i from 0 to n is computed once → O(n)\nSpace: we store dp[0..n] → O(n) (can be reduced to O(1) by only keeping the last two values)\n\n\n\n\n\n\nProblem:\nYou are given an array cost[0..n-1], where cost[i] is the energy or money you pay when you step on position i.\nYou start before the array and want to go beyond the last index (to position n). From index i, you may move to:\n\ni + 1, or\ni + 2\n\nYou can start from index 0 or index 1.\nGoal: Find the minimum total cost to reach position n.\nExample:\ncost = [1, 100, 1, 1]\n\nPossible ways:\n\nStart at 0:\n  0 -&gt; 2 -&gt; n\n  cost = cost[0] + cost[2] = 1 + 1 = 2\n\nStart at 1:\n  1 -&gt; 3 -&gt; n\n  cost = 100 + 1 = 101\n\nAnswer = 2\n\n\n\nLet’s define a recursive function:\n\nsolve(i) = minimum cost to go from index i to the end (position n).\n\nTransitions:\n\nFrom i, you pay cost[i], then go to i+1 or i+2.\n\nint n;\nvector&lt;int&gt; cost;\n\nint solve(int i) {\n    if (i &gt;= n) return 0;\n\n    int take1 = solve(i + 1);\n    int take2 = solve(i + 2);\n    return cost[i] + min(take1, take2);\n}\n\nint main() {\n    cost = {1, 100, 1, 1};\n    n = cost.size();\n\n    int ans = min(solve(0), solve(1));  // can start from 0 or 1\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n}\nWhy is this slow?\n\nsolve(i) calls solve(i+1) and solve(i+2).\nThose calls overlap heavily (same i recomputed many times).\nTime becomes exponential in n (O(2^n)).\n\n\n\n\n\n\nWe store the answer for each i in dp[i]:\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint n;\nvector&lt;int&gt; cost;\nvector&lt;int&gt; dp;\n\nint solve(int i) {\n    if (i &gt;= n) return 0;\n\n    if (dp[i] != -1) return dp[i]; // already computed\n\n    int take1 = solve(i + 1);\n    int take2 = solve(i + 2);\n    dp[i] = cost[i] + min(take1, take2);\n    return dp[i];\n}\n\nint main() {\n    cost = {1, 100, 1, 1};\n    n = cost.size();\n    dp.assign(n, -1);\n\n    int ans = min(solve(0), solve(1));\n    cout &lt;&lt; \"Minimum cost = \" &lt;&lt; ans &lt;&lt; \"\\n\";\n}\nNow:\n\nEach solve(i) is computed once.\nTotal time is O(n) instead of exponential.\n\n\n\n\n\nWe can also do it iteratively from the end to the beginning.\nDefine:\n\ndp[i] = minimum cost to go from index i to the end.\n\nThen:\n\nIf i &gt;= n, cost is 0.\nFor i &lt; n:\n\ndp[i] = cost[i] + min(dp[i+1], dp[i+2])\n\n\nWe usually make the array slightly larger (size n+2) to avoid bounds checks.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; cost = {1, 100, 1, 1};\n    int n = cost.size();\n\n    vector&lt;int&gt; dp(n + 2, 0); // dp[n] and dp[n+1] = 0 by default\n\n    for (int i = n - 1; i &gt;= 0; i--) {\n        dp[i] = cost[i] + min(dp[i + 1], dp[i + 2]);\n    }\n\n    int ans = min(dp[0], dp[1]); // can start from index 0 or 1\n    cout &lt;&lt; \"Minimum cost = \" &lt;&lt; ans &lt;&lt; \"\\n\";\n}\n\n\n\n\nLet’s apply the SRTBOT framework.\n\n\n\ndp[i] = minimum total cost to go from index i to position n (i.e., to reach or go beyond the end).\n\n\n\n\n\nFrom index i, you:\n\nPay cost[i]\nThen jump to i+1 or i+2\n\nSo:\n\ndp[i] = cost[i] + min(dp[i+1], dp[i+2])\n\n\n\n\n\nFrom state i, we can transition to:\n\ni + 1\ni + 2\n\nThose are the only “edges” in our DP graph.\n\n\n\n\nWe define:\n\ndp[n] = 0 (already at/beyond the end, no more cost)\ndp[n+1] = 0 (safe padding to use dp[i+2] when i = n-1)\n\nIn top-down:\n\nIf i &gt;= n, return 0.\n\n\n\n\n\nFor bottom-up:\n\nWe process i from n-1 down to 0, so that:\n\ndp[i+1] and dp[i+2] are already computed when we calculate dp[i].\n\n\nfor (int i = n - 1; i &gt;= 0; i--) {\n    dp[i] = cost[i] + min(dp[i + 1], dp[i + 2]);\n}\n\n\n\n\n\nTime: We compute dp[i] once for each i in [0..n-1], each in O(1) → total O(n).\nSpace: We use an array dp of size n+2 → O(n). (We can even reduce it to O(1) by only keeping the last two values.)\n\n\n\n\n\n\nDynamic Programming usually appears when:\n\nYou can write a recursive solution that:\n\nCombines answers to smaller subproblems\nBut recomputes the same subproblems many times\n\nYou then:\n\nDefine a state (dp[...])\nDerive a recurrence\nAdd memoization (top-down) or fill a table (bottom-up)\n\n\nSRTBOT helps you structure your thinking:\n\nState → Recurrence → Transitions → Base cases → Order of computation → Time/space complexity",
    "crumbs": [
      "Stage 3",
      "Dynamic Programming (DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#warm-up-fibonacci-numbers",
    "href": "b2/dynamic-programming.html#warm-up-fibonacci-numbers",
    "title": "Dynamic Programming (DP)",
    "section": "",
    "text": "We define the Fibonacci sequence:\n\nF(0) = 0\nF(1) = 1\nF(n) = F(n-1) + F(n-2) for n ≥ 2\n\n\n\nint fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n    return fib(n - 1) + fib(n - 2);\n}\nWhat’s wrong with this?\n\nfib(5) calls fib(4) and fib(3)\nfib(4) calls fib(3) and fib(2)\nfib(3) gets called again and again\n\nThis creates an exponential number of calls: Time ≈ O(2^n) — too slow for large n.",
    "crumbs": [
      "Stage 3",
      "Dynamic Programming (DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#fixing-it-with-memoization-top-down-dp",
    "href": "b2/dynamic-programming.html#fixing-it-with-memoization-top-down-dp",
    "title": "Dynamic Programming (DP)",
    "section": "",
    "text": "We create an array dp[] where:\n\ndp[n] = the value of fib(n) once computed.\n\nBefore computing fib(n), we check if it was already computed.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;long long&gt; dp;\n\nlong long fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\n    if (dp[n] != -1) return dp[n]; // already computed\n\n    dp[n] = fib(n - 1) + fib(n - 2);\n    return dp[n];\n}\n\nint main() {\n    int n = 50;\n    dp.assign(n + 1, -1);\n\n    cout &lt;&lt; \"F(\" &lt;&lt; n &lt;&lt; \") = \" &lt;&lt; fib(n) &lt;&lt; \"\\n\";\n}\nNow each fib(k) is computed once. All later calls just reuse the stored answer.",
    "crumbs": [
      "Stage 3",
      "Dynamic Programming (DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#srtbot-framework-for-dp",
    "href": "b2/dynamic-programming.html#srtbot-framework-for-dp",
    "title": "Dynamic Programming (DP)",
    "section": "",
    "text": "Let’s use SRTBOT to organize our DP thinking:\n\n\nWhat does dp[i] represent?\n\ndp[i] = F(i), the i-th Fibonacci number.\n\n\n\n\n\nHow do we build big states from smaller ones?\n\ndp[i] = dp[i-1] + dp[i-2] for i ≥ 2\n\n\n\n\n\nTo compute dp[i], we use:\n\ndp[i-1]\ndp[i-2]\n\n\n\n\n\nWe must define the first values:\n\ndp[0] = 0\ndp[1] = 1\n\n\n\n\n\nFor bottom-up DP:\nfor (int i = 2; i &lt;= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n}\nWe compute from small to large (0 → 1 → 2 → ... → n).\n\n\n\n\n\nTime: each i from 0 to n is computed once → O(n)\nSpace: we store dp[0..n] → O(n) (can be reduced to O(1) by only keeping the last two values)",
    "crumbs": [
      "Stage 3",
      "Dynamic Programming (DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#minimum-cost-to-reach-the-end",
    "href": "b2/dynamic-programming.html#minimum-cost-to-reach-the-end",
    "title": "Dynamic Programming (DP)",
    "section": "",
    "text": "Problem:\nYou are given an array cost[0..n-1], where cost[i] is the energy or money you pay when you step on position i.\nYou start before the array and want to go beyond the last index (to position n). From index i, you may move to:\n\ni + 1, or\ni + 2\n\nYou can start from index 0 or index 1.\nGoal: Find the minimum total cost to reach position n.\nExample:\ncost = [1, 100, 1, 1]\n\nPossible ways:\n\nStart at 0:\n  0 -&gt; 2 -&gt; n\n  cost = cost[0] + cost[2] = 1 + 1 = 2\n\nStart at 1:\n  1 -&gt; 3 -&gt; n\n  cost = 100 + 1 = 101\n\nAnswer = 2\n\n\n\nLet’s define a recursive function:\n\nsolve(i) = minimum cost to go from index i to the end (position n).\n\nTransitions:\n\nFrom i, you pay cost[i], then go to i+1 or i+2.\n\nint n;\nvector&lt;int&gt; cost;\n\nint solve(int i) {\n    if (i &gt;= n) return 0;\n\n    int take1 = solve(i + 1);\n    int take2 = solve(i + 2);\n    return cost[i] + min(take1, take2);\n}\n\nint main() {\n    cost = {1, 100, 1, 1};\n    n = cost.size();\n\n    int ans = min(solve(0), solve(1));  // can start from 0 or 1\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n}\nWhy is this slow?\n\nsolve(i) calls solve(i+1) and solve(i+2).\nThose calls overlap heavily (same i recomputed many times).\nTime becomes exponential in n (O(2^n)).",
    "crumbs": [
      "Stage 3",
      "Dynamic Programming (DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#add-memoization-top-down-dp",
    "href": "b2/dynamic-programming.html#add-memoization-top-down-dp",
    "title": "Dynamic Programming (DP)",
    "section": "",
    "text": "We store the answer for each i in dp[i]:\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint n;\nvector&lt;int&gt; cost;\nvector&lt;int&gt; dp;\n\nint solve(int i) {\n    if (i &gt;= n) return 0;\n\n    if (dp[i] != -1) return dp[i]; // already computed\n\n    int take1 = solve(i + 1);\n    int take2 = solve(i + 2);\n    dp[i] = cost[i] + min(take1, take2);\n    return dp[i];\n}\n\nint main() {\n    cost = {1, 100, 1, 1};\n    n = cost.size();\n    dp.assign(n, -1);\n\n    int ans = min(solve(0), solve(1));\n    cout &lt;&lt; \"Minimum cost = \" &lt;&lt; ans &lt;&lt; \"\\n\";\n}\nNow:\n\nEach solve(i) is computed once.\nTotal time is O(n) instead of exponential.",
    "crumbs": [
      "Stage 3",
      "Dynamic Programming (DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#bottom-up-dp-version",
    "href": "b2/dynamic-programming.html#bottom-up-dp-version",
    "title": "Dynamic Programming (DP)",
    "section": "",
    "text": "We can also do it iteratively from the end to the beginning.\nDefine:\n\ndp[i] = minimum cost to go from index i to the end.\n\nThen:\n\nIf i &gt;= n, cost is 0.\nFor i &lt; n:\n\ndp[i] = cost[i] + min(dp[i+1], dp[i+2])\n\n\nWe usually make the array slightly larger (size n+2) to avoid bounds checks.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; cost = {1, 100, 1, 1};\n    int n = cost.size();\n\n    vector&lt;int&gt; dp(n + 2, 0); // dp[n] and dp[n+1] = 0 by default\n\n    for (int i = n - 1; i &gt;= 0; i--) {\n        dp[i] = cost[i] + min(dp[i + 1], dp[i + 2]);\n    }\n\n    int ans = min(dp[0], dp[1]); // can start from index 0 or 1\n    cout &lt;&lt; \"Minimum cost = \" &lt;&lt; ans &lt;&lt; \"\\n\";\n}",
    "crumbs": [
      "Stage 3",
      "Dynamic Programming (DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#srtbot-for-minimum-cost-to-reach-the-end",
    "href": "b2/dynamic-programming.html#srtbot-for-minimum-cost-to-reach-the-end",
    "title": "Dynamic Programming (DP)",
    "section": "",
    "text": "Let’s apply the SRTBOT framework.\n\n\n\ndp[i] = minimum total cost to go from index i to position n (i.e., to reach or go beyond the end).\n\n\n\n\n\nFrom index i, you:\n\nPay cost[i]\nThen jump to i+1 or i+2\n\nSo:\n\ndp[i] = cost[i] + min(dp[i+1], dp[i+2])\n\n\n\n\n\nFrom state i, we can transition to:\n\ni + 1\ni + 2\n\nThose are the only “edges” in our DP graph.\n\n\n\n\nWe define:\n\ndp[n] = 0 (already at/beyond the end, no more cost)\ndp[n+1] = 0 (safe padding to use dp[i+2] when i = n-1)\n\nIn top-down:\n\nIf i &gt;= n, return 0.\n\n\n\n\n\nFor bottom-up:\n\nWe process i from n-1 down to 0, so that:\n\ndp[i+1] and dp[i+2] are already computed when we calculate dp[i].\n\n\nfor (int i = n - 1; i &gt;= 0; i--) {\n    dp[i] = cost[i] + min(dp[i + 1], dp[i + 2]);\n}\n\n\n\n\n\nTime: We compute dp[i] once for each i in [0..n-1], each in O(1) → total O(n).\nSpace: We use an array dp of size n+2 → O(n). (We can even reduce it to O(1) by only keeping the last two values.)",
    "crumbs": [
      "Stage 3",
      "Dynamic Programming (DP)"
    ]
  },
  {
    "objectID": "b2/dynamic-programming.html#big-picture-intuition-for-dp",
    "href": "b2/dynamic-programming.html#big-picture-intuition-for-dp",
    "title": "Dynamic Programming (DP)",
    "section": "",
    "text": "Dynamic Programming usually appears when:\n\nYou can write a recursive solution that:\n\nCombines answers to smaller subproblems\nBut recomputes the same subproblems many times\n\nYou then:\n\nDefine a state (dp[...])\nDerive a recurrence\nAdd memoization (top-down) or fill a table (bottom-up)\n\n\nSRTBOT helps you structure your thinking:\n\nState → Recurrence → Transitions → Base cases → Order of computation → Time/space complexity",
    "crumbs": [
      "Stage 3",
      "Dynamic Programming (DP)"
    ]
  },
  {
    "objectID": "b2/cpp/bitwise-operations.html",
    "href": "b2/cpp/bitwise-operations.html",
    "title": "Bitwise Operators and Bitmasks",
    "section": "",
    "text": "Bitwise operators let you work with the individual bits of an integer. They’re super powerful for bit manipulation, optimization tricks, and things like generating all subsets of a set.\n\n\nComputers store integers in binary — using only 0 and 1. Each position (bit) represents a power of 2:\nBit position:  7  6  5  4  3  2  1  0\nValue:       128 64 32 16  8  4  2  1\nTo get the value of a binary number, you add the powers of 2 where there is a 1.\n\n\n00000110  =  4 + 2       = 6\n00001010  =  8 + 2       = 10\n00001100  =  8 + 4       = 12\n00000001  =  1           = 1\n00000000  =  0           = 0\nSo when we do bitwise operations (&, |, ^, etc.), we are combining or modifying these individual bits.\n\n\n\n\n\nAll of these work on integer types (int, long long, etc.):\n\n\n\n\n\n\n\n\nOperator\nName\nWhat it does (bitwise)\n\n\n\n\n&\nAND\n1 if both bits are 1\n\n\n|\nOR\n1 if at least one bit is 1\n\n\n^\nXOR\n1 if bits are different\n\n\n~\nNOT / complement\nFlips all bits (1 → 0, 0 → 1)\n\n\n&lt;&lt;\nLeft shift\nShifts bits left (multiply by powers of 2)\n\n\n&gt;&gt;\nRight shift\nShifts bits right (divide by powers of 2)\n\n\n\n\n\n\n\nLet’s use small numbers and pretend they’re 8-bit for clarity:\na = 6   -&gt; 00000110\nb = 10  -&gt; 00001010\n\n\na & b   -&gt; 00000110\n           00001010\n           --------\n           00000010  = 2\n\n\n\na | b   -&gt; 00000110\n           00001010\n           --------\n           00001110  = 14\n\n\n\na ^ b   -&gt; 00000110\n           00001010\n           --------\n           00001100  = 12   (bits that are different become 1)\n\n\n\n~a      -&gt; 11111001   (on 8 bits, but in real C++ it’s on full `int`/`long long`)\n\n\n\na &lt;&lt; 1  -&gt; 00001100  = 12   (6 * 2)\na &lt;&lt; 2  -&gt; 00011000  = 24   (6 * 4)\n\nb &gt;&gt; 1  -&gt; 00000101  = 5    (10 / 2)\n\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid printBits(int x) {\n    for (int i = 7; i &gt;= 0; i--) {\n        cout &lt;&lt; ((x &gt;&gt; i) & 1);\n    }\n}\n\nint main() {\n    int a = 6;   // 00000110\n    int b = 10;  // 00001010\n\n    cout &lt;&lt; \"a = \"; printBits(a); cout &lt;&lt; \" (\" &lt;&lt; a &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"b = \"; printBits(b); cout &lt;&lt; \" (\" &lt;&lt; b &lt;&lt; \")\\n\\n\";\n\n    cout &lt;&lt; \"a & b = \"; printBits(a & b); cout &lt;&lt; \" (\" &lt;&lt; (a & b) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"a | b = \"; printBits(a | b); cout &lt;&lt; \" (\" &lt;&lt; (a | b) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"a ^ b = \"; printBits(a ^ b); cout &lt;&lt; \" (\" &lt;&lt; (a ^ b) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"~a    = \"; printBits((unsigned char)~a); cout &lt;&lt; \" (only low 8 bits)\\n\";\n\n    cout &lt;&lt; \"a &lt;&lt; 1 = \"; printBits(a &lt;&lt; 1); cout &lt;&lt; \" (\" &lt;&lt; (a &lt;&lt; 1) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"b &gt;&gt; 1 = \"; printBits(b &gt;&gt; 1); cout &lt;&lt; \" (\" &lt;&lt; (b &gt;&gt; 1) &lt;&lt; \")\\n\";\n}",
    "crumbs": [
      "Stage 3",
      "C++",
      "**Bitwise Operators and Bitmasks**"
    ]
  },
  {
    "objectID": "b2/cpp/bitwise-operations.html#binary-numbers",
    "href": "b2/cpp/bitwise-operations.html#binary-numbers",
    "title": "Bitwise Operators and Bitmasks",
    "section": "",
    "text": "Computers store integers in binary — using only 0 and 1. Each position (bit) represents a power of 2:\nBit position:  7  6  5  4  3  2  1  0\nValue:       128 64 32 16  8  4  2  1\nTo get the value of a binary number, you add the powers of 2 where there is a 1.\n\n\n00000110  =  4 + 2       = 6\n00001010  =  8 + 2       = 10\n00001100  =  8 + 4       = 12\n00000001  =  1           = 1\n00000000  =  0           = 0\nSo when we do bitwise operations (&, |, ^, etc.), we are combining or modifying these individual bits.",
    "crumbs": [
      "Stage 3",
      "C++",
      "**Bitwise Operators and Bitmasks**"
    ]
  },
  {
    "objectID": "b2/cpp/bitwise-operations.html#the-main-bitwise-operators",
    "href": "b2/cpp/bitwise-operations.html#the-main-bitwise-operators",
    "title": "Bitwise Operators and Bitmasks",
    "section": "",
    "text": "All of these work on integer types (int, long long, etc.):\n\n\n\n\n\n\n\n\nOperator\nName\nWhat it does (bitwise)\n\n\n\n\n&\nAND\n1 if both bits are 1\n\n\n|\nOR\n1 if at least one bit is 1\n\n\n^\nXOR\n1 if bits are different\n\n\n~\nNOT / complement\nFlips all bits (1 → 0, 0 → 1)\n\n\n&lt;&lt;\nLeft shift\nShifts bits left (multiply by powers of 2)\n\n\n&gt;&gt;\nRight shift\nShifts bits right (divide by powers of 2)",
    "crumbs": [
      "Stage 3",
      "C++",
      "**Bitwise Operators and Bitmasks**"
    ]
  },
  {
    "objectID": "b2/cpp/bitwise-operations.html#seeing-bitwise-operations-in-binary",
    "href": "b2/cpp/bitwise-operations.html#seeing-bitwise-operations-in-binary",
    "title": "Bitwise Operators and Bitmasks",
    "section": "",
    "text": "Let’s use small numbers and pretend they’re 8-bit for clarity:\na = 6   -&gt; 00000110\nb = 10  -&gt; 00001010\n\n\na & b   -&gt; 00000110\n           00001010\n           --------\n           00000010  = 2\n\n\n\na | b   -&gt; 00000110\n           00001010\n           --------\n           00001110  = 14\n\n\n\na ^ b   -&gt; 00000110\n           00001010\n           --------\n           00001100  = 12   (bits that are different become 1)\n\n\n\n~a      -&gt; 11111001   (on 8 bits, but in real C++ it’s on full `int`/`long long`)\n\n\n\na &lt;&lt; 1  -&gt; 00001100  = 12   (6 * 2)\na &lt;&lt; 2  -&gt; 00011000  = 24   (6 * 4)\n\nb &gt;&gt; 1  -&gt; 00000101  = 5    (10 / 2)",
    "crumbs": [
      "Stage 3",
      "C++",
      "**Bitwise Operators and Bitmasks**"
    ]
  },
  {
    "objectID": "b2/cpp/bitwise-operations.html#simple-c-example",
    "href": "b2/cpp/bitwise-operations.html#simple-c-example",
    "title": "Bitwise Operators and Bitmasks",
    "section": "",
    "text": "#include &lt;iostream&gt;\nusing namespace std;\n\nvoid printBits(int x) {\n    for (int i = 7; i &gt;= 0; i--) {\n        cout &lt;&lt; ((x &gt;&gt; i) & 1);\n    }\n}\n\nint main() {\n    int a = 6;   // 00000110\n    int b = 10;  // 00001010\n\n    cout &lt;&lt; \"a = \"; printBits(a); cout &lt;&lt; \" (\" &lt;&lt; a &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"b = \"; printBits(b); cout &lt;&lt; \" (\" &lt;&lt; b &lt;&lt; \")\\n\\n\";\n\n    cout &lt;&lt; \"a & b = \"; printBits(a & b); cout &lt;&lt; \" (\" &lt;&lt; (a & b) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"a | b = \"; printBits(a | b); cout &lt;&lt; \" (\" &lt;&lt; (a | b) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"a ^ b = \"; printBits(a ^ b); cout &lt;&lt; \" (\" &lt;&lt; (a ^ b) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"~a    = \"; printBits((unsigned char)~a); cout &lt;&lt; \" (only low 8 bits)\\n\";\n\n    cout &lt;&lt; \"a &lt;&lt; 1 = \"; printBits(a &lt;&lt; 1); cout &lt;&lt; \" (\" &lt;&lt; (a &lt;&lt; 1) &lt;&lt; \")\\n\";\n    cout &lt;&lt; \"b &gt;&gt; 1 = \"; printBits(b &gt;&gt; 1); cout &lt;&lt; \" (\" &lt;&lt; (b &gt;&gt; 1) &lt;&lt; \")\\n\";\n}",
    "crumbs": [
      "Stage 3",
      "C++",
      "**Bitwise Operators and Bitmasks**"
    ]
  },
  {
    "objectID": "b1/sorting.html",
    "href": "b1/sorting.html",
    "title": "Sorting",
    "section": "",
    "text": "Sorting means arranging elements in a specific order, usually from smallest to largest, or alphabetically if they are strings.\nSorting makes data easier to search, compare, and process efficiently.\nMany algorithms like binary search only work if the data is sorted.\n\n\n\n\nSelection sort repeatedly finds the smallest element from the unsorted part of the array and moves it to the beginning.\nStep by step: 1. Find the smallest element in the array. 2. Swap it with the first element. 3. Find the next smallest and swap it with the second element. 4. Keep going until the array is sorted.\n\n\n\nSuppose we have:\n[5, 3, 8, 4, 2]\nAfter the first pass (find smallest = 2, swap with first):\n[2, 3, 8, 4, 5]\nAfter the second pass (next smallest = 3, already in place):\n[2, 3, 8, 4, 5]\nNext, find smallest among [8, 4, 5] → 4 → swap:\n[2, 3, 4, 8, 5]\nFinally → [2, 3, 4, 5, 8]\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {5, 3, 8, 4, 2};\n    int n = arr.size();\n\n    for (int i = 0; i &lt; n - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (arr[j] &lt; arr[minIndex])\n                minIndex = j;\n        }\n        swap(arr[i], arr[minIndex]);\n    }\n\n    for (int x : arr) cout &lt;&lt; x &lt;&lt; \" \";\n}\nOutput:\n2 3 4 5 8\nSelection sort is easy to understand but not very efficient.\n\n\n\n\nThere are two nested loops (one inside another).\nSo it takes about \\(n \\cdot n\\) steps → \\(O(n^2)\\) time.\n\n\n\n\n\nIn real programs and competitive programming, we rarely write sort manually.\nC++ provides a very fast sorting function in the standard library.\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {5, 3, 8, 4, 2};\n    sort(arr.begin(), arr.end());\n\n    for (int x : arr) cout &lt;&lt; x &lt;&lt; \" \";\n}\nOutput:\n2 3 4 5 8\nThat one line sort(arr.begin(), arr.end()); sorts the entire vector in ascending order.\n\n\n\nYou can also use the same sort function with regular arrays.\nYou just need to give the starting and ending pointers.\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    int n = 5;\n\n    int arr[] = {5, 3, 8, 4, 2}; \n\n    sort(arr, arr + n);\n\n    for (int i = 0; i &lt; n; i++)\n        cout &lt;&lt; arr[i] &lt;&lt; \" \";\n}\nOutput:\n2 3 4 5 8\nsort(arr, arr + n); means: sort starting from arr (first element) up to arr + n (just past the last one).\n\n\n\nIf you want to sort from largest to smallest, you can use a custom comparison:\nFor vectors:\nsort(arr.begin(), arr.end(), greater&lt;int&gt;());\nFor C-arrays:\nsort(arr, arr + n, greater&lt;int&gt;());\nOutput:\n8 5 4 3 2\n\n\n\nThe same function works for strings, doubles, or any comparable type:\nvector&lt;string&gt; names = {\"Bob\", \"Alice\", \"Charlie\"};\nsort(names.begin(), names.end());\nOutput:\nAlice Bob Charlie\n\n\n\n\nThe library sort function uses an optimized algorithm. Its time complexity is \\(O(n \\log n)\\), which is much faster than \\(O(n^2)\\) for large inputs.\nFor example:\n\nIf \\(n = 1,000\\), selection sort does about \\(1,000,000\\) operations.\nIf \\(n = 1,000\\), library sort does about \\(10,000\\) operations — around \\(100\\) times faster.",
    "crumbs": [
      "Stage 2",
      "Sorting"
    ]
  },
  {
    "objectID": "b1/sorting.html#selection-sort",
    "href": "b1/sorting.html#selection-sort",
    "title": "Sorting",
    "section": "",
    "text": "Selection sort repeatedly finds the smallest element from the unsorted part of the array and moves it to the beginning.\nStep by step: 1. Find the smallest element in the array. 2. Swap it with the first element. 3. Find the next smallest and swap it with the second element. 4. Keep going until the array is sorted.\n\n\n\nSuppose we have:\n[5, 3, 8, 4, 2]\nAfter the first pass (find smallest = 2, swap with first):\n[2, 3, 8, 4, 5]\nAfter the second pass (next smallest = 3, already in place):\n[2, 3, 8, 4, 5]\nNext, find smallest among [8, 4, 5] → 4 → swap:\n[2, 3, 4, 8, 5]\nFinally → [2, 3, 4, 5, 8]\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {5, 3, 8, 4, 2};\n    int n = arr.size();\n\n    for (int i = 0; i &lt; n - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (arr[j] &lt; arr[minIndex])\n                minIndex = j;\n        }\n        swap(arr[i], arr[minIndex]);\n    }\n\n    for (int x : arr) cout &lt;&lt; x &lt;&lt; \" \";\n}\nOutput:\n2 3 4 5 8\nSelection sort is easy to understand but not very efficient.\n\n\n\n\nThere are two nested loops (one inside another).\nSo it takes about \\(n \\cdot n\\) steps → \\(O(n^2)\\) time.",
    "crumbs": [
      "Stage 2",
      "Sorting"
    ]
  },
  {
    "objectID": "b1/sorting.html#using-the-built-in-sort-function",
    "href": "b1/sorting.html#using-the-built-in-sort-function",
    "title": "Sorting",
    "section": "",
    "text": "In real programs and competitive programming, we rarely write sort manually.\nC++ provides a very fast sorting function in the standard library.\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {5, 3, 8, 4, 2};\n    sort(arr.begin(), arr.end());\n\n    for (int x : arr) cout &lt;&lt; x &lt;&lt; \" \";\n}\nOutput:\n2 3 4 5 8\nThat one line sort(arr.begin(), arr.end()); sorts the entire vector in ascending order.\n\n\n\nYou can also use the same sort function with regular arrays.\nYou just need to give the starting and ending pointers.\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    int n = 5;\n\n    int arr[] = {5, 3, 8, 4, 2}; \n\n    sort(arr, arr + n);\n\n    for (int i = 0; i &lt; n; i++)\n        cout &lt;&lt; arr[i] &lt;&lt; \" \";\n}\nOutput:\n2 3 4 5 8\nsort(arr, arr + n); means: sort starting from arr (first element) up to arr + n (just past the last one).\n\n\n\nIf you want to sort from largest to smallest, you can use a custom comparison:\nFor vectors:\nsort(arr.begin(), arr.end(), greater&lt;int&gt;());\nFor C-arrays:\nsort(arr, arr + n, greater&lt;int&gt;());\nOutput:\n8 5 4 3 2\n\n\n\nThe same function works for strings, doubles, or any comparable type:\nvector&lt;string&gt; names = {\"Bob\", \"Alice\", \"Charlie\"};\nsort(names.begin(), names.end());\nOutput:\nAlice Bob Charlie",
    "crumbs": [
      "Stage 2",
      "Sorting"
    ]
  },
  {
    "objectID": "b1/sorting.html#complexity",
    "href": "b1/sorting.html#complexity",
    "title": "Sorting",
    "section": "",
    "text": "The library sort function uses an optimized algorithm. Its time complexity is \\(O(n \\log n)\\), which is much faster than \\(O(n^2)\\) for large inputs.\nFor example:\n\nIf \\(n = 1,000\\), selection sort does about \\(1,000,000\\) operations.\nIf \\(n = 1,000\\), library sort does about \\(10,000\\) operations — around \\(100\\) times faster.",
    "crumbs": [
      "Stage 2",
      "Sorting"
    ]
  },
  {
    "objectID": "b1/problems/sum-of-three-values.html",
    "href": "b1/problems/sum-of-three-values.html",
    "title": "",
    "section": "",
    "text": "Sum of Three Values\n\nCSES\nmedium\n\n\n\nYou are given an array of \\(n\\) integers, and your task is to find three values at distinct positions whose sum is \\(x\\).\nInput:\n\nFirst line: two integers \\(n\\) and \\(x\\) — the array size and the target sum.\nSecond line: \\(n\\) integers \\(a_1,a_2,\\dots,a_n\\) — the array values.\n\nOutput:\nPrint three integers: the positions (1-indexed) of the chosen values. If there are several valid triplets, you may print any of them. If there is no such triplet, print\nIMPOSSIBLE\nConstraints:\n\n\\(1 \\le n \\le 5000\\)\n\\(1 \\le x, a_i \\le 10^9\\)\n\nExample:\nInput:\n4 8\n2 7 5 1\nOutput:\n1 3 4",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Sum Of Three Values"
    ]
  },
  {
    "objectID": "b1/problems/sum-of-three-values.html#sum-of-three-values",
    "href": "b1/problems/sum-of-three-values.html#sum-of-three-values",
    "title": "",
    "section": "",
    "text": "Sum of Three Values\n\nCSES\nmedium\n\n\n\nYou are given an array of \\(n\\) integers, and your task is to find three values at distinct positions whose sum is \\(x\\).\nInput:\n\nFirst line: two integers \\(n\\) and \\(x\\) — the array size and the target sum.\nSecond line: \\(n\\) integers \\(a_1,a_2,\\dots,a_n\\) — the array values.\n\nOutput:\nPrint three integers: the positions (1-indexed) of the chosen values. If there are several valid triplets, you may print any of them. If there is no such triplet, print\nIMPOSSIBLE\nConstraints:\n\n\\(1 \\le n \\le 5000\\)\n\\(1 \\le x, a_i \\le 10^9\\)\n\nExample:\nInput:\n4 8\n2 7 5 1\nOutput:\n1 3 4",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Sum Of Three Values"
    ]
  },
  {
    "objectID": "b1/problems/twins.html",
    "href": "b1/problems/twins.html",
    "title": "",
    "section": "",
    "text": "Twins\n\nCodeforces\neasy\n\n\n\nGiven an array \\(A\\) of \\(N\\) integers, determine the minimum number of elements to select from \\(A\\) such that the sum of the selected elements is strictly greater than the sum of the remaining elements.",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Twins"
    ]
  },
  {
    "objectID": "b1/problems/twins.html#twins",
    "href": "b1/problems/twins.html#twins",
    "title": "",
    "section": "",
    "text": "Twins\n\nCodeforces\neasy\n\n\n\nGiven an array \\(A\\) of \\(N\\) integers, determine the minimum number of elements to select from \\(A\\) such that the sum of the selected elements is strictly greater than the sum of the remaining elements.",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Twins"
    ]
  },
  {
    "objectID": "b1/problems/stick-lengths.html",
    "href": "b1/problems/stick-lengths.html",
    "title": "",
    "section": "",
    "text": "Stick Lengths\n\nCSES\nmedium\n\n\n\nYou are given \\(n\\) sticks with lengths \\(p_1, p_2, \\dots, p_n\\). You want to make all sticks the same length.\nYou may either lengthen or shorten each stick. Changing the length of a stick from \\(a\\) to \\(b\\) costs \\(|a-b|\\).\nTask: Find the minimum total cost to make all sticks have the same length.\nConstraints:\n\n\\(1 \\le n \\le 2 \\cdot 10^5\\)\n\\(1 \\le p_i \\le 10^9\\)\n\nInput:\n\nFirst line: integer \\(n\\) — number of sticks.\nSecond line: \\(n\\) integers \\(p_1, p_2, \\dots, p_n\\) — the stick lengths.\n\nOutput:\n\nOne integer — the minimum possible total cost.\n\nExample:\nInput:\n5\n2 3 1 5 2\nOutput:\n5",
    "crumbs": [
      "Stage 2",
      "Practice Problems",
      "Stick Lengths"
    ]
  },
  {
    "objectID": "b1/problems/stick-lengths.html#stick-lengths",
    "href": "b1/problems/stick-lengths.html#stick-lengths",
    "title": "",
    "section": "",
    "text": "Stick Lengths\n\nCSES\nmedium\n\n\n\nYou are given \\(n\\) sticks with lengths \\(p_1, p_2, \\dots, p_n\\). You want to make all sticks the same length.\nYou may either lengthen or shorten each stick. Changing the length of a stick from \\(a\\) to \\(b\\) costs \\(|a-b|\\).\nTask: Find the minimum total cost to make all sticks have the same length.\nConstraints:\n\n\\(1 \\le n \\le 2 \\cdot 10^5\\)\n\\(1 \\le p_i \\le 10^9\\)\n\nInput:\n\nFirst line: integer \\(n\\) — number of sticks.\nSecond line: \\(n\\) integers \\(p_1, p_2, \\dots, p_n\\) — the stick lengths.\n\nOutput:\n\nOne integer — the minimum possible total cost.\n\nExample:\nInput:\n5\n2 3 1 5 2\nOutput:\n5",
    "crumbs": [
      "Stage 2",
      "Practice Problems",
      "Stick Lengths"
    ]
  },
  {
    "objectID": "b1/problems/domino-piling.html",
    "href": "b1/problems/domino-piling.html",
    "title": "",
    "section": "",
    "text": "Domino piling\n\nCodeforces\neasy\n\n\n\nGiven a grid of \\(N\\) rows and \\(M\\) columns. You have an infinite amount of pieces of size \\(2 \\times 1\\) you want to put as many pieces in the grid as possible such that.\n\nEach piece completely covers two squares.\nNo two pieces overlap.\nEach piece lies entirely inside the grid.",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Domino piling"
    ]
  },
  {
    "objectID": "b1/problems/domino-piling.html#domino-piling",
    "href": "b1/problems/domino-piling.html#domino-piling",
    "title": "",
    "section": "",
    "text": "Domino piling\n\nCodeforces\neasy\n\n\n\nGiven a grid of \\(N\\) rows and \\(M\\) columns. You have an infinite amount of pieces of size \\(2 \\times 1\\) you want to put as many pieces in the grid as possible such that.\n\nEach piece completely covers two squares.\nNo two pieces overlap.\nEach piece lies entirely inside the grid.",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Domino piling"
    ]
  },
  {
    "objectID": "b1/adhoc.html",
    "href": "b1/adhoc.html",
    "title": "Ad-hoc Problems",
    "section": "",
    "text": "An ad-hoc problem is one that doesn’t fit into a standard category like greedy, sorting, simulation, or dynamic programming (you will learn about this later).\nIt’s usually solved by careful observation, simple logic, and a few clever steps — not by using a known algorithm.\nThink of ad-hoc problems as “puzzle problems” — each one has its own unique trick.\n\n\n“Ad-hoc” is Latin for “for this situation.”\nIn programming, it means you design a custom solution just for the given problem.\nThere’s no formula or template — you must read carefully, find what’s being asked, and come up with your own way to solve it.\n\n\n\n\nThe problem statement sounds strange or story-like.\n\nNo standard algorithm (like binary search or sorting) fits it.\n\nYou can solve it with basic logic, loops, and conditions.\n\nIt often involves counting, comparing, or simulating something directly.\n\nThese are the “think on your feet” problems.\n\n\n\n\n\nCounting wins\n\n\n\n\n\nYou are given results of a few matches: “A” if Alice wins, “B” if Bob wins. Print who won more games.\n\n\n\n\n\nSolution\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string s;\n    cin &gt;&gt; s;\n\n    int a = 0, b = 0;\n    for (char c : s) {\n        if (c == 'A') a++;\n        else if (c == 'B') b++;\n    }\n\n    if (a &gt; b) cout &lt;&lt; \"Alice\";\n    else if (b &gt; a) cout &lt;&lt; \"Bob\";\n    else cout &lt;&lt; \"Draw\";\n}\nThis problem has no formula or algorithm — you just follow the logic directly.\n\n\n\n\n\n\n\nRounding grades\n\n\n\n\n\nA student’s grade is rounded up to the next multiple of 5 if it’s within 2 points.\nOtherwise, it stays the same.\n\n\n\n\n\nSolution\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int grade;\n    cin &gt;&gt; grade;\n\n    int next = ((grade / 5) + 1) * 5;\n    if (next - grade &lt; 3 && grade &gt;= 38)\n        cout &lt;&lt; next;\n    else\n        cout &lt;&lt; grade;\n}\nYou just follow the description exactly. This is pure ad-hoc logic.\n\n\n\n\n\n\n\nCounting digits\n\n\n\n\n\nGiven a number, count how many times digit 7 appears.\n\n\n\n\n\nSolution\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n; cin &gt;&gt; n;\n    int count = 0;\n    while (n &gt; 0) {\n        if (n % 10 == 7) count++;\n        n /= 10;\n    }\n    cout &lt;&lt; count;\n}\nThere’s no “digit counting algorithm” — you just do it manually. That’s ad-hoc.\n\n\n\n\n\n\nRead carefully. Understand exactly what happens step by step.\n\nSimulate with examples. Try small cases manually to see the pattern.\n\nFind the rule. Identify what changes and what stays the same.\n\nImplement directly. Use if-statements, loops, or arrays to match the logic.\n\nAd-hoc is about translating the description into code.\n\n\n\n\nTry writing out a few examples by hand before coding.\n\nDon’t overcomplicate — the solution is usually simpler than it looks.\n\nWatch out for small edge cases (empty input, negatives, ties).\n\nClean, clear code matters more than fancy tricks.\n\n\n\n\n\nOften very simple once you understand the logic\n\nDoesn’t need advanced algorithms or data structures\n\nGreat for beginners — builds careful thinking\n\n\n\n\n\nEach problem is unique — can’t reuse your old code\n\nHard to predict what kind of logic is needed\n\nCan be tricky to spot small exceptions or edge cases\n\n\n\n\n\nAd-hoc means solving a problem by direct reasoning, not by a standard algorithm.\n\nThey often involve small rules, conditions, or counting.\n\nRead carefully, simulate examples, and turn logic into code.\n\nStay calm — the simplest approach is usually the right one.",
    "crumbs": [
      "Stage 2",
      "Ad-hoc Problems"
    ]
  },
  {
    "objectID": "b1/adhoc.html#what-does-ad-hoc-mean",
    "href": "b1/adhoc.html#what-does-ad-hoc-mean",
    "title": "Ad-hoc Problems",
    "section": "",
    "text": "“Ad-hoc” is Latin for “for this situation.”\nIn programming, it means you design a custom solution just for the given problem.\nThere’s no formula or template — you must read carefully, find what’s being asked, and come up with your own way to solve it.",
    "crumbs": [
      "Stage 2",
      "Ad-hoc Problems"
    ]
  },
  {
    "objectID": "b1/adhoc.html#typical-signs-of-an-ad-hoc-problem",
    "href": "b1/adhoc.html#typical-signs-of-an-ad-hoc-problem",
    "title": "Ad-hoc Problems",
    "section": "",
    "text": "The problem statement sounds strange or story-like.\n\nNo standard algorithm (like binary search or sorting) fits it.\n\nYou can solve it with basic logic, loops, and conditions.\n\nIt often involves counting, comparing, or simulating something directly.\n\nThese are the “think on your feet” problems.",
    "crumbs": [
      "Stage 2",
      "Ad-hoc Problems"
    ]
  },
  {
    "objectID": "b1/adhoc.html#counting-wins",
    "href": "b1/adhoc.html#counting-wins",
    "title": "Ad-hoc Problems",
    "section": "",
    "text": "Counting wins\n\n\n\n\n\nYou are given results of a few matches: “A” if Alice wins, “B” if Bob wins. Print who won more games.",
    "crumbs": [
      "Stage 2",
      "Ad-hoc Problems"
    ]
  },
  {
    "objectID": "b1/adhoc.html#rounding-grades",
    "href": "b1/adhoc.html#rounding-grades",
    "title": "Ad-hoc Problems",
    "section": "",
    "text": "Rounding grades\n\n\n\n\n\nA student’s grade is rounded up to the next multiple of 5 if it’s within 2 points.\nOtherwise, it stays the same.",
    "crumbs": [
      "Stage 2",
      "Ad-hoc Problems"
    ]
  },
  {
    "objectID": "b1/adhoc.html#counting-digits",
    "href": "b1/adhoc.html#counting-digits",
    "title": "Ad-hoc Problems",
    "section": "",
    "text": "Counting digits\n\n\n\n\n\nGiven a number, count how many times digit 7 appears.",
    "crumbs": [
      "Stage 2",
      "Ad-hoc Problems"
    ]
  },
  {
    "objectID": "b1/adhoc.html#how-to-approach-ad-hoc-problems",
    "href": "b1/adhoc.html#how-to-approach-ad-hoc-problems",
    "title": "Ad-hoc Problems",
    "section": "",
    "text": "Read carefully. Understand exactly what happens step by step.\n\nSimulate with examples. Try small cases manually to see the pattern.\n\nFind the rule. Identify what changes and what stays the same.\n\nImplement directly. Use if-statements, loops, or arrays to match the logic.\n\nAd-hoc is about translating the description into code.",
    "crumbs": [
      "Stage 2",
      "Ad-hoc Problems"
    ]
  },
  {
    "objectID": "b1/adhoc.html#tips",
    "href": "b1/adhoc.html#tips",
    "title": "Ad-hoc Problems",
    "section": "",
    "text": "Try writing out a few examples by hand before coding.\n\nDon’t overcomplicate — the solution is usually simpler than it looks.\n\nWatch out for small edge cases (empty input, negatives, ties).\n\nClean, clear code matters more than fancy tricks.",
    "crumbs": [
      "Stage 2",
      "Ad-hoc Problems"
    ]
  },
  {
    "objectID": "b1/adhoc.html#advantages",
    "href": "b1/adhoc.html#advantages",
    "title": "Ad-hoc Problems",
    "section": "",
    "text": "Often very simple once you understand the logic\n\nDoesn’t need advanced algorithms or data structures\n\nGreat for beginners — builds careful thinking",
    "crumbs": [
      "Stage 2",
      "Ad-hoc Problems"
    ]
  },
  {
    "objectID": "b1/adhoc.html#disadvantages",
    "href": "b1/adhoc.html#disadvantages",
    "title": "Ad-hoc Problems",
    "section": "",
    "text": "Each problem is unique — can’t reuse your old code\n\nHard to predict what kind of logic is needed\n\nCan be tricky to spot small exceptions or edge cases",
    "crumbs": [
      "Stage 2",
      "Ad-hoc Problems"
    ]
  },
  {
    "objectID": "b1/adhoc.html#quick-summary",
    "href": "b1/adhoc.html#quick-summary",
    "title": "Ad-hoc Problems",
    "section": "",
    "text": "Ad-hoc means solving a problem by direct reasoning, not by a standard algorithm.\n\nThey often involve small rules, conditions, or counting.\n\nRead carefully, simulate examples, and turn logic into code.\n\nStay calm — the simplest approach is usually the right one.",
    "crumbs": [
      "Stage 2",
      "Ad-hoc Problems"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html",
    "href": "b1/modular-arithmetics.html",
    "title": "Modular Arithmetics",
    "section": "",
    "text": "Modular arithmetic is a way of doing math where numbers “wrap around” after reaching a certain value — called the modulus.\nThink of it like a clock.\nAfter 24 hours, it goes back to the same time again. That’s mod 24 arithmetic!\n\n\nWhen we say a mod m, it means the remainder when a is divided by m.\nFor example:\n\n\n\nExpression\nMeaning\nResult\n\n\n\n\n7 mod 3\n7 divided by 3 leaves remainder 1\n1\n\n\n10 mod 4\n10 divided by 4 leaves remainder 2\n2\n\n\n15 mod 6\n15 divided by 6 leaves remainder 3\n3\n\n\n12 mod 12\n12 divided by 12 leaves remainder 0\n0\n\n\n\nIn C++, we use the % operator for this:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; 7 % 3 &lt;&lt; endl;   // prints 1\n    cout &lt;&lt; 10 % 4 &lt;&lt; endl;  // prints 2\n    cout &lt;&lt; 10 % 5 &lt;&lt; endl;  // prints 0\n}\n\n\n\nWhen we work with very large numbers (for example, in combinatorics or cryptography), results can become too big for normal data types.\nTo get around this, we take everything modulo some number to keep it small and manageable.\nA common modulus used in competitive programming is:\nMOD = 1'000'000'007  // (a large prime number)\nIt’s used because:\n\nIt fits safely in 64-bit integers.\nIt avoids overflow when adding up two remainders.\nIt’s a prime number, which has nice math properties.\n\n\n\n\nThese rules make modular arithmetic simple to use:\n\nAddition\n(a + b) % m = (a % m + b % m) % m\nSubtraction\n(a - b) % m = ((a % m - b % m) + m) % m\nWe add +m to make sure the result isn’t negative.\nMultiplication\n(a * b) % m = (a % m * b % m) % m\n\nExample:\nint a = 7, b = 5, m = 3;\ncout &lt;&lt; (a + b) % m &lt;&lt; endl;   // (7 + 5) % 3 = 12 % 3 = 0\ncout &lt;&lt; (a * b) % m &lt;&lt; endl;   // (7 * 5) % 3 = 35 % 3 = 2\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    const int MOD = 1'000'000'007;\n    long long a = 1e12, b = 1e12;\n    cout &lt;&lt; (a + b) % MOD &lt;&lt; endl;\n}\nOutput:\n999999979\nEven though the sum is 2e12, we safely wrapped it inside MOD.\n\n\n\n\nBe careful with negative numbers — in C++, % can give negative results.\nExample:\ncout &lt;&lt; (-5) % 3; // prints -2\nTo fix this, always use:\n((a % m) + m) % m\nExample:\nint a = -5, m = 3;\ncout &lt;&lt; ((a % m) + m) % m; // prints 1\n\n\n\nIf you want to compute the remainder of \\(a^b\\) when divided by \\(m\\), it’s not efficient to multiply \\(a\\) many times. Instead, use fast exponentiation.\nFast exponentiation is based on the following observation. If \\(b\\) is even then \\(a^b = (a^{b/2})^2\\), and if \\(b\\) is odd then \\(a^b = a \\cdot (a^{\\lfloor b/2 \\rfloor})^2\\). This is why we can use a function that recursively calls itself, each time halving the exponent.\nlong long modpow(long long a, long long b, long long m) {\n    if (b == 0) return 1;\n\n    long long half = modpow(a, b / 2, m);\n    long long res = (half * half) % m;\n\n    if (b % 2 == 1) { // If b is odd\n        res = (res * (a % m)) % m;\n    }\n    return res;\n}\nSince \\(b\\) is halved each time the recursion is called, the total number of recursive calls is \\(\\lfloor \\log_2 b \\rfloor + 1\\), hence the time complexity of this function is \\(O(\\log b)\\).\nUsage:\ncout &lt;&lt; modpow(2, 10, 1000); // 1024 % 1000 = 24\n\n\n\nSometimes we need to divide numbers under modulo. However, modulo does not distribute over division as it does with the addition and multiplication. So, instead dividing, we multiply by the modular inverse.\nFrom the Fermat’s little theorem we can derive that for a prime modulus \\(m\\), the modular inverse of \\(a\\) is\n\\(a^{-1} \\equiv a^{m-2} \\mod m\\)\nint inverse = modpow(a, MOD - 2, MOD);\nThen a divided by b with modulus MOD becomes\n(a * modpow(b, MOD - 2, MOD)) % MOD\n\n\n\nYou’ll see it in problems where:\n\nNumbers grow extremely large (combinations, dynamic programming, etc.)\nThe result only needs to be given “mod 1e9+7”\nYou’re implementing math algorithms like power, inverse, or combinatorics\n\n\n\n\n\nKeeps numbers small and avoids overflow\n\nWorks with huge results easily\n\nGreat for competitive programming problems\n\n\n\n\n\nYou lose the exact value (only remainder is kept)\n\nDivision is tricky — requires modular inverse\n\nNegative results can be confusing in C++\n\n\n\n\n\na % m gives the remainder when dividing a by m\n\nKeep using % MOD to avoid overflow in large problems\n\nUse (a + b) % MOD, (a * b) % MOD, and ((a - b) % MOD + MOD) % MOD\n\nFor exponentiation, use fast power\n\nFor division, use modular inverse when MOD is prime",
    "crumbs": [
      "Stage 2",
      "Modular Arithmetics"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#what-does-mod-mean",
    "href": "b1/modular-arithmetics.html#what-does-mod-mean",
    "title": "Modular Arithmetics",
    "section": "",
    "text": "When we say a mod m, it means the remainder when a is divided by m.\nFor example:\n\n\n\nExpression\nMeaning\nResult\n\n\n\n\n7 mod 3\n7 divided by 3 leaves remainder 1\n1\n\n\n10 mod 4\n10 divided by 4 leaves remainder 2\n2\n\n\n15 mod 6\n15 divided by 6 leaves remainder 3\n3\n\n\n12 mod 12\n12 divided by 12 leaves remainder 0\n0\n\n\n\nIn C++, we use the % operator for this:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; 7 % 3 &lt;&lt; endl;   // prints 1\n    cout &lt;&lt; 10 % 4 &lt;&lt; endl;  // prints 2\n    cout &lt;&lt; 10 % 5 &lt;&lt; endl;  // prints 0\n}",
    "crumbs": [
      "Stage 2",
      "Modular Arithmetics"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#modular-arithmetic-in-programming",
    "href": "b1/modular-arithmetics.html#modular-arithmetic-in-programming",
    "title": "Modular Arithmetics",
    "section": "",
    "text": "When we work with very large numbers (for example, in combinatorics or cryptography), results can become too big for normal data types.\nTo get around this, we take everything modulo some number to keep it small and manageable.\nA common modulus used in competitive programming is:\nMOD = 1'000'000'007  // (a large prime number)\nIt’s used because:\n\nIt fits safely in 64-bit integers.\nIt avoids overflow when adding up two remainders.\nIt’s a prime number, which has nice math properties.",
    "crumbs": [
      "Stage 2",
      "Modular Arithmetics"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#basic-modular-rules",
    "href": "b1/modular-arithmetics.html#basic-modular-rules",
    "title": "Modular Arithmetics",
    "section": "",
    "text": "These rules make modular arithmetic simple to use:\n\nAddition\n(a + b) % m = (a % m + b % m) % m\nSubtraction\n(a - b) % m = ((a % m - b % m) + m) % m\nWe add +m to make sure the result isn’t negative.\nMultiplication\n(a * b) % m = (a % m * b % m) % m\n\nExample:\nint a = 7, b = 5, m = 3;\ncout &lt;&lt; (a + b) % m &lt;&lt; endl;   // (7 + 5) % 3 = 12 % 3 = 0\ncout &lt;&lt; (a * b) % m &lt;&lt; endl;   // (7 * 5) % 3 = 35 % 3 = 2\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    const int MOD = 1'000'000'007;\n    long long a = 1e12, b = 1e12;\n    cout &lt;&lt; (a + b) % MOD &lt;&lt; endl;\n}\nOutput:\n999999979\nEven though the sum is 2e12, we safely wrapped it inside MOD.",
    "crumbs": [
      "Stage 2",
      "Modular Arithmetics"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#handling-negatives",
    "href": "b1/modular-arithmetics.html#handling-negatives",
    "title": "Modular Arithmetics",
    "section": "",
    "text": "Be careful with negative numbers — in C++, % can give negative results.\nExample:\ncout &lt;&lt; (-5) % 3; // prints -2\nTo fix this, always use:\n((a % m) + m) % m\nExample:\nint a = -5, m = 3;\ncout &lt;&lt; ((a % m) + m) % m; // prints 1",
    "crumbs": [
      "Stage 2",
      "Modular Arithmetics"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#modular-exponentiation",
    "href": "b1/modular-arithmetics.html#modular-exponentiation",
    "title": "Modular Arithmetics",
    "section": "",
    "text": "If you want to compute the remainder of \\(a^b\\) when divided by \\(m\\), it’s not efficient to multiply \\(a\\) many times. Instead, use fast exponentiation.\nFast exponentiation is based on the following observation. If \\(b\\) is even then \\(a^b = (a^{b/2})^2\\), and if \\(b\\) is odd then \\(a^b = a \\cdot (a^{\\lfloor b/2 \\rfloor})^2\\). This is why we can use a function that recursively calls itself, each time halving the exponent.\nlong long modpow(long long a, long long b, long long m) {\n    if (b == 0) return 1;\n\n    long long half = modpow(a, b / 2, m);\n    long long res = (half * half) % m;\n\n    if (b % 2 == 1) { // If b is odd\n        res = (res * (a % m)) % m;\n    }\n    return res;\n}\nSince \\(b\\) is halved each time the recursion is called, the total number of recursive calls is \\(\\lfloor \\log_2 b \\rfloor + 1\\), hence the time complexity of this function is \\(O(\\log b)\\).\nUsage:\ncout &lt;&lt; modpow(2, 10, 1000); // 1024 % 1000 = 24",
    "crumbs": [
      "Stage 2",
      "Modular Arithmetics"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#modular-inverse-optional-advanced",
    "href": "b1/modular-arithmetics.html#modular-inverse-optional-advanced",
    "title": "Modular Arithmetics",
    "section": "",
    "text": "Sometimes we need to divide numbers under modulo. However, modulo does not distribute over division as it does with the addition and multiplication. So, instead dividing, we multiply by the modular inverse.\nFrom the Fermat’s little theorem we can derive that for a prime modulus \\(m\\), the modular inverse of \\(a\\) is\n\\(a^{-1} \\equiv a^{m-2} \\mod m\\)\nint inverse = modpow(a, MOD - 2, MOD);\nThen a divided by b with modulus MOD becomes\n(a * modpow(b, MOD - 2, MOD)) % MOD",
    "crumbs": [
      "Stage 2",
      "Modular Arithmetics"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#when-do-we-use-modular-arithmetic",
    "href": "b1/modular-arithmetics.html#when-do-we-use-modular-arithmetic",
    "title": "Modular Arithmetics",
    "section": "",
    "text": "You’ll see it in problems where:\n\nNumbers grow extremely large (combinations, dynamic programming, etc.)\nThe result only needs to be given “mod 1e9+7”\nYou’re implementing math algorithms like power, inverse, or combinatorics",
    "crumbs": [
      "Stage 2",
      "Modular Arithmetics"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#advantages",
    "href": "b1/modular-arithmetics.html#advantages",
    "title": "Modular Arithmetics",
    "section": "",
    "text": "Keeps numbers small and avoids overflow\n\nWorks with huge results easily\n\nGreat for competitive programming problems",
    "crumbs": [
      "Stage 2",
      "Modular Arithmetics"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#disadvantages",
    "href": "b1/modular-arithmetics.html#disadvantages",
    "title": "Modular Arithmetics",
    "section": "",
    "text": "You lose the exact value (only remainder is kept)\n\nDivision is tricky — requires modular inverse\n\nNegative results can be confusing in C++",
    "crumbs": [
      "Stage 2",
      "Modular Arithmetics"
    ]
  },
  {
    "objectID": "b1/modular-arithmetics.html#quick-summary",
    "href": "b1/modular-arithmetics.html#quick-summary",
    "title": "Modular Arithmetics",
    "section": "",
    "text": "a % m gives the remainder when dividing a by m\n\nKeep using % MOD to avoid overflow in large problems\n\nUse (a + b) % MOD, (a * b) % MOD, and ((a - b) % MOD + MOD) % MOD\n\nFor exponentiation, use fast power\n\nFor division, use modular inverse when MOD is prime",
    "crumbs": [
      "Stage 2",
      "Modular Arithmetics"
    ]
  },
  {
    "objectID": "b1/casework.html",
    "href": "b1/casework.html",
    "title": "Case Work",
    "section": "",
    "text": "Case work problems are those where the solution is found by splitting the problem into different cases, solving each one separately, and then combining the results.\n\n\nIn many problems you might try to write one formula or one loop to cover everything. In a case work problem, you notice that different situations behave differently. So instead of one generic rule, you say:\n\nIf case A happens, do this.\nIf case B happens, do that.\nMaybe also case C, case D, etc.\n\nThen you either add up the answers of all the cases, or pick the best one.\n\n\n\n\nIt allows you to handle special situations cleanly (when simple logic alone doesn’t work).\nIt helps you break down a tricky problem into manageable pieces.\nIt often appears in counting problems or problems with multiple outcomes.\n\n\n\n\n\nRead the problem carefully and look for places where things change (for example, small/large, positive/negative, even/odd).\nIdentify all distinct cases that cover all possibilities without overlap.\nFor each case, figure out how to compute the result.\nCombine the results if needed (add them or take min/max).\nDouble-check you didn’t miss any case or count something twice.\n\n\n\n\n\n\n\n\n\nEven or odd sum\n\n\n\n\n\nYou have two numbers \\(a\\) and \\(b\\). Count how many pairs \\((i, j)\\) with \\(1 \\leq i \\leq a\\) and \\(1 \\leq j \\leq b\\) have \\(i + j\\) even.\n\n\n\n\n\nSolution\n\nObservation: \\(i + j\\) is even if both are even or both are odd.\nSo there are two cases:\n\nCase 1: \\(i\\) even and \\(j\\) even\nCase 2: \\(i\\) odd and \\(j\\) odd\n\nCompute each count and add them together.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n\n    int evenA = a / 2;\n    int oddA = a - evenA;\n    int evenB = b / 2;\n    int oddB = b - evenB;\n\n    int pairs = evenA * evenB + oddA * oddB;\n    cout &lt;&lt; pairs;\n}\n\n\n\n\n\n\n\nTriangle validity\n\n\n\n\n\nGiven three side lengths \\(a, b, c\\), determine if they can form a triangle.\n\n\n\n\n\nSolution\n\nWe can test each case by checking which side might be the largest:\n\nCase 1: \\(a\\) is largest → check if \\(b + c &gt; a\\)\nCase 2: \\(b\\) is largest → check if \\(a + c &gt; b\\)\nCase 3: \\(c\\) is largest → check if \\(a + b &gt; c\\)\n\nIf any of these are true, a triangle is possible.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int a, b, c;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n\n    bool ok = false;\n    if (b + c &gt; a) ok = true;\n    if (a + c &gt; b) ok = true;\n    if (a + b &gt; c) ok = true;\n\n    cout &lt;&lt; (ok ? \"YES\" : \"NO\");\n}\nThis checks all cases separately — a direct example of case work.\n\n\n\n\n\n\n\nCoordinate quadrant\n\n\n\n\n\nGiven \\((x, y)\\), print which quadrant the point belongs to.\n\n\n\n\n\nSolution\n\nCases:\n\n\\(x &gt; 0, y &gt; 0\\) → Quadrant I\n\\(x &lt; 0, y &gt; 0\\) → Quadrant II\n\\(x &lt; 0, y &lt; 0\\) → Quadrant III\n\\(x &gt; 0, y &lt; 0\\) → Quadrant IV\nIf \\(x = 0\\) or \\(y = 0\\) → on an axis\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x, y;\n    cin &gt;&gt; x &gt;&gt; y;\n\n    if (x &gt; 0 && y &gt; 0) cout &lt;&lt; \"Quadrant I\";\n    else if (x &lt; 0 && y &gt; 0) cout &lt;&lt; \"Quadrant II\";\n    else if (x &lt; 0 && y &lt; 0) cout &lt;&lt; \"Quadrant III\";\n    else if (x &gt; 0 && y &lt; 0) cout &lt;&lt; \"Quadrant IV\";\n    else cout &lt;&lt; \"On an axis\";\n}\n\n\n\n\n\n\nMake sure your cases don’t overlap.\nEnsure all possibilities are covered.\nWatch for boundaries (like 0 or equality).\nKeep the logic clear and simple.\n\n\n\n\n\nCase work means breaking a problem into smaller, simpler situations.\nSolve each case separately and combine results.\nIt’s a thinking technique, not a special algorithm.\nGreat for early problem-solving practice.\n\n\nTip: When unsure how to start, think “What are the possible situations?” — that’s the beginning of case work.",
    "crumbs": [
      "Stage 2",
      "Case Work"
    ]
  },
  {
    "objectID": "b1/casework.html#what-is-case-work",
    "href": "b1/casework.html#what-is-case-work",
    "title": "Case Work",
    "section": "",
    "text": "In many problems you might try to write one formula or one loop to cover everything. In a case work problem, you notice that different situations behave differently. So instead of one generic rule, you say:\n\nIf case A happens, do this.\nIf case B happens, do that.\nMaybe also case C, case D, etc.\n\nThen you either add up the answers of all the cases, or pick the best one.",
    "crumbs": [
      "Stage 2",
      "Case Work"
    ]
  },
  {
    "objectID": "b1/casework.html#why-use-case-work",
    "href": "b1/casework.html#why-use-case-work",
    "title": "Case Work",
    "section": "",
    "text": "It allows you to handle special situations cleanly (when simple logic alone doesn’t work).\nIt helps you break down a tricky problem into manageable pieces.\nIt often appears in counting problems or problems with multiple outcomes.",
    "crumbs": [
      "Stage 2",
      "Case Work"
    ]
  },
  {
    "objectID": "b1/casework.html#how-to-do-case-work",
    "href": "b1/casework.html#how-to-do-case-work",
    "title": "Case Work",
    "section": "",
    "text": "Read the problem carefully and look for places where things change (for example, small/large, positive/negative, even/odd).\nIdentify all distinct cases that cover all possibilities without overlap.\nFor each case, figure out how to compute the result.\nCombine the results if needed (add them or take min/max).\nDouble-check you didn’t miss any case or count something twice.",
    "crumbs": [
      "Stage 2",
      "Case Work"
    ]
  },
  {
    "objectID": "b1/casework.html#even-or-odd-sum",
    "href": "b1/casework.html#even-or-odd-sum",
    "title": "Case Work",
    "section": "",
    "text": "Even or odd sum\n\n\n\n\n\nYou have two numbers \\(a\\) and \\(b\\). Count how many pairs \\((i, j)\\) with \\(1 \\leq i \\leq a\\) and \\(1 \\leq j \\leq b\\) have \\(i + j\\) even.",
    "crumbs": [
      "Stage 2",
      "Case Work"
    ]
  },
  {
    "objectID": "b1/casework.html#triangle-validity",
    "href": "b1/casework.html#triangle-validity",
    "title": "Case Work",
    "section": "",
    "text": "Triangle validity\n\n\n\n\n\nGiven three side lengths \\(a, b, c\\), determine if they can form a triangle.",
    "crumbs": [
      "Stage 2",
      "Case Work"
    ]
  },
  {
    "objectID": "b1/casework.html#coordinate-quadrant",
    "href": "b1/casework.html#coordinate-quadrant",
    "title": "Case Work",
    "section": "",
    "text": "Coordinate quadrant\n\n\n\n\n\nGiven \\((x, y)\\), print which quadrant the point belongs to.",
    "crumbs": [
      "Stage 2",
      "Case Work"
    ]
  },
  {
    "objectID": "b1/casework.html#tips-for-case-work",
    "href": "b1/casework.html#tips-for-case-work",
    "title": "Case Work",
    "section": "",
    "text": "Make sure your cases don’t overlap.\nEnsure all possibilities are covered.\nWatch for boundaries (like 0 or equality).\nKeep the logic clear and simple.",
    "crumbs": [
      "Stage 2",
      "Case Work"
    ]
  },
  {
    "objectID": "b1/casework.html#quick-summary",
    "href": "b1/casework.html#quick-summary",
    "title": "Case Work",
    "section": "",
    "text": "Case work means breaking a problem into smaller, simpler situations.\nSolve each case separately and combine results.\nIt’s a thinking technique, not a special algorithm.\nGreat for early problem-solving practice.\n\n\nTip: When unsure how to start, think “What are the possible situations?” — that’s the beginning of case work.",
    "crumbs": [
      "Stage 2",
      "Case Work"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html",
    "href": "b1/cpp/maps.html",
    "title": "Maps",
    "section": "",
    "text": "A map is a container in C++ which stores pairs of items like this:\nkey -&gt; value\nand keeps them sorted by key automatically.\nExample:\n#include &lt;iostream&gt;\n#include &lt;map&gt;\nusing namespace std;\n\nint main() {\n    map&lt;string, int&gt; ages;\n\n    ages[\"Alice\"] = 25;\n    ages[\"Bob\"] = 30;\n    ages[\"Charlie\"] = 22;\n\n    for (auto p : ages)\n        cout &lt;&lt; p.first &lt;&lt; \": \" &lt;&lt; p.second &lt;&lt; endl;\n}\nOutput:\nAlice: 25\nBob: 30\nCharlie: 22\nNotice that the names are printed in alphabetical order — because a map sorts keys automatically.\n\n\nTo use a map, include:\n#include &lt;map&gt;\nThen you can declare it like this:\nmap&lt;int, string&gt; students;     // key: int, value: string\nmap&lt;string, double&gt; prices;    // key: string, value: double\nmap&lt;char, int&gt; frequency;      // key: char, value: int\n\n\n\nmap&lt;string, int&gt; scores;\n\nscores[\"Mark\"] = 90;          // add using [] \n\ncout &lt;&lt; scores[\"Mark\"];       // prints 90\nIf you access a key that doesn’t exist with [], it will create it with a default value (like 0).\ncout &lt;&lt; scores[\"Unknown\"];  // creates \"Unknown\" with value 0\nIf you don’t want that behavior, use count() to check first if it exists.\nif (scores.count(\"Tom\"))\n    cout &lt;&lt; \"Tom found!\";\n\n\n\n\n\n\nOperation\nExample\nDescription\n\n\n\n\nm[key]\nm[\"Bob\"]\nAccess or create element\n\n\nerase(key)\nm.erase(\"Bob\")\nRemoves key and value\n\n\ncount(key)\nif (m.count(\"Bob\"))\n1 if key exists, 0 if not\n\n\nsize()\nm.size();\nReturns number of elements\n\n\nclear()\nm.clear();\nDeletes all elements\n\n\nempty()\nm.empty();\nChecks if map is empty\n\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string text = \"apple banana apple orange banana apple\";\n    map&lt;string, int&gt; freq;\n\n    string word;\n    for (auto c : text) {\n        if (c == ' ') {\n            if (!word.empty()) freq[word]++;\n            word.clear();\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) freq[word]++; // last word\n\n    for (auto p : freq)\n        cout &lt;&lt; p.first &lt;&lt; \": \" &lt;&lt; p.second &lt;&lt; endl;\n}\nOutput:\napple: 3\nbanana: 2\norange: 1\n\n\n\nYou can loop through it with a range-based for:\nfor (auto p : myMap)\n    cout &lt;&lt; p.first &lt;&lt; \" -&gt; \" &lt;&lt; p.second &lt;&lt; endl;\nor using iterators:\nfor (auto it = myMap.begin(); it != myMap.end(); it++)\n    cout &lt;&lt; it-&gt;first &lt;&lt; \": \" &lt;&lt; it-&gt;second &lt;&lt; endl;\nfirst = key, second = value.\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nKeeps order?\nAllows duplicate keys?\nSpeed (average)\nNotes\n\n\n\n\nmap\nYes\nNo\nO(log n)\nStores keys sorted (balanced tree)\n\n\nunordered_map\nNo\nNo\nO(1) average\nFast, but order is random\n\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nint main() {\n    unordered_map&lt;string, int&gt; age;\n\n    age[\"Bob\"] = 30;\n    age[\"Alice\"] = 25;\n    age[\"Tom\"] = 28;\n\n    for (auto p : age)\n        cout &lt;&lt; p.first &lt;&lt; \": \" &lt;&lt; p.second &lt;&lt; endl;\n}\nOutput:\n(order may be random)\nBob: 30\nTom: 28\nAlice: 25\nSo unordered_map is usually faster, but doesn’t sort keys.",
    "crumbs": [
      "Stage 2",
      "C++",
      "Maps"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#creating-a-map",
    "href": "b1/cpp/maps.html#creating-a-map",
    "title": "Maps",
    "section": "",
    "text": "To use a map, include:\n#include &lt;map&gt;\nThen you can declare it like this:\nmap&lt;int, string&gt; students;     // key: int, value: string\nmap&lt;string, double&gt; prices;    // key: string, value: double\nmap&lt;char, int&gt; frequency;      // key: char, value: int",
    "crumbs": [
      "Stage 2",
      "C++",
      "Maps"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#adding-and-accessing-elements",
    "href": "b1/cpp/maps.html#adding-and-accessing-elements",
    "title": "Maps",
    "section": "",
    "text": "map&lt;string, int&gt; scores;\n\nscores[\"Mark\"] = 90;          // add using [] \n\ncout &lt;&lt; scores[\"Mark\"];       // prints 90\nIf you access a key that doesn’t exist with [], it will create it with a default value (like 0).\ncout &lt;&lt; scores[\"Unknown\"];  // creates \"Unknown\" with value 0\nIf you don’t want that behavior, use count() to check first if it exists.\nif (scores.count(\"Tom\"))\n    cout &lt;&lt; \"Tom found!\";",
    "crumbs": [
      "Stage 2",
      "C++",
      "Maps"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#common-operations",
    "href": "b1/cpp/maps.html#common-operations",
    "title": "Maps",
    "section": "",
    "text": "Operation\nExample\nDescription\n\n\n\n\nm[key]\nm[\"Bob\"]\nAccess or create element\n\n\nerase(key)\nm.erase(\"Bob\")\nRemoves key and value\n\n\ncount(key)\nif (m.count(\"Bob\"))\n1 if key exists, 0 if not\n\n\nsize()\nm.size();\nReturns number of elements\n\n\nclear()\nm.clear();\nDeletes all elements\n\n\nempty()\nm.empty();\nChecks if map is empty",
    "crumbs": [
      "Stage 2",
      "C++",
      "Maps"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#example-word-frequency-counter",
    "href": "b1/cpp/maps.html#example-word-frequency-counter",
    "title": "Maps",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string text = \"apple banana apple orange banana apple\";\n    map&lt;string, int&gt; freq;\n\n    string word;\n    for (auto c : text) {\n        if (c == ' ') {\n            if (!word.empty()) freq[word]++;\n            word.clear();\n        } else {\n            word += c;\n        }\n    }\n    if (!word.empty()) freq[word]++; // last word\n\n    for (auto p : freq)\n        cout &lt;&lt; p.first &lt;&lt; \": \" &lt;&lt; p.second &lt;&lt; endl;\n}\nOutput:\napple: 3\nbanana: 2\norange: 1",
    "crumbs": [
      "Stage 2",
      "C++",
      "Maps"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#iterating-through-a-map",
    "href": "b1/cpp/maps.html#iterating-through-a-map",
    "title": "Maps",
    "section": "",
    "text": "You can loop through it with a range-based for:\nfor (auto p : myMap)\n    cout &lt;&lt; p.first &lt;&lt; \" -&gt; \" &lt;&lt; p.second &lt;&lt; endl;\nor using iterators:\nfor (auto it = myMap.begin(); it != myMap.end(); it++)\n    cout &lt;&lt; it-&gt;first &lt;&lt; \": \" &lt;&lt; it-&gt;second &lt;&lt; endl;\nfirst = key, second = value.",
    "crumbs": [
      "Stage 2",
      "C++",
      "Maps"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#kinds-of-maps",
    "href": "b1/cpp/maps.html#kinds-of-maps",
    "title": "Maps",
    "section": "",
    "text": "Type\nKeeps order?\nAllows duplicate keys?\nSpeed (average)\nNotes\n\n\n\n\nmap\nYes\nNo\nO(log n)\nStores keys sorted (balanced tree)\n\n\nunordered_map\nNo\nNo\nO(1) average\nFast, but order is random",
    "crumbs": [
      "Stage 2",
      "C++",
      "Maps"
    ]
  },
  {
    "objectID": "b1/cpp/maps.html#example-unordered_map",
    "href": "b1/cpp/maps.html#example-unordered_map",
    "title": "Maps",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nint main() {\n    unordered_map&lt;string, int&gt; age;\n\n    age[\"Bob\"] = 30;\n    age[\"Alice\"] = 25;\n    age[\"Tom\"] = 28;\n\n    for (auto p : age)\n        cout &lt;&lt; p.first &lt;&lt; \": \" &lt;&lt; p.second &lt;&lt; endl;\n}\nOutput:\n(order may be random)\nBob: 30\nTom: 28\nAlice: 25\nSo unordered_map is usually faster, but doesn’t sort keys.",
    "crumbs": [
      "Stage 2",
      "C++",
      "Maps"
    ]
  },
  {
    "objectID": "b0/problems/equator.html",
    "href": "b0/problems/equator.html",
    "title": "",
    "section": "",
    "text": "Equator\n\nCodeforces\neasy\n\n\n\nGiven array \\(A\\) of \\(N\\) integers \\(A_1, A_2, \\dots, A_N\\). Find the first index \\(i\\) such that the sum \\(A_1 + A_2 ... + A_i\\) is at least half the sum of the whole array.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Equator"
    ]
  },
  {
    "objectID": "b0/problems/equator.html#equator",
    "href": "b0/problems/equator.html#equator",
    "title": "",
    "section": "",
    "text": "Equator\n\nCodeforces\neasy\n\n\n\nGiven array \\(A\\) of \\(N\\) integers \\(A_1, A_2, \\dots, A_N\\). Find the first index \\(i\\) such that the sum \\(A_1 + A_2 ... + A_i\\) is at least half the sum of the whole array.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Equator"
    ]
  },
  {
    "objectID": "b0/problems/your-digits.html",
    "href": "b0/problems/your-digits.html",
    "title": "",
    "section": "",
    "text": "Your Digits\n\nCodeforces\nmedium\n\n\n\nYou have \\(k_2\\) digits \\(2\\), \\(k_3\\) digits \\(3\\), \\(k_5\\) digits \\(5\\), and \\(k_6\\) digits \\(6\\). You want to form numbers \\(32\\) and \\(256\\) using these digits (each digit at most once) to maximize their total sum. Find the maximum possible sum.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Your Digits"
    ]
  },
  {
    "objectID": "b0/problems/your-digits.html#your-digits",
    "href": "b0/problems/your-digits.html#your-digits",
    "title": "",
    "section": "",
    "text": "Your Digits\n\nCodeforces\nmedium\n\n\n\nYou have \\(k_2\\) digits \\(2\\), \\(k_3\\) digits \\(3\\), \\(k_5\\) digits \\(5\\), and \\(k_6\\) digits \\(6\\). You want to form numbers \\(32\\) and \\(256\\) using these digits (each digit at most once) to maximize their total sum. Find the maximum possible sum.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Your Digits"
    ]
  },
  {
    "objectID": "b0/problems/theatre-square.html",
    "href": "b0/problems/theatre-square.html",
    "title": "",
    "section": "",
    "text": "Theatre Square\n\nCodeforces\neasy\n\n\n\nWe are tasked with tiling a grid of dimensions \\(N \\times M\\) using tiles of dimensions \\(A \\times A\\). The tiles are allowed to protrude the grid but must fully cover it.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Theatre Square"
    ]
  },
  {
    "objectID": "b0/problems/theatre-square.html#theatre-square",
    "href": "b0/problems/theatre-square.html#theatre-square",
    "title": "",
    "section": "",
    "text": "Theatre Square\n\nCodeforces\neasy\n\n\n\nWe are tasked with tiling a grid of dimensions \\(N \\times M\\) using tiles of dimensions \\(A \\times A\\). The tiles are allowed to protrude the grid but must fully cover it.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Theatre Square"
    ]
  },
  {
    "objectID": "b0/problems/static-range-sum-queries.html",
    "href": "b0/problems/static-range-sum-queries.html",
    "title": "",
    "section": "",
    "text": "Static Range Sum Queries\n\nCSES\nmedium\n\n\n\nYou are given an array of \\(n\\) integers and \\(q\\) queries. Each query asks for the sum of values in the inclusive range \\([a,b]\\). Print the answer for every query.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Static Range Sum Queries"
    ]
  },
  {
    "objectID": "b0/problems/static-range-sum-queries.html#static-range-sum-queries",
    "href": "b0/problems/static-range-sum-queries.html#static-range-sum-queries",
    "title": "",
    "section": "",
    "text": "Static Range Sum Queries\n\nCSES\nmedium\n\n\n\nYou are given an array of \\(n\\) integers and \\(q\\) queries. Each query asks for the sum of values in the inclusive range \\([a,b]\\). Print the answer for every query.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Static Range Sum Queries"
    ]
  },
  {
    "objectID": "b0/problems/domino-piling.html",
    "href": "b0/problems/domino-piling.html",
    "title": "",
    "section": "",
    "text": "Domino Piling\n\nCodeforces\neasy\n\n\n\nGiven a board of size \\(M \\times N\\) and unlimited \\(2\\times1\\) dominoes (rotation allowed), place as many dominoes as possible so that they lie entirely within the board and do not overlap. Output the maximum number of dominoes.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Domino Piling"
    ]
  },
  {
    "objectID": "b0/problems/domino-piling.html#domino-piling",
    "href": "b0/problems/domino-piling.html#domino-piling",
    "title": "",
    "section": "",
    "text": "Domino Piling\n\nCodeforces\neasy\n\n\n\nGiven a board of size \\(M \\times N\\) and unlimited \\(2\\times1\\) dominoes (rotation allowed), place as many dominoes as possible so that they lie entirely within the board and do not overlap. Output the maximum number of dominoes.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Domino Piling"
    ]
  },
  {
    "objectID": "b0/problems/beautiful-year.html",
    "href": "b0/problems/beautiful-year.html",
    "title": "",
    "section": "",
    "text": "Beautiful Year\n\nCodeforces\neasy\n\n\n\nGiven a year number, find the minimum year number which is strictly larger than the given one and has only distinct digits.\nYou can assume that year is at least 1000 and at most 9000.\nFor example, for year 1987, the next such year is 2013.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Beautiful Year"
    ]
  },
  {
    "objectID": "b0/problems/beautiful-year.html#beautiful-year",
    "href": "b0/problems/beautiful-year.html#beautiful-year",
    "title": "",
    "section": "",
    "text": "Beautiful Year\n\nCodeforces\neasy\n\n\n\nGiven a year number, find the minimum year number which is strictly larger than the given one and has only distinct digits.\nYou can assume that year is at least 1000 and at most 9000.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Beautiful Year"
    ]
  },
  {
    "objectID": "b0/problems/-template.html",
    "href": "b0/problems/-template.html",
    "title": "",
    "section": "",
    "text": "Sum of Two Numbers\n\nCodeforces\neasy\n\n\n\nA brief explanation of what the problem really wants from us. Keep it minimal, extract what’s important, discard the story. If you introduce notation, write it in LaTeX, between dollar signs. (e.g. “Given array \\(A\\) find the sum of its elements”)\n\n\n\n\n\n\nNote\n\n\n\nCallouts can now be inside statements, too. Hooray! 🥳 :)\nHere is an ok place if you want to make some comment which is neither the statement nor a solution.\nNumbers are fascinating, summing them up is magical, this problem is all about being fabulous.\nIf you thought that solution was brilliant, wait until you see the next one!"
  },
  {
    "objectID": "b0/problems/-template.html#sum-of-two-numbers",
    "href": "b0/problems/-template.html#sum-of-two-numbers",
    "title": "",
    "section": "",
    "text": "Sum of Two Numbers\n\nCodeforces\neasy\n\n\n\nA brief explanation of what the problem really wants from us. Keep it minimal, extract what’s important, discard the story. If you introduce notation, write it in LaTeX, between dollar signs. (e.g. “Given array \\(A\\) find the sum of its elements”)\n\n\n\n\n\n\nNote\n\n\n\nCallouts can now be inside statements, too. Hooray! 🥳 :)"
  },
  {
    "objectID": "b0/problems/leap-year.html",
    "href": "b0/problems/leap-year.html",
    "title": "",
    "section": "",
    "text": "Leap Year\n\n\neasy\n\n\n\nWrite a program that reads a year from the input, and then outputs whether it is a leap year or not.\nYou should research on your own which rule determines whether a year is a leap year.",
    "crumbs": [
      "Stage 1",
      "Practice Problems",
      "Leap Year"
    ]
  },
  {
    "objectID": "b0/problems/leap-year.html#leap-year",
    "href": "b0/problems/leap-year.html#leap-year",
    "title": "",
    "section": "",
    "text": "Leap Year\n\n\neasy\n\n\n\nWrite a program that reads a year from the input, and then outputs whether it is a leap year or not.",
    "crumbs": [
      "Stage 1",
      "Practice Problems",
      "Leap Year"
    ]
  },
  {
    "objectID": "b0/problems/middle-digits.html",
    "href": "b0/problems/middle-digits.html",
    "title": "",
    "section": "",
    "text": "Middle Digits\n\n\nmedium\n\n\n\nTwo natural numbers \\(x\\) and \\(y\\) are given, and each of them has an odd number of digits. Write a function SwapMidDigits(\\(x\\), \\(y\\)) that changes the values of these numbers in the following way:\nThe middle digit of \\(x\\) is removed and replaced with the middle digit of \\(y\\);\nThe middle digit of \\(y\\) is removed and replaced with the middle digit of \\(x\\).\nPrint the new numbers. The main function should only read \\(x\\) and \\(y\\), call the function SwapMidDigits, and then print the new values of \\(x\\) and \\(y\\).\nYou can assume that \\(100 \\leq x, y &lt; 10^9\\), and that \\(x\\) and \\(y\\) each have an odd number of digits.\nIf this seems too hard, you can try first to solve this task assuming that both \\(x\\) and \\(y\\) have \\(3\\) digits.",
    "crumbs": [
      "Stage 1",
      "Practice Problems",
      "Middle Digits"
    ]
  },
  {
    "objectID": "b0/problems/middle-digits.html#middle-digits",
    "href": "b0/problems/middle-digits.html#middle-digits",
    "title": "",
    "section": "",
    "text": "Middle Digits\n\n\nmedium\n\n\n\nTwo natural numbers \\(x\\) and \\(y\\) are given, and each of them has an odd number of digits. Write a function SwapMidDigits(\\(x\\), \\(y\\)) that changes the values of these numbers in the following way:\nThe middle digit of \\(x\\) is removed and replaced with the middle digit of \\(y\\);\nThe middle digit of \\(y\\) is removed and replaced with the middle digit of \\(x\\).\nPrint the new numbers. The main function should only read \\(x\\) and \\(y\\), call the function SwapMidDigits, and then print the new values of \\(x\\) and \\(y\\).\nYou can assume that \\(100 \\leq x, y &lt; 10^9\\), and that \\(x\\) and \\(y\\) each have an odd number of digits.",
    "crumbs": [
      "Stage 1",
      "Practice Problems",
      "Middle Digits"
    ]
  },
  {
    "objectID": "b0/problems/diverse-game.html",
    "href": "b0/problems/diverse-game.html",
    "title": "",
    "section": "",
    "text": "Diverse Game\n\nCodeforces\neasy\n\n\n\nThere are \\(T\\) test cases. In each test you are given a matrix \\(A\\) of size \\(N \\times M\\), containing all integers from \\(1\\) to \\(N \\cdot M\\) exactly once. Construct a matrix \\(B\\) of the same size such that for every cell \\((i, j)\\), \\(A_{i,j} \\neq B_{i,j}\\). If it is impossible, output \\(-1\\).",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Diverse Game"
    ]
  },
  {
    "objectID": "b0/problems/diverse-game.html#diverse-game",
    "href": "b0/problems/diverse-game.html#diverse-game",
    "title": "",
    "section": "",
    "text": "Diverse Game\n\nCodeforces\neasy\n\n\n\nThere are \\(T\\) test cases. In each test you are given a matrix \\(A\\) of size \\(N \\times M\\), containing all integers from \\(1\\) to \\(N \\cdot M\\) exactly once. Construct a matrix \\(B\\) of the same size such that for every cell \\((i, j)\\), \\(A_{i,j} \\neq B_{i,j}\\). If it is impossible, output \\(-1\\).",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Diverse Game"
    ]
  },
  {
    "objectID": "b0/problems/increasing-decreasing-digits.html",
    "href": "b0/problems/increasing-decreasing-digits.html",
    "title": "",
    "section": "",
    "text": "Increasing Decreasing Digits\n\n\nhard\n\n\n\nA number is called beautiful if it has at least \\(3\\) digits, does not contain the digit \\(0\\), and its digits form a strictly increasing sequence (of length at least \\(2\\)) from the beginning up to some digit, and then a strictly decreasing sequence (of length at least \\(2\\)) from that digit to the end.\nFor example, the numbers \\(125862\\), \\(565\\), and \\(89731\\) are beautiful, while \\(23241\\), \\(89722\\), and \\(1234\\) are not.\nFor a given natural number \\(A\\), determine the smallest beautiful number that is strictly greater than \\(A\\).\nFor example, for \\(A = 320557\\), the output should be \\(35321\\).\nYou can assume that \\(100 \\leq A \\leq 10^7\\).\nIf this seems too hard, you can try first to solve this task assuming that both \\(A\\) and the solutions will have \\(3\\) digits.",
    "crumbs": [
      "Stage 1",
      "Practice Problems",
      "Increasing Decreasing Digits"
    ]
  },
  {
    "objectID": "b0/problems/increasing-decreasing-digits.html#increasing-decreasing-digits",
    "href": "b0/problems/increasing-decreasing-digits.html#increasing-decreasing-digits",
    "title": "",
    "section": "",
    "text": "Increasing Decreasing Digits\n\n\nhard\n\n\n\nA number is called beautiful if it has at least \\(3\\) digits, does not contain the digit \\(0\\), and its digits form a strictly increasing sequence (of length at least \\(2\\)) from the beginning up to some digit, and then a strictly decreasing sequence (of length at least \\(2\\)) from that digit to the end.\nFor example, the numbers \\(125862\\), \\(565\\), and \\(89731\\) are beautiful, while \\(23241\\), \\(89722\\), and \\(1234\\) are not.\nFor a given natural number \\(A\\), determine the smallest beautiful number that is strictly greater than \\(A\\).\nFor example, for \\(A = 320557\\), the output should be \\(35321\\).\nYou can assume that \\(100 \\leq A \\leq 10^7\\).",
    "crumbs": [
      "Stage 1",
      "Practice Problems",
      "Increasing Decreasing Digits"
    ]
  },
  {
    "objectID": "b0/cp/problems-with-subproblems.html",
    "href": "b0/cp/problems-with-subproblems.html",
    "title": "Problems with Subproblems",
    "section": "",
    "text": "On Codeforces, a problem is either solved or not. Other platforms divide problems into subproblems with different constraints, each awarding points, so the verdict shows your score. This format is common in major contests like national and international Olympiads.\n\n\n\n\nIso-celestial\n\nCodeforces\n\n\n\nYou are given \\(N\\) points on a \\(2\\) dimensional coordinate plane, where \\(N \\leq 3000\\). Your task is to count the number of triplets of points which form an isosceles triangle.\n\n\nThe problem consists of three subproblems which differ only in the constraints on \\(N\\), as described by the table.\n\n\n\nSubproblem\nConstraints\nPoints\n\n\n\n\n1\n\\(N = 3\\)\n33\n\n\n2\n\\(N \\leq 100\\)\n33\n\n\n3\n\n34\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the third subproblem there are no additional constraints, meaning that the only constraints that will hold are the ones from the statement. For \\(N\\) that means \\(1 \\leq N \\leq 3000\\).\n\n\n\n\n\n\n\n\nSolution for Subproblem 1\n\nHere we are only given 3 points so either they form an isosceles triangle or they don’t. For this we can check if any 2 edges have equal lengths:\n\n#include\"bits/stdc++.h\"\nusing namespace std;\n\nint n;\n\nlong long x[3001], y[3001];\n\nlong double dist(int i, int j) {\n    long double dy = y[i] - y[j];\n    long double dx = x[i] - x[j];\n\n    return sqrtl(dy * dy + dx * dx);\n}\n\nbool f(int a, int b, int c) {\n    long double ab = dist(a, b);\n    long double ac = dist(a, c);\n    long double bc = dist(b, c);\n\n    return (ab == ac || ab == bc || ac == bc);\n}\n\nint main() {\n    cin &gt;&gt; n;\n\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; x[i]&gt;&gt; y[i];\n    }\n\n    cout &lt;&lt; f(0, 1, 2);\n}\n\n\n\n\n\n\nSolution for Subproblem 2\n\nSince \\(N \\leq 100\\) in this subproblem, we can loop over all triplets and test each one using the solution from the previous subproblem. This approach performs \\(O(N^3)\\) checks, which is too slow for the full problem, where \\(N \\leq 3000\\).\n\n#include\"bits/stdc++.h\"\nusing namespace std;\n\nint n;\n\nlong long x[3001], y[3001];\n\nlong double dist(int i, int j); // same as before\nbool f(int a, int b, int c); // same as before\n\nint main () {\n\n    cin &gt;&gt; n;\n\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; x[i]&gt;&gt; y[i];\n    }\n\n    int counter = 0;\n\n    for (int i = 0 ; i &lt; n ; i++) {\n        for (int j = i + 1 ; j &lt; n ; j++) {\n            for (int k = j + 1 ; k &lt; n ; k++) {\n                if (f(i, j, k)) counter++;\n            }\n        }\n    }\n\n    cout &lt;&lt; counter;\n}\n\n\n\n\n\n\nSolution for Subproblem 3 (Full solution)\n\nHere we need to think outside the box and make observations to come up with faster solutions. Lets consider a single point \\(P\\) and calculate the distance between \\(P\\) and every other point.\nWe can observe that if two points \\(X\\) and \\(Y\\) have the same distance from \\(P\\), then the triplet \\((P, X, Y)\\) forms an isosceles triangle. If there are \\(K\\) points all at the same distance from \\(P\\) then any pair from those \\(K\\) points when grouped with \\(P\\) will form an isosceles triangle.\nThis gives us an algorithm which performs \\(O(N^2)\\) steps. For each point \\(P\\), loop over every other point \\(Q\\) and count the number of times each distinct distance appears. Then loop over the distinct distances. Let \\(C\\) be the count for that distance. Add \\(C \\choose 2\\) to the answer.\n\n#include\"bits/stdc++.h\"\nusing namespace std;\n\nint n;\n\nlong long x[3001], y[3001];\n\nlong double dist (int i, int j); // same as before\n\nint main () {\n\n    cin &gt;&gt; n;\n\n    for (int i = 0 ; i &lt; n ; i++) {\n        cin &gt;&gt; x[i]&gt;&gt; y[i];\n    }\n\n    int counter = 0;\n\n    for (int i = 0 ; i &lt; n ; i++) {\n        long double all[n];\n\n        for (int j = 0 ; j &lt; n ; j++) {\n            all[j] = dist(i, j);\n        }\n\n        sort(all, all + n);\n\n        int cnt = 1;\n\n        for (int j = 1 ; j &lt; n ; j++) {\n            if (all[j] != all[j-1]) {\n                counter += cnt * (cnt - 1) / 2;\n                cnt = 0;\n            }\n            cnt++;\n        }\n\n        counter += cnt * (cnt - 1) / 2;\n    }\n\n    cout &lt;&lt; counter;\n}\n\nThe looping over all distinct distances is done by sorting all the distances, and going through this sorted order, but taking an action only when the current distance is different to the previous one. To simplify the code, we are conveniently using the fact that the distance of the point to itself will be listed at the index \\(0\\) in the sorted array, so the iteration can start from the index \\(1\\).",
    "crumbs": [
      "Stage 1",
      "Competitive Programming",
      "Problems with Subproblems"
    ]
  },
  {
    "objectID": "b0/cp/problems-with-subproblems.html#iso-celestial",
    "href": "b0/cp/problems-with-subproblems.html#iso-celestial",
    "title": "Problems with Subproblems",
    "section": "",
    "text": "Iso-celestial\n\nCodeforces\n\n\n\nYou are given \\(N\\) points on a \\(2\\) dimensional coordinate plane, where \\(N \\leq 3000\\). Your task is to count the number of triplets of points which form an isosceles triangle.\n\n\nThe problem consists of three subproblems which differ only in the constraints on \\(N\\), as described by the table.\n\n\n\nSubproblem\nConstraints\nPoints\n\n\n\n\n1\n\\(N = 3\\)\n33\n\n\n2\n\\(N \\leq 100\\)\n33\n\n\n3\n\n34\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the third subproblem there are no additional constraints, meaning that the only constraints that will hold are the ones from the statement. For \\(N\\) that means \\(1 \\leq N \\leq 3000\\).",
    "crumbs": [
      "Stage 1",
      "Competitive Programming",
      "Problems with Subproblems"
    ]
  },
  {
    "objectID": "b0/cpp/functions.html",
    "href": "b0/cpp/functions.html",
    "title": "Functions",
    "section": "",
    "text": "A function is a block of code under a particular name. You can call this name to execute the block of code whenever needed.\nA function in C++ is composed 4 main parts:\n\nFunction name — The name that’s going to be used to call the function.\nThe body of the function — The place where the code of the functions is written.\nThe parameters — Values that are passed to the function when calling it. A function can have any number of parameters (possibly zero).\nThe return type — Functions return a value to the position where it was called. The return type specifies the type of that returned value. If a function doesn’t return anything, its return type should be void.\n\n\n\n\n\n\nFunctions are written globally (outside the main function) with the following syntax:\nreturn_type function_name(parameter1, parameter2, ... , parameterN) {\n    // body of the function (the block of code)\n}\n\nreturn_type: The type of the value the function is going to return (e.g int, long long, string, etc). If return_type is void then the function won’t return any value.\nfunction_name: The name given to the function so we can call it by this name.\nparameter1, parameter2, ... , parameterN: The parameters of the function\n\n\n\n\nTo call a function we’ll use the following syntax:\nfunction_name(value1, value2, ... , valueN);\n\n\n\nLet’s assume that the function doesn’t return anything (i.e return_type is void), there are no parameters, and that it just prints a simple text. It could look like this:\n#include&lt;iostream&gt;\nusing namespace std;\n \nvoid f() { // a function named f which doesn't return anything (void) and doesn't take parameters\n    cout &lt;&lt; \"Hello Function\" &lt;&lt; endl;\n}\n \nint main() { // program starts here\n    f();\n    cout &lt;&lt; \"Hello Main\" &lt;&lt; endl;\n    f();\n}\nHere the output will be:\nHello Function\nHello Main\nHello Function\nThis program contains two functions: f() and main(). C++ only calls main(), and inside it, other functions are called. First, The function f() is called by main(), so the program starts executing it. The statement cout &lt;&lt; \"Hello Function\" &lt;&lt; endl gets executed. When the function f() finishes, the program returns to main() and continues with the next statement, executing cout &lt;&lt; \"Hello Main\" &lt;&lt; endl;. After that, function f() is called again and cout &lt;&lt; \"Hello Function\" &lt;&lt; endl is executed a second time.\n\n\n\n\n\n\nParameters are similar to variables. They receive a value whenever the function is called and they’re defined in a similar way parameter_type parameter_name. For example:\nvoid multiply(int x, int y) {\n    cout &lt;&lt; x * y &lt;&lt; endl;\n}\nHere we defined a function multiply() that accepts two parameters (x and y) and prints its their product.\n\n\n\nNow, to call function multiply() we need to provide the values of x and y. This will be done by putting the values of x and y respectively between the brackets when calling multiply(). Note that the order of values given when calling a function must match the order of the parameters when defining the function. For example if we want to print the multiplication of 5 and 3 we’ll call multiply() in the following format:\nmultiply(5, 3);\nWhat happened here is that multiply got called with x = 5 and y = 3.\n\n\n\n\n\nflowchart BT\n    subgraph Call\n        F[\"multiply(5, 3);\"]\n    end\n\n    subgraph Function\n        M[\"int multiply(int x, int y)\"]\n        X[\"x = 5\"]\n        Y[\"y = 3\"]\n    end\n\n    F --&gt; X\n    F --&gt; Y\n    X --&gt; M\n    Y --&gt; M\n\n\n\n\n\n\n\n\n\n\nWhen we call a function and pass a variable, the parameter saves a copy of the passed variable’s value. This means if we change the value of the parameter, the value of the passed variable won’t be changed. This is called passing by value. However, there’s another way of passing variables called passing by reference where the parameter doesn’t copy the value of the passed variable. Instead it becomes the variable itself — so changes to the parameter in the function affect the passed variable’s value.\nTo write a function that passes a parameter by reference we add a & character before the parameters name. For example, we’ll write a function that takes one integer and adds 1 to it. Let’s see how the function will look if we pass by value:\nvoid addOneByValue(int x) {\n    x = x + 1;\n}\nAnd if we use passing by reference:\nvoid addOneByReference(int &x) {\n    x = x + 1;\n}\nLet’s write a code using both functions.\n#include&lt;iostream&gt;\nusing namespace std;\n\nvoid addOneByReference(int &x) {\n    x = x + 1;\n}\n\nvoid addOneByValue(int x) {\n    x = x + 1;\n}\n\nint main() {\n    int n = 5;\n    addOneByValue(n); // x will copy the value from n, and n won't change\n    cout &lt;&lt; n &lt;&lt; endl;\n    addOneByReference(n); // x will become n itself, so editing x will edit n\n    cout &lt;&lt; n &lt;&lt; endl;\n}\nThe output will be:\n5\n6\nNote that calling the functions doesn’t change. when we called addOneByValue(n);, the value of n got copied into x and when we changed x, n didn’t change. However, when we called addOneByReference(n);, x became n so when we added one to x, the value of n changed as well.\n\n\n\n\nWhen a function finishes, it can return a value to the position where it got called. To do this, we need to specify the type of the returned value before the function name. The function then uses the return statement to provide the value. For example:\n#include&lt;iostream&gt;\nusing namespace std;\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int result = add(5, 3); // result now holds 8\n}\n\nint (before add) tells that the function will return an integer.\nreturn a + b tells to return the value of a + b to the position where add() got called.\nint result = add(5, 3) tells that the returned value will be assigned to result.\n\nHere is a diagram that shows what happened:\n\n\n\n\n\nsequenceDiagram\n    participant main()\n    participant Add()\n\n    main()-&gt;&gt;Add(): call add(5, 3)\n    Add()-&gt;&gt;Add(): compute a + b\n    Add()--&gt;&gt;main(): return 8\n    main()-&gt;&gt;main(): result = 8\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAfter calling return a + b; the function ends immediatelly. Any statement after the return statement won’t be executed.\n\n\n\n\n\n\n\nWe can call a function within another function. If that function finishes it returns to the function that called it. For example this code:\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvoid m() {\n    cout &lt;&lt; \"third\" &lt;&lt; endl;\n}\n\nvoid f() {\n    cout &lt;&lt; \"second\" &lt;&lt; endl;\n    m();\n    cout &lt;&lt; \"fourth\" &lt;&lt; endl;\n}\n\nint main() {\n    cout &lt;&lt; \"first\" &lt;&lt; endl;\n    f();\n    cout &lt;&lt; \"fifth\" &lt;&lt; endl;\n}\nThe output is going to be:\nfirst\nsecond\nthird\nfourth\nfifth\nThe program starts by executing the main() function, which runs the statement cout &lt;&lt; \"first\" &lt;&lt; endl;. After that, main() calls the function f(). Inside f(), the statement cout &lt;&lt; \"second\" &lt;&lt; endl; is executed, and then the function m() is called. Inside m(), the statement cout &lt;&lt; \"third\" &lt;&lt; endl; is executed. When m() finishes, control returns to f(), where the program continues with cout &lt;&lt; \"fourth\" &lt;&lt; endl;. After that, f() finishes and returns to main(), which then executes the final statement cout &lt;&lt; \"fifth\" &lt;&lt; endl;.\nHere’s a sequence diagram of what happened:\n\n\n\n\n\nsequenceDiagram\n    participant main()\n    participant f()\n    participant m()\n\n    main()-&gt;&gt;main(): cout &lt;&lt; \"first\" &lt;&lt; endl;\n    main()-&gt;&gt;f(): call f()\n    f()-&gt;&gt;f(): cout &lt;&lt; \"second\" &lt;&lt; endl;;\n    f()-&gt;&gt;m(): call m();\n    m()-&gt;&gt;m(): cout &lt;&lt; \"third\" &lt;&lt; endl;;\n    m()--&gt;&gt;f(): return \n    f()-&gt;&gt;f(): cout &lt;&lt; \"fourth\" &lt;&lt; endl;;\n    f()--&gt;&gt;main(): return \n    main()-&gt;&gt;main(): cout &lt;&lt; \"fifth\" &lt;&lt; endl;\n\n\n\n\n\n\n\n\n\n\nA functions that calls itself is called recursitive. An example of a problem that can be solved using recursive functions is calculating factorials. In math, the factorial of a number \\(n\\) is written as \\(n!\\) and it is computed as follows.\n\\(n! = 1 * 2 * 3 * \\ldots * (n - 1) * n\\)\nSo, the factorial of \\(4\\) will be:\n\\(4! = 1 * 2 * 3 * 4 = 24\\)\nA function that calculates \\(n!\\) will look as follows:\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint factorial(int x) {\n    if (x &lt;= 1) {\n        return 1;\n    }\n    else {\n        return factorial(x - 1) * x;\n    }\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; factorial(n) &lt;&lt; endl;\n}\nHere we made a function that calls itself. For example, if we give it 3 as an input, the main function will call factorial(3), and it will call factorial(2) that will call factorial(1). factorial(1) will return 1 to the position that called it (in factorial(2)) which will return factorial(1) * 2  = 1 * 2 = 2 to factorial(3). Finally, factorial(3) will return factorial(2) * 3 = 2 * 3 = 6 to main(), which will print 6 at the output.\n\n\n\n\n\n\nNote\n\n\n\nThe condition at the beggining of the recursion, if (x &lt;= 1), is very important. Without it the function would be calling itself indefinitely.\n\n\n\n\n\n\n\nsequenceDiagram\n    participant main()\n    participant f(3)\n    participant f(2)\n    participant f(1)\n\n\n    \n    main()-&gt;&gt;f(3): call f(3)\n    f(3)-&gt;&gt;f(2): call f(2)\n    f(2)-&gt;&gt;f(1): call f(1)\n    f(1)--&gt;&gt;f(2): return 1\n    f(2)--&gt;&gt;f(3): return 1 * 2\n    f(3)--&gt;&gt;main(): return 2 * 3",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Functions"
    ]
  },
  {
    "objectID": "b0/cpp/functions.html#what-is-a-function",
    "href": "b0/cpp/functions.html#what-is-a-function",
    "title": "Functions",
    "section": "",
    "text": "A function is a block of code under a particular name. You can call this name to execute the block of code whenever needed.\nA function in C++ is composed 4 main parts:\n\nFunction name — The name that’s going to be used to call the function.\nThe body of the function — The place where the code of the functions is written.\nThe parameters — Values that are passed to the function when calling it. A function can have any number of parameters (possibly zero).\nThe return type — Functions return a value to the position where it was called. The return type specifies the type of that returned value. If a function doesn’t return anything, its return type should be void.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Functions"
    ]
  },
  {
    "objectID": "b0/cpp/functions.html#syntax",
    "href": "b0/cpp/functions.html#syntax",
    "title": "Functions",
    "section": "",
    "text": "Functions are written globally (outside the main function) with the following syntax:\nreturn_type function_name(parameter1, parameter2, ... , parameterN) {\n    // body of the function (the block of code)\n}\n\nreturn_type: The type of the value the function is going to return (e.g int, long long, string, etc). If return_type is void then the function won’t return any value.\nfunction_name: The name given to the function so we can call it by this name.\nparameter1, parameter2, ... , parameterN: The parameters of the function\n\n\n\n\nTo call a function we’ll use the following syntax:\nfunction_name(value1, value2, ... , valueN);\n\n\n\nLet’s assume that the function doesn’t return anything (i.e return_type is void), there are no parameters, and that it just prints a simple text. It could look like this:\n#include&lt;iostream&gt;\nusing namespace std;\n \nvoid f() { // a function named f which doesn't return anything (void) and doesn't take parameters\n    cout &lt;&lt; \"Hello Function\" &lt;&lt; endl;\n}\n \nint main() { // program starts here\n    f();\n    cout &lt;&lt; \"Hello Main\" &lt;&lt; endl;\n    f();\n}\nHere the output will be:\nHello Function\nHello Main\nHello Function\nThis program contains two functions: f() and main(). C++ only calls main(), and inside it, other functions are called. First, The function f() is called by main(), so the program starts executing it. The statement cout &lt;&lt; \"Hello Function\" &lt;&lt; endl gets executed. When the function f() finishes, the program returns to main() and continues with the next statement, executing cout &lt;&lt; \"Hello Main\" &lt;&lt; endl;. After that, function f() is called again and cout &lt;&lt; \"Hello Function\" &lt;&lt; endl is executed a second time.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Functions"
    ]
  },
  {
    "objectID": "b0/cpp/functions.html#parameters",
    "href": "b0/cpp/functions.html#parameters",
    "title": "Functions",
    "section": "",
    "text": "Parameters are similar to variables. They receive a value whenever the function is called and they’re defined in a similar way parameter_type parameter_name. For example:\nvoid multiply(int x, int y) {\n    cout &lt;&lt; x * y &lt;&lt; endl;\n}\nHere we defined a function multiply() that accepts two parameters (x and y) and prints its their product.\n\n\n\nNow, to call function multiply() we need to provide the values of x and y. This will be done by putting the values of x and y respectively between the brackets when calling multiply(). Note that the order of values given when calling a function must match the order of the parameters when defining the function. For example if we want to print the multiplication of 5 and 3 we’ll call multiply() in the following format:\nmultiply(5, 3);\nWhat happened here is that multiply got called with x = 5 and y = 3.\n\n\n\n\n\nflowchart BT\n    subgraph Call\n        F[\"multiply(5, 3);\"]\n    end\n\n    subgraph Function\n        M[\"int multiply(int x, int y)\"]\n        X[\"x = 5\"]\n        Y[\"y = 3\"]\n    end\n\n    F --&gt; X\n    F --&gt; Y\n    X --&gt; M\n    Y --&gt; M\n\n\n\n\n\n\n\n\n\n\nWhen we call a function and pass a variable, the parameter saves a copy of the passed variable’s value. This means if we change the value of the parameter, the value of the passed variable won’t be changed. This is called passing by value. However, there’s another way of passing variables called passing by reference where the parameter doesn’t copy the value of the passed variable. Instead it becomes the variable itself — so changes to the parameter in the function affect the passed variable’s value.\nTo write a function that passes a parameter by reference we add a & character before the parameters name. For example, we’ll write a function that takes one integer and adds 1 to it. Let’s see how the function will look if we pass by value:\nvoid addOneByValue(int x) {\n    x = x + 1;\n}\nAnd if we use passing by reference:\nvoid addOneByReference(int &x) {\n    x = x + 1;\n}\nLet’s write a code using both functions.\n#include&lt;iostream&gt;\nusing namespace std;\n\nvoid addOneByReference(int &x) {\n    x = x + 1;\n}\n\nvoid addOneByValue(int x) {\n    x = x + 1;\n}\n\nint main() {\n    int n = 5;\n    addOneByValue(n); // x will copy the value from n, and n won't change\n    cout &lt;&lt; n &lt;&lt; endl;\n    addOneByReference(n); // x will become n itself, so editing x will edit n\n    cout &lt;&lt; n &lt;&lt; endl;\n}\nThe output will be:\n5\n6\nNote that calling the functions doesn’t change. when we called addOneByValue(n);, the value of n got copied into x and when we changed x, n didn’t change. However, when we called addOneByReference(n);, x became n so when we added one to x, the value of n changed as well.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Functions"
    ]
  },
  {
    "objectID": "b0/cpp/functions.html#returns",
    "href": "b0/cpp/functions.html#returns",
    "title": "Functions",
    "section": "",
    "text": "When a function finishes, it can return a value to the position where it got called. To do this, we need to specify the type of the returned value before the function name. The function then uses the return statement to provide the value. For example:\n#include&lt;iostream&gt;\nusing namespace std;\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int result = add(5, 3); // result now holds 8\n}\n\nint (before add) tells that the function will return an integer.\nreturn a + b tells to return the value of a + b to the position where add() got called.\nint result = add(5, 3) tells that the returned value will be assigned to result.\n\nHere is a diagram that shows what happened:\n\n\n\n\n\nsequenceDiagram\n    participant main()\n    participant Add()\n\n    main()-&gt;&gt;Add(): call add(5, 3)\n    Add()-&gt;&gt;Add(): compute a + b\n    Add()--&gt;&gt;main(): return 8\n    main()-&gt;&gt;main(): result = 8\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAfter calling return a + b; the function ends immediatelly. Any statement after the return statement won’t be executed.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Functions"
    ]
  },
  {
    "objectID": "b0/cpp/functions.html#recursivity",
    "href": "b0/cpp/functions.html#recursivity",
    "title": "Functions",
    "section": "",
    "text": "We can call a function within another function. If that function finishes it returns to the function that called it. For example this code:\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvoid m() {\n    cout &lt;&lt; \"third\" &lt;&lt; endl;\n}\n\nvoid f() {\n    cout &lt;&lt; \"second\" &lt;&lt; endl;\n    m();\n    cout &lt;&lt; \"fourth\" &lt;&lt; endl;\n}\n\nint main() {\n    cout &lt;&lt; \"first\" &lt;&lt; endl;\n    f();\n    cout &lt;&lt; \"fifth\" &lt;&lt; endl;\n}\nThe output is going to be:\nfirst\nsecond\nthird\nfourth\nfifth\nThe program starts by executing the main() function, which runs the statement cout &lt;&lt; \"first\" &lt;&lt; endl;. After that, main() calls the function f(). Inside f(), the statement cout &lt;&lt; \"second\" &lt;&lt; endl; is executed, and then the function m() is called. Inside m(), the statement cout &lt;&lt; \"third\" &lt;&lt; endl; is executed. When m() finishes, control returns to f(), where the program continues with cout &lt;&lt; \"fourth\" &lt;&lt; endl;. After that, f() finishes and returns to main(), which then executes the final statement cout &lt;&lt; \"fifth\" &lt;&lt; endl;.\nHere’s a sequence diagram of what happened:\n\n\n\n\n\nsequenceDiagram\n    participant main()\n    participant f()\n    participant m()\n\n    main()-&gt;&gt;main(): cout &lt;&lt; \"first\" &lt;&lt; endl;\n    main()-&gt;&gt;f(): call f()\n    f()-&gt;&gt;f(): cout &lt;&lt; \"second\" &lt;&lt; endl;;\n    f()-&gt;&gt;m(): call m();\n    m()-&gt;&gt;m(): cout &lt;&lt; \"third\" &lt;&lt; endl;;\n    m()--&gt;&gt;f(): return \n    f()-&gt;&gt;f(): cout &lt;&lt; \"fourth\" &lt;&lt; endl;;\n    f()--&gt;&gt;main(): return \n    main()-&gt;&gt;main(): cout &lt;&lt; \"fifth\" &lt;&lt; endl;\n\n\n\n\n\n\n\n\n\n\nA functions that calls itself is called recursitive. An example of a problem that can be solved using recursive functions is calculating factorials. In math, the factorial of a number \\(n\\) is written as \\(n!\\) and it is computed as follows.\n\\(n! = 1 * 2 * 3 * \\ldots * (n - 1) * n\\)\nSo, the factorial of \\(4\\) will be:\n\\(4! = 1 * 2 * 3 * 4 = 24\\)\nA function that calculates \\(n!\\) will look as follows:\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint factorial(int x) {\n    if (x &lt;= 1) {\n        return 1;\n    }\n    else {\n        return factorial(x - 1) * x;\n    }\n}\n\nint main() {\n    int n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; factorial(n) &lt;&lt; endl;\n}\nHere we made a function that calls itself. For example, if we give it 3 as an input, the main function will call factorial(3), and it will call factorial(2) that will call factorial(1). factorial(1) will return 1 to the position that called it (in factorial(2)) which will return factorial(1) * 2  = 1 * 2 = 2 to factorial(3). Finally, factorial(3) will return factorial(2) * 3 = 2 * 3 = 6 to main(), which will print 6 at the output.\n\n\n\n\n\n\nNote\n\n\n\nThe condition at the beggining of the recursion, if (x &lt;= 1), is very important. Without it the function would be calling itself indefinitely.\n\n\n\n\n\n\n\nsequenceDiagram\n    participant main()\n    participant f(3)\n    participant f(2)\n    participant f(1)\n\n\n    \n    main()-&gt;&gt;f(3): call f(3)\n    f(3)-&gt;&gt;f(2): call f(2)\n    f(2)-&gt;&gt;f(1): call f(1)\n    f(1)--&gt;&gt;f(2): return 1\n    f(2)--&gt;&gt;f(3): return 1 * 2\n    f(3)--&gt;&gt;main(): return 2 * 3",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Functions"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html",
    "href": "b0/cpp/operators.html",
    "title": "Operators",
    "section": "",
    "text": "Operator let us perform calculations or modify variables. Here’s a list of some basic operators in C++.\n\n\nThe assignment operator allows us to set a specific value to a variable.\nint x;\nx = 5; // here we set the value of the variable 'x' to 5\nIn the previous example, 5 (the right operand) was assigned to x (the left operand). The order of evaluation is from right to left (more on this in a later example)\n\n\n\n\n\n\nOperator\nMeaning\n\n\n\n\n*\nMultiplication\n\n\n/\nDivision\n\n\n%\nModulo\n\n\n+\nAddition\n\n\n-\nSubtraction\n\n\n\nAll these operators are binary operators, meaning they require two operands. For example:\n5 * 3\n1 + 1\n6 / 2\nThe modulo operator (%) gives the remainder of diving the left operand by the right operand. The remaining operations are applied in the same way as regular mathematics.\n\n\n\nThe value that we assign to a variable does not have to be a simple constant or other variable. We can actually assign full expressions which use arithmetic operators.\nint x, y;\nx = 5;\ny = 3 + 2 * x;\n// since '*' comes before '+' in operator precedence, y will be 13 not 25\n\n\n\nSuppose we had a variable x and we wanted to add some value to it, multiply it by some value or apply some operation and assign its result to x. Normally we would use x = x + y or x = x * y. We can instead do x += y or x *= y and it would do the same operation.\n\n\n\nExpression\nUsing Compound\n\n\n\n\nx = x + y\nx += y\n\n\nx = x - 5\nx -= 5\n\n\nx = x / y\nx /= y\n\n\nprice = price * (units + 1)\nprice *= units + 1\n\n\n\n\n\n\nIf we wanted to add 1 to some variable x we saw that we can shorten it to x += 1, but when we are adding or subtracting 1, we have an even shorter way to write it using increment and decrement operators.\n\nint x;\nx = 0;\nx++; // after this line is executed x is 1\nx--; // after this line is executed x is 0\nA subtle difference between ++ and += 1 is that ++ and -- can be written before (prefix) or after (suffix) a variable and each has its own meaning. We will explore the difference with an example:\nint x, y;\nx = 1;\ny = ++x;\nIn this example y will be 2 because when ++ is before the variable we first apply the increment then use its value.\nint x, y;\nx = 1;\ny = x++;\nHere, y will be 1 because when ++ is after the variable we first use the value of the variable then apply the increment.\n\n\n\nSimilar to arithmetic operators, these are binary operators meaning they take two operands, but here we are comparing the operands and what we get in return is a boolean.\nReminder: Booleans are data types which store a value that is either true or false\n\n\n\nOperator\nDescription\n\n\n\n\n==\nEqual to\n\n\n!=\nNot equal to\n\n\n&lt;\nLess than\n\n\n&gt;\nGreater than\n\n\n&lt;=\nLess than or equal to\n\n\n&gt;=\nGreater than or equal to\n\n\n\nint x = 1, y = 2; \nbool same = (x==y); // since x and y are not equal (x==y) will be 'false'\nbool x_less_than_y = (x &lt; y); // since x &lt; y the expression will be 'true'\nComparision is not only limited to variables, the left and right operands may be full expressions, for example:\nint x = 5;\nbool even = (x % 2 == 0);\n// a number is even if it can be divided by 2 with no remainder\n// in this case 'false' will be assigned to the variable 'even'\n\n\n\nThe ! operator (NOT) is a unary operator meaning it has only one operand which is a boolean. If the operand’s value is true then this operation produces false otherwise it produces true.\nbool a = (5 &gt; 7);  // false\nbool b = !a;       // true\nbool c = !(7 &gt; 5); // false\nThe && and || operators are operators which receive two boolean values as operands. The && operator (AND) produces true if both operands’ values are true and produces false otherwise.\nbool a = (5 % 2 == 0); // false, 5 is odd\nbool b = (3 &gt; 2); // true\nbool c = a && b; // false because a is false\nbool d = (!c) && b; // true because (!c) is true and b is true\nThe || operator (OR) produces true if at least one of its operands’ values are true and produces false otherwise.\nbool a = (5 &lt; 2); // false\nbool b = (4 % 2 == 0); // true, 4 is even\nbool c = a && b; // false, because a is false\nbool d = b || c; //  true, because b is true\nA special and important property of the AND and OR operators is the short-circuit evaluation. Suppose we have two boolean expressions A and B, if we want to evaluate A && B and we know that A is false, then we dont need to evaluate B, because we know that A && B is false.\nThis is important in cases where evaluating the right operand modifies values, for example:\nint x = 0;\nbool b = (5 % 2 == 0) && (x++ == 0); \nSince 5 % 2 == 0 is false, the execution does not evaluate the expression (x++ == 0) which means that x never gets incremented. Similarly for the || operator if the first operand is true the evaluation of the second operand is skipped.\n\n\n\nThis operator is a ternary operator meaning it accepts three operands: condition, expression_t and expression_f. The syntax is as follows:\ncondition ? expression_t : expression_f\nIf the condition provided evaluates to true then the statement produces expression_t, otherwise it produces expression_f. \nint x = 5;\nint y = (x % 2 == 0 ? x : x + 1); // if x is even then y = x, otherwise y = x + 1\n                                  // since 5 is odd then y = x + 1 = 6\nIf we had two integers a and b and we wanted the larger one, we can do the following:\nint max = (a &gt; b ? a : b);\n\n\n\nWhen an expression has multiple operators, C++ has a defined order in which it performs these operations. For example 5 + 7 % 2 evaluates to 6 because % happens before +. If instead we had (5 + 7) % 2 then the result would be 0.\nFrom greatest to smallest priority, C++ operators are evaluated in the following order:\n\n\n\n\n\n\n\n\n\n\nLevel\nPrecedence group\nOperator\nDescription\nGrouping\n\n\n\n\n1\nPostfix (unary)\n++ –\npostfix increment / decrement\nLeft-to-right\n\n\n2\nPrefix (unary)\n++ – !\nprefix increment / decrementlogical NOT\nRight-to-left\n\n\n3\nArithmetic: scaling\n* / %\nmultiply, divide, modulo\nLeft-to-right\n\n\n4\nArithmetic: addition\n+ -\naddition, subtraction\nLeft-to-right\n\n\n5\nRelational\n&lt; &gt; &lt;= &gt;=\ncomparison operators\nLeft-to-right\n\n\n6\nEquality\n==  !=\nequality / inequality\nLeft-to-right\n\n\n7\nConjunction\n&&\nlogical AND\nLeft-to-right\n\n\n8\nDisjunction\n||\nlogical OR\nLeft-to-right\n\n\n9\nAssignment-level expressions\n= *= /= %= += -=  ?:\nassignment / compound assignmentconditional operator\nRight-to-left",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Operators"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#assignment",
    "href": "b0/cpp/operators.html#assignment",
    "title": "Operators",
    "section": "",
    "text": "The assignment operator allows us to set a specific value to a variable.\nint x;\nx = 5; // here we set the value of the variable 'x' to 5\nIn the previous example, 5 (the right operand) was assigned to x (the left operand). The order of evaluation is from right to left (more on this in a later example)",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Operators"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#arithmetic-operators--",
    "href": "b0/cpp/operators.html#arithmetic-operators--",
    "title": "Operators",
    "section": "",
    "text": "Operator\nMeaning\n\n\n\n\n*\nMultiplication\n\n\n/\nDivision\n\n\n%\nModulo\n\n\n+\nAddition\n\n\n-\nSubtraction\n\n\n\nAll these operators are binary operators, meaning they require two operands. For example:\n5 * 3\n1 + 1\n6 / 2\nThe modulo operator (%) gives the remainder of diving the left operand by the right operand. The remaining operations are applied in the same way as regular mathematics.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Operators"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#assigning-expressions",
    "href": "b0/cpp/operators.html#assigning-expressions",
    "title": "Operators",
    "section": "",
    "text": "The value that we assign to a variable does not have to be a simple constant or other variable. We can actually assign full expressions which use arithmetic operators.\nint x, y;\nx = 5;\ny = 3 + 2 * x;\n// since '*' comes before '+' in operator precedence, y will be 13 not 25",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Operators"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#compound-assignments--",
    "href": "b0/cpp/operators.html#compound-assignments--",
    "title": "Operators",
    "section": "",
    "text": "Suppose we had a variable x and we wanted to add some value to it, multiply it by some value or apply some operation and assign its result to x. Normally we would use x = x + y or x = x * y. We can instead do x += y or x *= y and it would do the same operation.\n\n\n\nExpression\nUsing Compound\n\n\n\n\nx = x + y\nx += y\n\n\nx = x - 5\nx -= 5\n\n\nx = x / y\nx /= y\n\n\nprice = price * (units + 1)\nprice *= units + 1",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Operators"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#increment-and-decrement---",
    "href": "b0/cpp/operators.html#increment-and-decrement---",
    "title": "Operators",
    "section": "",
    "text": "If we wanted to add 1 to some variable x we saw that we can shorten it to x += 1, but when we are adding or subtracting 1, we have an even shorter way to write it using increment and decrement operators.\n\nint x;\nx = 0;\nx++; // after this line is executed x is 1\nx--; // after this line is executed x is 0\nA subtle difference between ++ and += 1 is that ++ and -- can be written before (prefix) or after (suffix) a variable and each has its own meaning. We will explore the difference with an example:\nint x, y;\nx = 1;\ny = ++x;\nIn this example y will be 2 because when ++ is before the variable we first apply the increment then use its value.\nint x, y;\nx = 1;\ny = x++;\nHere, y will be 1 because when ++ is after the variable we first use the value of the variable then apply the increment.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Operators"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#relational-and-comparison-operators",
    "href": "b0/cpp/operators.html#relational-and-comparison-operators",
    "title": "Operators",
    "section": "",
    "text": "Similar to arithmetic operators, these are binary operators meaning they take two operands, but here we are comparing the operands and what we get in return is a boolean.\nReminder: Booleans are data types which store a value that is either true or false\n\n\n\nOperator\nDescription\n\n\n\n\n==\nEqual to\n\n\n!=\nNot equal to\n\n\n&lt;\nLess than\n\n\n&gt;\nGreater than\n\n\n&lt;=\nLess than or equal to\n\n\n&gt;=\nGreater than or equal to\n\n\n\nint x = 1, y = 2; \nbool same = (x==y); // since x and y are not equal (x==y) will be 'false'\nbool x_less_than_y = (x &lt; y); // since x &lt; y the expression will be 'true'\nComparision is not only limited to variables, the left and right operands may be full expressions, for example:\nint x = 5;\nbool even = (x % 2 == 0);\n// a number is even if it can be divided by 2 with no remainder\n// in this case 'false' will be assigned to the variable 'even'",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Operators"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#logical-operators",
    "href": "b0/cpp/operators.html#logical-operators",
    "title": "Operators",
    "section": "",
    "text": "The ! operator (NOT) is a unary operator meaning it has only one operand which is a boolean. If the operand’s value is true then this operation produces false otherwise it produces true.\nbool a = (5 &gt; 7);  // false\nbool b = !a;       // true\nbool c = !(7 &gt; 5); // false\nThe && and || operators are operators which receive two boolean values as operands. The && operator (AND) produces true if both operands’ values are true and produces false otherwise.\nbool a = (5 % 2 == 0); // false, 5 is odd\nbool b = (3 &gt; 2); // true\nbool c = a && b; // false because a is false\nbool d = (!c) && b; // true because (!c) is true and b is true\nThe || operator (OR) produces true if at least one of its operands’ values are true and produces false otherwise.\nbool a = (5 &lt; 2); // false\nbool b = (4 % 2 == 0); // true, 4 is even\nbool c = a && b; // false, because a is false\nbool d = b || c; //  true, because b is true\nA special and important property of the AND and OR operators is the short-circuit evaluation. Suppose we have two boolean expressions A and B, if we want to evaluate A && B and we know that A is false, then we dont need to evaluate B, because we know that A && B is false.\nThis is important in cases where evaluating the right operand modifies values, for example:\nint x = 0;\nbool b = (5 % 2 == 0) && (x++ == 0); \nSince 5 % 2 == 0 is false, the execution does not evaluate the expression (x++ == 0) which means that x never gets incremented. Similarly for the || operator if the first operand is true the evaluation of the second operand is skipped.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Operators"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#conditional-ternary-operator",
    "href": "b0/cpp/operators.html#conditional-ternary-operator",
    "title": "Operators",
    "section": "",
    "text": "This operator is a ternary operator meaning it accepts three operands: condition, expression_t and expression_f. The syntax is as follows:\ncondition ? expression_t : expression_f\nIf the condition provided evaluates to true then the statement produces expression_t, otherwise it produces expression_f. \nint x = 5;\nint y = (x % 2 == 0 ? x : x + 1); // if x is even then y = x, otherwise y = x + 1\n                                  // since 5 is odd then y = x + 1 = 6\nIf we had two integers a and b and we wanted the larger one, we can do the following:\nint max = (a &gt; b ? a : b);",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Operators"
    ]
  },
  {
    "objectID": "b0/cpp/operators.html#precendence-of-operators",
    "href": "b0/cpp/operators.html#precendence-of-operators",
    "title": "Operators",
    "section": "",
    "text": "When an expression has multiple operators, C++ has a defined order in which it performs these operations. For example 5 + 7 % 2 evaluates to 6 because % happens before +. If instead we had (5 + 7) % 2 then the result would be 0.\nFrom greatest to smallest priority, C++ operators are evaluated in the following order:\n\n\n\n\n\n\n\n\n\n\nLevel\nPrecedence group\nOperator\nDescription\nGrouping\n\n\n\n\n1\nPostfix (unary)\n++ –\npostfix increment / decrement\nLeft-to-right\n\n\n2\nPrefix (unary)\n++ – !\nprefix increment / decrementlogical NOT\nRight-to-left\n\n\n3\nArithmetic: scaling\n* / %\nmultiply, divide, modulo\nLeft-to-right\n\n\n4\nArithmetic: addition\n+ -\naddition, subtraction\nLeft-to-right\n\n\n5\nRelational\n&lt; &gt; &lt;= &gt;=\ncomparison operators\nLeft-to-right\n\n\n6\nEquality\n==  !=\nequality / inequality\nLeft-to-right\n\n\n7\nConjunction\n&&\nlogical AND\nLeft-to-right\n\n\n8\nDisjunction\n||\nlogical OR\nLeft-to-right\n\n\n9\nAssignment-level expressions\n= *= /= %= += -=  ?:\nassignment / compound assignmentconditional operator\nRight-to-left",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Operators"
    ]
  },
  {
    "objectID": "b0/cpp/name-visibility.html",
    "href": "b0/cpp/name-visibility.html",
    "title": "Name Visibility",
    "section": "",
    "text": "In C++, the position where a variable is declared affects where it can be used.\n\n\nA scope is the region of a program where a name can be used and can be accessed directly by its name. We say the name is visible in that scope. Most scopes are the areas surrounded by curly brackets {}. The area outside any scope is called a global scope. Any other area is called a local scope.\n#include&lt;iostream&gt;\nusing namespace std;\n\n// global scope\nint x = 5;\n\nint main() {\n    // local scope 1\n    int y = 4\n    \n    for (int i = 0 ; i &lt; 5 ; i++) {\n        // local scope 2\n        int z = 20;\n        if (i % 2 == 0) {\n            // local scope 3\n            cout &lt;&lt; z + x &lt;&lt; ' ' &lt;&lt; z + y &lt;&lt; endl;\n        }\n        else {\n            // local scope 4\n            cout &lt;&lt; z - y &lt;&lt; ' ' &lt;&lt; z - x &lt;&lt; endl;\n        }\n    }\n}\nIn this example we have a global scope and 4 local scopes. Note that the scope 1 extend through the whole main function, the scope 2 is the region inside the for loop, and scopes 3 and 4 are the areas inside each of the if and else blocks repsectively.\n\n\n\nGlobally initialized variables (also called global variables) are visible and can be used in all scopes after their intialization. Locally initialized variables (also called local variables) are visible only within the scope they are declared in. This includes the scopes nested within their scopes, i.e. inner scopes.\nLooking at the previouse example this is the visiblility of each x, y, and z:\n\n\n\nVariable name\nDeclared in\nVisible in\n\n\n\n\nx\nGlobal scope\nAll scopes\n\n\ny\nScope 1 (inside main())\nAll local scopes\n\n\ni\nfor loop that starts the scope 2\nScopes 2, 3, and 4\n\n\nz\nScope 2 (inside for)\nScopes 2, 3, and 4\n\n\n\nNote that variables declared within for loop initialization belong to the scope of the body of the for loop, even though the initialization is before the curly braces.\n\n\n\n\n\n\nWarning\n\n\n\nUsing a variable outside its scope will lead to a compilation error.\n\n\n\n\n\nIn a single scope a name can only represent one variable\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x = 5;\n    string x = \"Hello world\"; // compilation error because x is declared twice\n}\nEven though we said that a name can only represent one variable, it’s ok if we declare a variable in a scope and then declare another variable with the same name in an inner scope. In that case, when we use this name we’ll be using the inner variable.\n#include&lt;iostream&gt;\nusing namespace std;\n\nint x = 5;\n\nint main() {\n    int x; // fine because we're in an inner scope of the global scope\n    cin &gt;&gt; x;\n    \n    if (x == 5) {\n        string x = \"Hello world\"; // fine because we're again in another inner scope\n        cout &lt;&lt; x &lt;&lt; endl;\n    }\n    else {\n        cout &lt;&lt; x &lt;&lt; endl;\n    }\n}",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Name Visibility"
    ]
  },
  {
    "objectID": "b0/cpp/name-visibility.html#scopes",
    "href": "b0/cpp/name-visibility.html#scopes",
    "title": "Name Visibility",
    "section": "",
    "text": "A scope is the region of a program where a name can be used and can be accessed directly by its name. We say the name is visible in that scope. Most scopes are the areas surrounded by curly brackets {}. The area outside any scope is called a global scope. Any other area is called a local scope.\n#include&lt;iostream&gt;\nusing namespace std;\n\n// global scope\nint x = 5;\n\nint main() {\n    // local scope 1\n    int y = 4\n    \n    for (int i = 0 ; i &lt; 5 ; i++) {\n        // local scope 2\n        int z = 20;\n        if (i % 2 == 0) {\n            // local scope 3\n            cout &lt;&lt; z + x &lt;&lt; ' ' &lt;&lt; z + y &lt;&lt; endl;\n        }\n        else {\n            // local scope 4\n            cout &lt;&lt; z - y &lt;&lt; ' ' &lt;&lt; z - x &lt;&lt; endl;\n        }\n    }\n}\nIn this example we have a global scope and 4 local scopes. Note that the scope 1 extend through the whole main function, the scope 2 is the region inside the for loop, and scopes 3 and 4 are the areas inside each of the if and else blocks repsectively.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Name Visibility"
    ]
  },
  {
    "objectID": "b0/cpp/name-visibility.html#where-is-a-variable-visible",
    "href": "b0/cpp/name-visibility.html#where-is-a-variable-visible",
    "title": "Name Visibility",
    "section": "",
    "text": "Globally initialized variables (also called global variables) are visible and can be used in all scopes after their intialization. Locally initialized variables (also called local variables) are visible only within the scope they are declared in. This includes the scopes nested within their scopes, i.e. inner scopes.\nLooking at the previouse example this is the visiblility of each x, y, and z:\n\n\n\nVariable name\nDeclared in\nVisible in\n\n\n\n\nx\nGlobal scope\nAll scopes\n\n\ny\nScope 1 (inside main())\nAll local scopes\n\n\ni\nfor loop that starts the scope 2\nScopes 2, 3, and 4\n\n\nz\nScope 2 (inside for)\nScopes 2, 3, and 4\n\n\n\nNote that variables declared within for loop initialization belong to the scope of the body of the for loop, even though the initialization is before the curly braces.\n\n\n\n\n\n\nWarning\n\n\n\nUsing a variable outside its scope will lead to a compilation error.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Name Visibility"
    ]
  },
  {
    "objectID": "b0/cpp/name-visibility.html#naming-within-a-scope",
    "href": "b0/cpp/name-visibility.html#naming-within-a-scope",
    "title": "Name Visibility",
    "section": "",
    "text": "In a single scope a name can only represent one variable\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x = 5;\n    string x = \"Hello world\"; // compilation error because x is declared twice\n}\nEven though we said that a name can only represent one variable, it’s ok if we declare a variable in a scope and then declare another variable with the same name in an inner scope. In that case, when we use this name we’ll be using the inner variable.\n#include&lt;iostream&gt;\nusing namespace std;\n\nint x = 5;\n\nint main() {\n    int x; // fine because we're in an inner scope of the global scope\n    cin &gt;&gt; x;\n    \n    if (x == 5) {\n        string x = \"Hello world\"; // fine because we're again in another inner scope\n        cout &lt;&lt; x &lt;&lt; endl;\n    }\n    else {\n        cout &lt;&lt; x &lt;&lt; endl;\n    }\n}",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Name Visibility"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html",
    "href": "b0/cpp/constants.html",
    "title": "Constants",
    "section": "",
    "text": "Sometimes, we want a value that never changes while the program is running. That’s what constants are for!\nConstants help prevent mistakes (like changing a number by accident) and make the code easier to understand.\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int age = 15;\n    age = 16; // we can change it\n\n    const double PI = 3.14159;\n    // PI = 3.14;  Error! cannot change a constant\n\n    cout &lt;&lt; \"PI is \" &lt;&lt; PI &lt;&lt; endl;\n    return 0;\n}\nOutput:\nPI is 3.14159\n\n\n\n\nTo protect important values from being changed by accident.\n\nTo make code more readable — PI is clearer than 3.14159.\n\nTo update easily — if PI ever changes (it won’t, but you get the point), you just change it in one place.\n\n\n\n\nYou make a constant by adding the keyword const before the type:\nconst int DAYS_IN_WEEK = 7;\nconst double GRAVITY = 9.81;\nconst char GRADE = 'A';\nConstants must always be given a value at the moment they are declared.\n\n\n\nLiteral constants are values that appear directly in the code, like:\nint x = 5;         // 5 is an integer literal\ndouble pi = 3.14;  // 3.14 is a double literal\nchar letter = 'A'; // 'A' is a character literal\nstring word = \"Hi\"; // \"Hi\" is a string literal\nThese are just raw values written in your code.\n\n\nYou can tell C++ what type a number literal should be using suffixes:\n\n\n\nLiteral\nType\nMeaning\n\n\n\n\n5\nint\ndefault integer\n\n\n5U\nunsigned int\nno negative values\n\n\n5L\nlong\nlong integer\n\n\n5LL\nlong long\nvery large integer\n\n\n3.14f\nfloat\nsingle-precision decimal\n\n\n3.14\ndouble\ndefault for decimals\n\n\n3.14L\nlong double\nhigh precision decimal\n\n\n\nExample:\nfloat a = 3.14f;\nlong long b = 10000000000LL;\nlong double c = 3.1415926535L;\nIf you omit the suffix, C++ will assume int for whole numbers and double for decimals.\n\n\n\n\nBefore const existed, people used #define to create constants:\n#define PI 3.14159\n#define GREETING \"Hello\"\nIt still works, but const is safer and preferred in modern C++.\n\n\n\n\n\n\nMethod\nExample\nCan change?\nWhen to use\n\n\n\n\nconst\nconst int x = 5;\nNo\nAlways for fixed values\n\n\n#define\n#define Z 15\nNo\nOld style, avoid in modern C++\n\n\n\n\n\n\n\nUse const for values that should never change.\n\nUse suffixes like LL or f to pick the right numeric type.\n\nAvoid #define for constants unless you are reading old code.\n\nWith constants, your code becomes safer, clearer, and easier to maintain.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Constants"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#example-regular-variable-vs-constant",
    "href": "b0/cpp/constants.html#example-regular-variable-vs-constant",
    "title": "Constants",
    "section": "",
    "text": "#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int age = 15;\n    age = 16; // we can change it\n\n    const double PI = 3.14159;\n    // PI = 3.14;  Error! cannot change a constant\n\n    cout &lt;&lt; \"PI is \" &lt;&lt; PI &lt;&lt; endl;\n    return 0;\n}\nOutput:\nPI is 3.14159",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Constants"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#why-use-constants",
    "href": "b0/cpp/constants.html#why-use-constants",
    "title": "Constants",
    "section": "",
    "text": "To protect important values from being changed by accident.\n\nTo make code more readable — PI is clearer than 3.14159.\n\nTo update easily — if PI ever changes (it won’t, but you get the point), you just change it in one place.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Constants"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#declaring-constants",
    "href": "b0/cpp/constants.html#declaring-constants",
    "title": "Constants",
    "section": "",
    "text": "You make a constant by adding the keyword const before the type:\nconst int DAYS_IN_WEEK = 7;\nconst double GRAVITY = 9.81;\nconst char GRADE = 'A';\nConstants must always be given a value at the moment they are declared.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Constants"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#literal-constants",
    "href": "b0/cpp/constants.html#literal-constants",
    "title": "Constants",
    "section": "",
    "text": "Literal constants are values that appear directly in the code, like:\nint x = 5;         // 5 is an integer literal\ndouble pi = 3.14;  // 3.14 is a double literal\nchar letter = 'A'; // 'A' is a character literal\nstring word = \"Hi\"; // \"Hi\" is a string literal\nThese are just raw values written in your code.\n\n\nYou can tell C++ what type a number literal should be using suffixes:\n\n\n\nLiteral\nType\nMeaning\n\n\n\n\n5\nint\ndefault integer\n\n\n5U\nunsigned int\nno negative values\n\n\n5L\nlong\nlong integer\n\n\n5LL\nlong long\nvery large integer\n\n\n3.14f\nfloat\nsingle-precision decimal\n\n\n3.14\ndouble\ndefault for decimals\n\n\n3.14L\nlong double\nhigh precision decimal\n\n\n\nExample:\nfloat a = 3.14f;\nlong long b = 10000000000LL;\nlong double c = 3.1415926535L;\nIf you omit the suffix, C++ will assume int for whole numbers and double for decimals.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Constants"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#constants-with-define-old-way",
    "href": "b0/cpp/constants.html#constants-with-define-old-way",
    "title": "Constants",
    "section": "",
    "text": "Before const existed, people used #define to create constants:\n#define PI 3.14159\n#define GREETING \"Hello\"\nIt still works, but const is safer and preferred in modern C++.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Constants"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#summary-table",
    "href": "b0/cpp/constants.html#summary-table",
    "title": "Constants",
    "section": "",
    "text": "Method\nExample\nCan change?\nWhen to use\n\n\n\n\nconst\nconst int x = 5;\nNo\nAlways for fixed values\n\n\n#define\n#define Z 15\nNo\nOld style, avoid in modern C++",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Constants"
    ]
  },
  {
    "objectID": "b0/cpp/constants.html#quick-recap",
    "href": "b0/cpp/constants.html#quick-recap",
    "title": "Constants",
    "section": "",
    "text": "Use const for values that should never change.\n\nUse suffixes like LL or f to pick the right numeric type.\n\nAvoid #define for constants unless you are reading old code.\n\nWith constants, your code becomes safer, clearer, and easier to maintain.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Constants"
    ]
  },
  {
    "objectID": "b0/cpp/while.html",
    "href": "b0/cpp/while.html",
    "title": "The while Loop",
    "section": "",
    "text": "The while loop is the simplest loop in C++. It repeatedly executes a statement or block as long as a condition is true.\n\n\nwhile (expression)\n    statement;\n\nexpression is evaluated before every iteration.\nIf it’s true, the loop executes the statement.\nIf it’s false, the loop ends, and the program continues afterward.\n\n\n\n\n// custom countdown using while\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n = 10;\n\n    while (n &gt; 0) {\n        cout &lt;&lt; n &lt;&lt; \", \";\n        --n;\n    }\n\n    cout &lt;&lt; \"liftoff!\\n\";\n}\nOutput:\n10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff!\n\n\n\n\nn starts at 10.\nThe condition n &gt; 0 is checked.\nIf true → print n, then decrease it by one.\nWhen n reaches 0 → condition is false → loop stops.\nProgram continues after the loop.\n\n\n\n\n\n\n\nImportant\n\n\n\nInfinite loop happens when the loop condition always stays true. For example, without --n, the loop would never end. Make sure that the condition eventually becomes false.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `while` Loop"
    ]
  },
  {
    "objectID": "b0/cpp/while.html#syntax",
    "href": "b0/cpp/while.html#syntax",
    "title": "The while Loop",
    "section": "",
    "text": "while (expression)\n    statement;\n\nexpression is evaluated before every iteration.\nIf it’s true, the loop executes the statement.\nIf it’s false, the loop ends, and the program continues afterward.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `while` Loop"
    ]
  },
  {
    "objectID": "b0/cpp/while.html#example-countdown",
    "href": "b0/cpp/while.html#example-countdown",
    "title": "The while Loop",
    "section": "",
    "text": "// custom countdown using while\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n = 10;\n\n    while (n &gt; 0) {\n        cout &lt;&lt; n &lt;&lt; \", \";\n        --n;\n    }\n\n    cout &lt;&lt; \"liftoff!\\n\";\n}\nOutput:\n10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff!",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `while` Loop"
    ]
  },
  {
    "objectID": "b0/cpp/while.html#how-it-works",
    "href": "b0/cpp/while.html#how-it-works",
    "title": "The while Loop",
    "section": "",
    "text": "n starts at 10.\nThe condition n &gt; 0 is checked.\nIf true → print n, then decrease it by one.\nWhen n reaches 0 → condition is false → loop stops.\nProgram continues after the loop.\n\n\n\n\n\n\n\nImportant\n\n\n\nInfinite loop happens when the loop condition always stays true. For example, without --n, the loop would never end. Make sure that the condition eventually becomes false.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `while` Loop"
    ]
  },
  {
    "objectID": "b0/cpp/statements.html",
    "href": "b0/cpp/statements.html",
    "title": "Statements and Control Flow",
    "section": "",
    "text": "A simple C++ statement is one of the individual instructions in a program — such as a variable declaration or an expression. Each simple statement ends with a semicolon (;) and is executed in the order it appears in the code.\nint x = 5;\nx = x + 2;\ncout &lt;&lt; x;\nIn the above example, each line is a simple statement that ends with a semicolon and runs sequentially from top to bottom.\n\n\nPrograms are not limited to a linear sequence of statements. In practice, a program might:\n\nRepeat certain parts of its code (loops).\nMake decisions to execute different code paths (conditionals).\n\nTo achieve this, C++ provides flow control statements - tools that tell the program what to do, when to do it, and under what conditions.\nExamples include:\n\nif / else (conditional branching)\nswitch (multi-way branching)\nwhile, for, and do-while (loops)\n\n\n\n\nA compound statement — a group of statements enclosed in curly braces {}. These grouped statements are treated as one single block.\nA compound statement looks like this:\n{\n    statement1;\n    statement2;\n    statement3;\n}\nEach substatement inside the block ends with its own semicolon, and the entire block acts as a single statement.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Statements and Control Flow"
    ]
  },
  {
    "objectID": "b0/cpp/statements.html#beyond-linear-execution",
    "href": "b0/cpp/statements.html#beyond-linear-execution",
    "title": "Statements and Control Flow",
    "section": "",
    "text": "Programs are not limited to a linear sequence of statements. In practice, a program might:\n\nRepeat certain parts of its code (loops).\nMake decisions to execute different code paths (conditionals).\n\nTo achieve this, C++ provides flow control statements - tools that tell the program what to do, when to do it, and under what conditions.\nExamples include:\n\nif / else (conditional branching)\nswitch (multi-way branching)\nwhile, for, and do-while (loops)",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Statements and Control Flow"
    ]
  },
  {
    "objectID": "b0/cpp/statements.html#compound-statements",
    "href": "b0/cpp/statements.html#compound-statements",
    "title": "Statements and Control Flow",
    "section": "",
    "text": "A compound statement — a group of statements enclosed in curly braces {}. These grouped statements are treated as one single block.\nA compound statement looks like this:\n{\n    statement1;\n    statement2;\n    statement3;\n}\nEach substatement inside the block ends with its own semicolon, and the entire block acts as a single statement.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Statements and Control Flow"
    ]
  },
  {
    "objectID": "b0/cpp/for.html",
    "href": "b0/cpp/for.html",
    "title": "The for Loop",
    "section": "",
    "text": "The for loop is designed for situations where the number of iterations is known. It allows initialization, condition, and increment/decrement all in one line.\n\n\nfor (initialization; condition; update)\n    statement;\n\n\n\n// countdown using a for loop\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    for (int n = 10; n &gt; 0; n--) {\n        cout &lt;&lt; n &lt;&lt; \", \";\n    }\n    cout &lt;&lt; \"liftoff!\\n\";\n}\nOutput:\n10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff!\n\n\n\n\nInitialization: runs once before the loop starts (e.g., int n = 10;)\nCondition: checked before every iteration (n &gt; 0)\nUpdate: runs after every iteration (n--)\nStatement: runs if condition is true (cout &lt;&lt; n &lt;&lt; \", \";)\n\n\n\n\nAll three parts are optional, but semicolons are required.\nfor (; n &lt; 10; )    // no init or update\nfor (; n &lt; 10; ++n) // update only\n\n\n\n\n\n\nCaution\n\n\n\nA missing condition creates an infinite loop.\n\n\n\n\n\nIterates automatically over each element in a range (like arrays or strings):\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string str {\"Hello!\"};\n    for (char c : str)\n        cout &lt;&lt; \"[\" &lt;&lt; c &lt;&lt; \"]\";\n    cout &lt;&lt; '\\n';\n}\nOutput:\n[H][e][l][l][o][!]\nYou can use auto to automatically detect the element type, the effect is the same.\nfor (auto c : str)\n    cout &lt;&lt; \"[\" &lt;&lt; c &lt;&lt; \"]\";",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `for` Loop"
    ]
  },
  {
    "objectID": "b0/cpp/for.html#syntax",
    "href": "b0/cpp/for.html#syntax",
    "title": "The for Loop",
    "section": "",
    "text": "for (initialization; condition; update)\n    statement;",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `for` Loop"
    ]
  },
  {
    "objectID": "b0/cpp/for.html#example-countdown",
    "href": "b0/cpp/for.html#example-countdown",
    "title": "The for Loop",
    "section": "",
    "text": "// countdown using a for loop\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    for (int n = 10; n &gt; 0; n--) {\n        cout &lt;&lt; n &lt;&lt; \", \";\n    }\n    cout &lt;&lt; \"liftoff!\\n\";\n}\nOutput:\n10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff!",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `for` Loop"
    ]
  },
  {
    "objectID": "b0/cpp/for.html#how-it-works",
    "href": "b0/cpp/for.html#how-it-works",
    "title": "The for Loop",
    "section": "",
    "text": "Initialization: runs once before the loop starts (e.g., int n = 10;)\nCondition: checked before every iteration (n &gt; 0)\nUpdate: runs after every iteration (n--)\nStatement: runs if condition is true (cout &lt;&lt; n &lt;&lt; \", \";)",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `for` Loop"
    ]
  },
  {
    "objectID": "b0/cpp/for.html#variations",
    "href": "b0/cpp/for.html#variations",
    "title": "The for Loop",
    "section": "",
    "text": "All three parts are optional, but semicolons are required.\nfor (; n &lt; 10; )    // no init or update\nfor (; n &lt; 10; ++n) // update only\n\n\n\n\n\n\nCaution\n\n\n\nA missing condition creates an infinite loop.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `for` Loop"
    ]
  },
  {
    "objectID": "b0/cpp/for.html#range-based-for-loop",
    "href": "b0/cpp/for.html#range-based-for-loop",
    "title": "The for Loop",
    "section": "",
    "text": "Iterates automatically over each element in a range (like arrays or strings):\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string str {\"Hello!\"};\n    for (char c : str)\n        cout &lt;&lt; \"[\" &lt;&lt; c &lt;&lt; \"]\";\n    cout &lt;&lt; '\\n';\n}\nOutput:\n[H][e][l][l][o][!]\nYou can use auto to automatically detect the element type, the effect is the same.\nfor (auto c : str)\n    cout &lt;&lt; \"[\" &lt;&lt; c &lt;&lt; \"]\";",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `for` Loop"
    ]
  },
  {
    "objectID": "b0/cpp/input-output.html",
    "href": "b0/cpp/input-output.html",
    "title": "Input/Output",
    "section": "",
    "text": "When a user runs a program, they are presented with a screen called the terminal. Through this screen the program may display information or accept information from the user. We call displaying information output and accepting information from the user input\n\n\nInput and output are performed through streams. A stream is a datatype which can take in data or give out data (or both). The two main streams used in C++ are cin for input and cout for output.\nIn order to interact with streams, we have two operators &lt;&lt; and &gt;&gt;, the usage is as follows:\nstream &lt;&lt; variable; // this feeds the value of the variable into the stream\nstream &gt;&gt; variable; // this takes data from the stream and stores it in variable\nIn the first case, variable is unaffected, but in the second case the variable will have a new value.\n\n\n\n\n\n\nNote\n\n\n\n“Stream” in this context is a type, whereas cin and cout are variables of that type.\n\n\nTo be able to work with streams, and use cin and cout, we must add #include &lt;iostream&gt; to the beggining of our program.\n\n\nSuppose you wrote the following program:\nint x = 5;\n// add 1 if x is divisible by 3 and add 2 otherwise\nint y = x + (x % 3 == 0 ? 1 : 2);\nThe variable y is stored in memory. The user has no way of knowing its value, if you want to share this variable with the user you must output it to the terminal.\ncout &lt;&lt; y;\nThis will display the value of y on the terminal. If we wish to print regular text we use \"...\".\ncout &lt;&lt; \"The value of y is\";\ncout &lt;&lt; y;\nThe result is…\nThe value of y is7\nThis doesn’t look quite right. The reason is because C++ does not understand what looks right and what doesn’t. C++ performs the operations exactly as we describe them. Since we never specified that there needs to be a space after “is”, the program didn’t add one. Instead, we should write:\ncout &lt;&lt; \"The value of y is \";\ncout &lt;&lt; y;\nWe can print multiple expressions in the same line:\ncout &lt;&lt; \"The value of y is \" &lt;&lt; y;\nWe can also print a new-line character '\\n' to jump to a new line:\ncout &lt;&lt; \"Hello\" &lt;&lt; '\\n' &lt;&lt; \"World\";\nWe get:\nHello\nWorld\n\n\n\nWe know how to write a program which defines, interacts with and prints data. The problem is that the program does the exact same thing each time it’s run. We might want to write a program which allows the user to choose the values on each run. For that we will use cin.\nint x;\ncin &gt;&gt; x;\ncout &lt;&lt; \"You entered: \" &lt;&lt; x;\nHere the program will wait on the instruction cin &gt;&gt; x until the user writes a value in the terminal and hits enter. After thats done, the value will be stored in x.\nExample input:\n5\nExpected output:\nYou entered: 5\n\n\n\n\n\n\nNote\n\n\n\nNotice that the operators for cin and cout are different: &gt;&gt; for cin, and &lt;&lt; for cout.\n\n\n\n\n\nWhen we use cin the stream reads until it finds a white space or we reach the end of the input file. Sometimes, we might want to read a full line even if it contains spaces. For that we use getline.\nstring s;\ngetline(cin, s);\n\ncout &lt;&lt; \"The line is: \" &lt;&lt; s;\nTo use getline you must add two arguments, the stream that it should read from, and the variable it should store the result in.\n\n\n\n\n\n\nCaution\n\n\n\nIt is not recommended to use cin and getline in the same program.\n\n\n\n\n\n\n\n\nExample problem\n\n\n\n\n\nWrite a program which reads 2 integers and prints first the smaller one and then the larger one, on separate lines.\n\n\n\n\n\nSolution to the example problem\n\nThe steps to solve this problem are as follows:\n\nDeclare two integer variables in order to store the input.\nUse cin to read the input.\nDeclare two additional variables to store the answer.\nUse ternary operator to determine the smaller and larger values.\nUse cout to print the answer.\n\nint a, b;\ncin &gt;&gt; a &gt;&gt; b; // we can read multiple variables in the same line\n\nint small = (a &lt; b ? a : b);\nint large = (a &gt; b ? a : b);\n\ncout &lt;&lt; small &lt;&lt; '\\n' &lt;&lt; large;\n\n\n\n\n\nWhen you use cout the data you print does not necessarily get printed right away. Sometimes it is delayed (stored in a buffer) to speed up the execution. By default, whenever you use cin the buffer gets flushed, which can sometimes be slow.\nAdditionally, if the buffer already has lots of data it might randomly decide to flush the output during execution. We can untie cin from cout and tell cout to only flush once at the end of execution by adding the two following lines:\ncin.tie(0); // tie the cin stream to stream (0) i.e no stream\ncin.sync_with_stdio(0);\n\n\n\n\n\n\nImportant\n\n\n\nIn the competitions, programs are tested automatically. The input is not entered by a user, instead it is redirected from a file. Such inputs can be very large. Whenever a problem has a lot of input (hundreds of thousands of numbers), you want to have the previous lines at the beginning of your code, otherwise it might run to slow.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Input/Output"
    ]
  },
  {
    "objectID": "b0/cpp/input-output.html#streams",
    "href": "b0/cpp/input-output.html#streams",
    "title": "Input/Output",
    "section": "",
    "text": "Input and output are performed through streams. A stream is a datatype which can take in data or give out data (or both). The two main streams used in C++ are cin for input and cout for output.\nIn order to interact with streams, we have two operators &lt;&lt; and &gt;&gt;, the usage is as follows:\nstream &lt;&lt; variable; // this feeds the value of the variable into the stream\nstream &gt;&gt; variable; // this takes data from the stream and stores it in variable\nIn the first case, variable is unaffected, but in the second case the variable will have a new value.\n\n\n\n\n\n\nNote\n\n\n\n“Stream” in this context is a type, whereas cin and cout are variables of that type.\n\n\nTo be able to work with streams, and use cin and cout, we must add #include &lt;iostream&gt; to the beggining of our program.\n\n\nSuppose you wrote the following program:\nint x = 5;\n// add 1 if x is divisible by 3 and add 2 otherwise\nint y = x + (x % 3 == 0 ? 1 : 2);\nThe variable y is stored in memory. The user has no way of knowing its value, if you want to share this variable with the user you must output it to the terminal.\ncout &lt;&lt; y;\nThis will display the value of y on the terminal. If we wish to print regular text we use \"...\".\ncout &lt;&lt; \"The value of y is\";\ncout &lt;&lt; y;\nThe result is…\nThe value of y is7\nThis doesn’t look quite right. The reason is because C++ does not understand what looks right and what doesn’t. C++ performs the operations exactly as we describe them. Since we never specified that there needs to be a space after “is”, the program didn’t add one. Instead, we should write:\ncout &lt;&lt; \"The value of y is \";\ncout &lt;&lt; y;\nWe can print multiple expressions in the same line:\ncout &lt;&lt; \"The value of y is \" &lt;&lt; y;\nWe can also print a new-line character '\\n' to jump to a new line:\ncout &lt;&lt; \"Hello\" &lt;&lt; '\\n' &lt;&lt; \"World\";\nWe get:\nHello\nWorld\n\n\n\nWe know how to write a program which defines, interacts with and prints data. The problem is that the program does the exact same thing each time it’s run. We might want to write a program which allows the user to choose the values on each run. For that we will use cin.\nint x;\ncin &gt;&gt; x;\ncout &lt;&lt; \"You entered: \" &lt;&lt; x;\nHere the program will wait on the instruction cin &gt;&gt; x until the user writes a value in the terminal and hits enter. After thats done, the value will be stored in x.\nExample input:\n5\nExpected output:\nYou entered: 5\n\n\n\n\n\n\nNote\n\n\n\nNotice that the operators for cin and cout are different: &gt;&gt; for cin, and &lt;&lt; for cout.\n\n\n\n\n\nWhen we use cin the stream reads until it finds a white space or we reach the end of the input file. Sometimes, we might want to read a full line even if it contains spaces. For that we use getline.\nstring s;\ngetline(cin, s);\n\ncout &lt;&lt; \"The line is: \" &lt;&lt; s;\nTo use getline you must add two arguments, the stream that it should read from, and the variable it should store the result in.\n\n\n\n\n\n\nCaution\n\n\n\nIt is not recommended to use cin and getline in the same program.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Input/Output"
    ]
  },
  {
    "objectID": "b0/cpp/input-output.html#example-problem",
    "href": "b0/cpp/input-output.html#example-problem",
    "title": "Input/Output",
    "section": "",
    "text": "Example problem\n\n\n\n\n\nWrite a program which reads 2 integers and prints first the smaller one and then the larger one, on separate lines.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Input/Output"
    ]
  },
  {
    "objectID": "b0/cpp/input-output.html#fast-io",
    "href": "b0/cpp/input-output.html#fast-io",
    "title": "Input/Output",
    "section": "",
    "text": "When you use cout the data you print does not necessarily get printed right away. Sometimes it is delayed (stored in a buffer) to speed up the execution. By default, whenever you use cin the buffer gets flushed, which can sometimes be slow.\nAdditionally, if the buffer already has lots of data it might randomly decide to flush the output during execution. We can untie cin from cout and tell cout to only flush once at the end of execution by adding the two following lines:\ncin.tie(0); // tie the cin stream to stream (0) i.e no stream\ncin.sync_with_stdio(0);\n\n\n\n\n\n\nImportant\n\n\n\nIn the competitions, programs are tested automatically. The input is not entered by a user, instead it is redirected from a file. Such inputs can be very large. Whenever a problem has a lot of input (hundreds of thousands of numbers), you want to have the previous lines at the beginning of your code, otherwise it might run to slow.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Input/Output"
    ]
  },
  {
    "objectID": "b0/cpp/do.html",
    "href": "b0/cpp/do.html",
    "title": "🔁 The do-while Loop",
    "section": "",
    "text": "The do-while loop is similar to a while loop, but it executes the block at least once, since the condition is checked after execution.\n\n\n\ndo\n    statement;\nwhile (condition);\n\nHere’s a simpler and easier-to-grasp version of the Echo Machine example — using numbers instead of strings, so beginners can focus on understanding how the loop repeats and stops.\n\n\n\n\n// number repeater using do-while\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int number;\n    do {\n        cout &lt;&lt; \"Enter a number (0 to stop): \";\n        cin &gt;&gt; number;\n        cout &lt;&lt; \"You entered: \" &lt;&lt; number &lt;&lt; endl;\n    } while (number != 0);\n\n    cout &lt;&lt; \"Loop ended because you entered 0.\" &lt;&lt; endl;\n}\n\n\n\nEnter a number (0 to stop): 5\nYou entered: 5\nEnter a number (0 to stop): 8\nYou entered: 8\nEnter a number (0 to stop): 0\nYou entered: 0\nLoop ended because you entered 0.\n\n\n\n\n\nThe program asks for a number and prints it.\nAfter printing, it checks the condition:\n\nIf the number is not 0, the loop repeats.\nIf the number is 0, the loop stops.\n\nThe message \"Loop ended because you entered 0.\" appears after the loop ends.\n\nKey idea: The do-while loop always runs at least once, even if the user enters 0 immediately — because the condition is checked after the first execution."
  },
  {
    "objectID": "b0/cpp/do.html#syntax",
    "href": "b0/cpp/do.html#syntax",
    "title": "🔁 The do-while Loop",
    "section": "",
    "text": "do\n    statement;\nwhile (condition);\n\nHere’s a simpler and easier-to-grasp version of the Echo Machine example — using numbers instead of strings, so beginners can focus on understanding how the loop repeats and stops."
  },
  {
    "objectID": "b0/cpp/do.html#example-simple-number-repeater",
    "href": "b0/cpp/do.html#example-simple-number-repeater",
    "title": "🔁 The do-while Loop",
    "section": "",
    "text": "// number repeater using do-while\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int number;\n    do {\n        cout &lt;&lt; \"Enter a number (0 to stop): \";\n        cin &gt;&gt; number;\n        cout &lt;&lt; \"You entered: \" &lt;&lt; number &lt;&lt; endl;\n    } while (number != 0);\n\n    cout &lt;&lt; \"Loop ended because you entered 0.\" &lt;&lt; endl;\n}\n\n\n\nEnter a number (0 to stop): 5\nYou entered: 5\nEnter a number (0 to stop): 8\nYou entered: 8\nEnter a number (0 to stop): 0\nYou entered: 0\nLoop ended because you entered 0.\n\n\n\n\n\nThe program asks for a number and prints it.\nAfter printing, it checks the condition:\n\nIf the number is not 0, the loop repeats.\nIf the number is 0, the loop stops.\n\nThe message \"Loop ended because you entered 0.\" appears after the loop ends.\n\nKey idea: The do-while loop always runs at least once, even if the user enters 0 immediately — because the condition is checked after the first execution."
  },
  {
    "objectID": "b0/cpp/if.html",
    "href": "b0/cpp/if.html",
    "title": "The if Statement",
    "section": "",
    "text": "The if statement is used to make decisions in a program — it tells the program to execute certain code only if a specific condition is true.\n\n\nif (condition)\n    statement;\n\ncondition is an expression that is evaluated to either true or false.\nIf the condition is true, the statement is executed.\nIf the condition is false, the statement is ignored, and the program continues after the if block.\n\n\n\n\nif (x == 100)\n    cout &lt;&lt; \"x is 100\";\nIf x is exactly 100, the message \"x is 100\" is printed. Otherwise, nothing happens and the program simply moves on.\n\n\n\nIf you want to execute more than one statement when the condition is true, group them inside curly braces {} to form a block:\nif (x == 100)\n{\n    cout &lt;&lt; \"x is \";\n    cout &lt;&lt; x;\n}\nThis block is treated as one single statement. Indentation and line breaks don’t affect how the program runs, so this is equivalent to:\nif (x == 100) { cout &lt;&lt; \"x is \"; cout &lt;&lt; x; }\n\n\n\nYou can add an else clause to specify what happens when the condition is false:\nif (x == 100)\n    cout &lt;&lt; \"x is 100\";\nelse\n    cout &lt;&lt; \"x is not 100\";\nIf the condition is true, the first statement runs. If it’s false, the statement after else runs instead.\n\n\n\nYou can chain multiple conditions using else if to handle multiple cases:\nif (x &gt; 0)\n    cout &lt;&lt; \"x is positive\";\nelse if (x &lt; 0)\n    cout &lt;&lt; \"x is negative\";\nelse\n    cout &lt;&lt; \"x is 0\";\nThis structure allows your program to decide among several alternatives:\n\nIf x is greater than zero → prints “x is positive”\nIf x is less than zero → prints “x is negative”\nOtherwise → prints “x is 0”",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `if` Statement"
    ]
  },
  {
    "objectID": "b0/cpp/if.html#basic-syntax",
    "href": "b0/cpp/if.html#basic-syntax",
    "title": "The if Statement",
    "section": "",
    "text": "if (condition)\n    statement;\n\ncondition is an expression that is evaluated to either true or false.\nIf the condition is true, the statement is executed.\nIf the condition is false, the statement is ignored, and the program continues after the if block.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `if` Statement"
    ]
  },
  {
    "objectID": "b0/cpp/if.html#example",
    "href": "b0/cpp/if.html#example",
    "title": "The if Statement",
    "section": "",
    "text": "if (x == 100)\n    cout &lt;&lt; \"x is 100\";\nIf x is exactly 100, the message \"x is 100\" is printed. Otherwise, nothing happens and the program simply moves on.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `if` Statement"
    ]
  },
  {
    "objectID": "b0/cpp/if.html#multiple-statements-compound-block",
    "href": "b0/cpp/if.html#multiple-statements-compound-block",
    "title": "The if Statement",
    "section": "",
    "text": "If you want to execute more than one statement when the condition is true, group them inside curly braces {} to form a block:\nif (x == 100)\n{\n    cout &lt;&lt; \"x is \";\n    cout &lt;&lt; x;\n}\nThis block is treated as one single statement. Indentation and line breaks don’t affect how the program runs, so this is equivalent to:\nif (x == 100) { cout &lt;&lt; \"x is \"; cout &lt;&lt; x; }",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `if` Statement"
    ]
  },
  {
    "objectID": "b0/cpp/if.html#using-else",
    "href": "b0/cpp/if.html#using-else",
    "title": "The if Statement",
    "section": "",
    "text": "You can add an else clause to specify what happens when the condition is false:\nif (x == 100)\n    cout &lt;&lt; \"x is 100\";\nelse\n    cout &lt;&lt; \"x is not 100\";\nIf the condition is true, the first statement runs. If it’s false, the statement after else runs instead.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `if` Statement"
    ]
  },
  {
    "objectID": "b0/cpp/if.html#else-if-chains",
    "href": "b0/cpp/if.html#else-if-chains",
    "title": "The if Statement",
    "section": "",
    "text": "You can chain multiple conditions using else if to handle multiple cases:\nif (x &gt; 0)\n    cout &lt;&lt; \"x is positive\";\nelse if (x &lt; 0)\n    cout &lt;&lt; \"x is negative\";\nelse\n    cout &lt;&lt; \"x is 0\";\nThis structure allows your program to decide among several alternatives:\n\nIf x is greater than zero → prints “x is positive”\nIf x is less than zero → prints “x is negative”\nOtherwise → prints “x is 0”",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "The `if` Statement"
    ]
  },
  {
    "objectID": "b0/cpp/switch.html",
    "href": "b0/cpp/switch.html",
    "title": "The switch Statement",
    "section": "",
    "text": "The switch statement tests a single expression against multiple constant values. It is similar to if-else chains, but cleaner when handling many fixed cases.\n\n\n\nswitch (expression) {\n    case constant1:\n        // statements\n        break;\n    case constant2:\n        // statements\n        break;\n    default:\n        // statements\n}\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x = 2;\n    switch (x) {\n        case 1:\n            cout &lt;&lt; \"x is 1\";\n            break;\n        case 2:\n            cout &lt;&lt; \"x is 2\";\n            break;\n        default:\n            cout &lt;&lt; \"value of x unknown\";\n    }\n}\nOutput:\nx is 2\n\n\n\n\n\nThe switch evaluates expression.\nIt compares it with each case constant.\nWhen a match is found, it executes statements until a break is reached.\nIf no match is found, the default case runs (if it exists).\n\n\n\n\n\nIf break is omitted, execution continues into the next case:\nswitch (x) {\n    case 1:\n    case 2:\n    case 3:\n        cout &lt;&lt; \"x is 1, 2 or 3\";\n        break;\n    default:\n        cout &lt;&lt; \"x is not 1, 2 nor 3\";\n}\n\n\n\n\n\nCase labels must be constant expressions (no variables).\nswitch is ideal for comparing a single value to multiple fixed options.\nFor non-constant comparisons (like ranges), use if / else if."
  },
  {
    "objectID": "b0/cpp/switch.html#syntax",
    "href": "b0/cpp/switch.html#syntax",
    "title": "The switch Statement",
    "section": "",
    "text": "switch (expression) {\n    case constant1:\n        // statements\n        break;\n    case constant2:\n        // statements\n        break;\n    default:\n        // statements\n}"
  },
  {
    "objectID": "b0/cpp/switch.html#example",
    "href": "b0/cpp/switch.html#example",
    "title": "The switch Statement",
    "section": "",
    "text": "#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x = 2;\n    switch (x) {\n        case 1:\n            cout &lt;&lt; \"x is 1\";\n            break;\n        case 2:\n            cout &lt;&lt; \"x is 2\";\n            break;\n        default:\n            cout &lt;&lt; \"value of x unknown\";\n    }\n}\nOutput:\nx is 2"
  },
  {
    "objectID": "b0/cpp/switch.html#how-it-works",
    "href": "b0/cpp/switch.html#how-it-works",
    "title": "The switch Statement",
    "section": "",
    "text": "The switch evaluates expression.\nIt compares it with each case constant.\nWhen a match is found, it executes statements until a break is reached.\nIf no match is found, the default case runs (if it exists)."
  },
  {
    "objectID": "b0/cpp/switch.html#fallthrough-behavior",
    "href": "b0/cpp/switch.html#fallthrough-behavior",
    "title": "The switch Statement",
    "section": "",
    "text": "If break is omitted, execution continues into the next case:\nswitch (x) {\n    case 1:\n    case 2:\n    case 3:\n        cout &lt;&lt; \"x is 1, 2 or 3\";\n        break;\n    default:\n        cout &lt;&lt; \"x is not 1, 2 nor 3\";\n}"
  },
  {
    "objectID": "b0/cpp/switch.html#notes",
    "href": "b0/cpp/switch.html#notes",
    "title": "The switch Statement",
    "section": "",
    "text": "Case labels must be constant expressions (no variables).\nswitch is ideal for comparing a single value to multiple fixed options.\nFor non-constant comparisons (like ranges), use if / else if."
  },
  {
    "objectID": "b0/cpp/structure-of-a-program.html",
    "href": "b0/cpp/structure-of-a-program.html",
    "title": "Structure of a Program",
    "section": "",
    "text": "Let’s look at what every C++ program is made of.\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Your first program!\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\";\n    return 0;\n}\n\n\n\nPreprocessor commands\n\nStart with #, like #include &lt;iostream&gt;.\nThey tell the computer to include extra tools before running the program.\n\nNamespaces\n\nWe often write using namespace std;.\nYou don’t need to understand namespaces deeply now, just always add this line.\n\nThe main() function\n\nThis is where your program starts running.\nThe computer executes commands from top to bottom inside { ... }.\n\nCurly braces { }\n\nThey group instructions together.\nYou will see them in functions, loops, and if-statements.\n\nSemicolons ;\n\nEvery instruction (line) ends with a semicolon.\nForgetting it will cause an error.\n\nReturn statement\n\nreturn 0; ends the program and tells the computer everything went fine.\n\n\n\n\n\n\n#include &lt;iostream&gt; tells the computer we want to use input/output commands.\n\nusing namespace std; lets us write cout instead of std::cout (shorter and easier).\n\nint main() every program starts here.\n\n{ ... } everything inside the curly braces is part of the program.\n\ncout &lt;&lt; \"Hello, world!\"; prints text to the screen.\n\nreturn 0; ends the program.\n\nWhen you run this, you will see:\nHello, world!\nThat’s your first program!\n\n\n\nComments are notes for humans, not computers. The computer will ignore these lines, and they only serve to remind you, as a programmer, of certain functionalities.\n// This is a single-line comment\n\n/*\nThis is a\nmulti-line comment\n*/\nYou will often write comments to remind yourself what something does.\n\n\n\nAlways indent the code inside {} with a tab or 4 spaces. It makes programs easier to read:\nint main() {\n    cout &lt;&lt; \"Good style matters!\";\n}\nBad style :\nint main(){\ncout&lt;&lt;\"Hard to read\";\n}",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Structure of a Program"
    ]
  },
  {
    "objectID": "b0/cpp/structure-of-a-program.html#building-blocks",
    "href": "b0/cpp/structure-of-a-program.html#building-blocks",
    "title": "Structure of a Program",
    "section": "",
    "text": "Preprocessor commands\n\nStart with #, like #include &lt;iostream&gt;.\nThey tell the computer to include extra tools before running the program.\n\nNamespaces\n\nWe often write using namespace std;.\nYou don’t need to understand namespaces deeply now, just always add this line.\n\nThe main() function\n\nThis is where your program starts running.\nThe computer executes commands from top to bottom inside { ... }.\n\nCurly braces { }\n\nThey group instructions together.\nYou will see them in functions, loops, and if-statements.\n\nSemicolons ;\n\nEvery instruction (line) ends with a semicolon.\nForgetting it will cause an error.\n\nReturn statement\n\nreturn 0; ends the program and tells the computer everything went fine.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Structure of a Program"
    ]
  },
  {
    "objectID": "b0/cpp/structure-of-a-program.html#what-happens-here",
    "href": "b0/cpp/structure-of-a-program.html#what-happens-here",
    "title": "Structure of a Program",
    "section": "",
    "text": "#include &lt;iostream&gt; tells the computer we want to use input/output commands.\n\nusing namespace std; lets us write cout instead of std::cout (shorter and easier).\n\nint main() every program starts here.\n\n{ ... } everything inside the curly braces is part of the program.\n\ncout &lt;&lt; \"Hello, world!\"; prints text to the screen.\n\nreturn 0; ends the program.\n\nWhen you run this, you will see:\nHello, world!\nThat’s your first program!",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Structure of a Program"
    ]
  },
  {
    "objectID": "b0/cpp/structure-of-a-program.html#comments",
    "href": "b0/cpp/structure-of-a-program.html#comments",
    "title": "Structure of a Program",
    "section": "",
    "text": "Comments are notes for humans, not computers. The computer will ignore these lines, and they only serve to remind you, as a programmer, of certain functionalities.\n// This is a single-line comment\n\n/*\nThis is a\nmulti-line comment\n*/\nYou will often write comments to remind yourself what something does.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Structure of a Program"
    ]
  },
  {
    "objectID": "b0/cpp/structure-of-a-program.html#indentation-and-readability",
    "href": "b0/cpp/structure-of-a-program.html#indentation-and-readability",
    "title": "Structure of a Program",
    "section": "",
    "text": "Always indent the code inside {} with a tab or 4 spaces. It makes programs easier to read:\nint main() {\n    cout &lt;&lt; \"Good style matters!\";\n}\nBad style :\nint main(){\ncout&lt;&lt;\"Hard to read\";\n}",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Structure of a Program"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html",
    "href": "b0/cpp/hello-world.html",
    "title": "Hello World!",
    "section": "",
    "text": "Let’s start by running your first C++ program.\nDo not worry about understanding the code yet. The goal is just to get things running.\nThe first thing to do is install an IDE. An IDE is a type of program you use to write code. There are many different IDEs available. We will show you how to work with one of them, called Code::Blocks, but feel free to experiment and find the one that suits you best.\n\n\n\n\n\nGo to the Code::Blocks downloads page.\nDownload the installer named codeblocks-25.03mingw-setup.exe (possibly there is a newer version, so instead of 25.03 there will be another number).\n\nThis version includes the MinGW compiler, so you do not need to install a compiler separately.\n\nRun the installer and keep the default options.\n\n\n\n\nCode::Blocks for macOS is older and does not include a compiler. It still works for simple projects, but you must install the compiler first.\n\nInstall Apple Command Line Tools (this provides clang):\n\nOpen Terminal and run: xcode-select --install\n\nDownload CodeBlocks-25.03_macOS-11.7_x64-wx3.2.6.dmg from Code::Blocks downloads page and install it (possibly there is a newer version, so instead of 25.03 there will be another number).\nIf Code::Blocks cannot find the compiler on first run, go to Settings -&gt; Compiler and select Clang if available.\n\n\n\n\n\n\n\nTip\n\n\n\nIf Code::Blocks feels rough (especially on macOS), you can use CLion or VS Code, or any other IDE. See the end of this chapter for some details.\n\n\n\n\n\n\n\nOpen Code::Blocks.\nGo to File -&gt; New -&gt; Project -&gt; Console application.\nChoose C++, click Next.\nEnter a project title, for example HelloWorld.\nPick a folder for the project and click Finish.\n\nCode::Blocks creates a project with a file named main.cpp inside.\n\n\n\nOpen main.cpp and replace everything with:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\";\n    return 0;\n}\n\n\n\n\nClick Build and run (green triangle) or press F9.\nYou should see:\n\nHello, World!\nGreat, you just ran your first C++ program!\n\n\n\nWhen you click Build, Code::Blocks calls a compiler (MinGW on Windows, Clang on macOS). The compiler translates your code into a binary (an executable file). On Windows the file usually ends with .exe. This is the file your computer can run directly.\nYou will learn more about compilers, linkers, and build settings later. For now, this is enough.\n\n\n\nThere are many IDEs and editors that work for C++. We also recommend:\n\nCLion\nVS Code\n\nThese might take a little more work to set up, but they are also more powerful! On Windows and macOS, you will need to install a compiler. Linux already includes the GCC compiler. If you are using VS Code, you will also need to install a C++ extension.\nThere are also some online IDEs, which are simple to start with but not a good choice in the long term.\nYou can use any of these later. For now, Code::Blocks is a simple starting point.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Hello World!"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html#step-1-install-codeblocks",
    "href": "b0/cpp/hello-world.html#step-1-install-codeblocks",
    "title": "Hello World!",
    "section": "",
    "text": "Go to the Code::Blocks downloads page.\nDownload the installer named codeblocks-25.03mingw-setup.exe (possibly there is a newer version, so instead of 25.03 there will be another number).\n\nThis version includes the MinGW compiler, so you do not need to install a compiler separately.\n\nRun the installer and keep the default options.\n\n\n\n\nCode::Blocks for macOS is older and does not include a compiler. It still works for simple projects, but you must install the compiler first.\n\nInstall Apple Command Line Tools (this provides clang):\n\nOpen Terminal and run: xcode-select --install\n\nDownload CodeBlocks-25.03_macOS-11.7_x64-wx3.2.6.dmg from Code::Blocks downloads page and install it (possibly there is a newer version, so instead of 25.03 there will be another number).\nIf Code::Blocks cannot find the compiler on first run, go to Settings -&gt; Compiler and select Clang if available.\n\n\n\n\n\n\n\nTip\n\n\n\nIf Code::Blocks feels rough (especially on macOS), you can use CLion or VS Code, or any other IDE. See the end of this chapter for some details.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Hello World!"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html#step-2-create-a-new-project",
    "href": "b0/cpp/hello-world.html#step-2-create-a-new-project",
    "title": "Hello World!",
    "section": "",
    "text": "Open Code::Blocks.\nGo to File -&gt; New -&gt; Project -&gt; Console application.\nChoose C++, click Next.\nEnter a project title, for example HelloWorld.\nPick a folder for the project and click Finish.\n\nCode::Blocks creates a project with a file named main.cpp inside.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Hello World!"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html#step-3-write-your-first-program",
    "href": "b0/cpp/hello-world.html#step-3-write-your-first-program",
    "title": "Hello World!",
    "section": "",
    "text": "Open main.cpp and replace everything with:\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\";\n    return 0;\n}",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Hello World!"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html#step-4-build-and-run",
    "href": "b0/cpp/hello-world.html#step-4-build-and-run",
    "title": "Hello World!",
    "section": "",
    "text": "Click Build and run (green triangle) or press F9.\nYou should see:\n\nHello, World!\nGreat, you just ran your first C++ program!",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Hello World!"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html#what-actually-happened-short-version",
    "href": "b0/cpp/hello-world.html#what-actually-happened-short-version",
    "title": "Hello World!",
    "section": "",
    "text": "When you click Build, Code::Blocks calls a compiler (MinGW on Windows, Clang on macOS). The compiler translates your code into a binary (an executable file). On Windows the file usually ends with .exe. This is the file your computer can run directly.\nYou will learn more about compilers, linkers, and build settings later. For now, this is enough.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Hello World!"
    ]
  },
  {
    "objectID": "b0/cpp/hello-world.html#other-ide-options",
    "href": "b0/cpp/hello-world.html#other-ide-options",
    "title": "Hello World!",
    "section": "",
    "text": "There are many IDEs and editors that work for C++. We also recommend:\n\nCLion\nVS Code\n\nThese might take a little more work to set up, but they are also more powerful! On Windows and macOS, you will need to install a compiler. Linux already includes the GCC compiler. If you are using VS Code, you will also need to install a C++ extension.\nThere are also some online IDEs, which are simple to start with but not a good choice in the long term.\nYou can use any of these later. For now, Code::Blocks is a simple starting point.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Hello World!"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html",
    "href": "b0/cpp/arrays.html",
    "title": "Arrays",
    "section": "",
    "text": "When a program needs lots of variables, declaring each one individually can be time-consuming and makes the code messy. To solve this problem, we can use arrays, which lets us group related data together.\n\n\nAn array is a series of variables of the same type and fixed size that are stored sequentially and share a common name. Variables in an array are called elements.\nTo differentiate between the elements in the array, each element is assigned a number (also called index). For an array of n elements, the elements are indexed sequentially from 0 to n - 1.\n\n\n\nTo declare an array the following syntax is used:\ntype name[size];\nWhere:\n\ntype: The type of all elements in the array.\nname: The name which will be used to address the array.\nsize: The number of elements in the array.\n\nFor example:\nint a[4];\nThis defines an array named a[] with size 4. The size of the array can’t change after the initialization.\nThe size of an array doesn’t have to be an explicit integer, it can be an expression which let us choose the size of the array based on the current state of the programm.\nint n ;\ncin &gt;&gt; n;\nint a[n + 1]; // makes an array of size n + 1\n\n\n\nIf an array is defined locally we know that all elements in a[] have undetermined values. To give an array initial values, we can do the following:\nint a[4] = {2 , 4 , 5 , 0};\nThis will make an array that looks like as in the picture, where the cells are the elements of the array and the numbers below are the indices:\n\nTo decalre an array locally, and let all of its elements be 0, we can write:\nint a[2000] = {};\nThis will make 2000 integers each with inital value equal to 0.\n\n\n\nTo call an element in the array the following syntax is used:\nname[index];\nWhere:\n\nname: The name of the array.\nindex: The index of the element that’s called.\n\nThat elements in an array act like regular variabes. The following code shows an example for this.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int a[5] = {1, 2, 3, 4, 5}; // value 1 is assigned to a[0]\n    int x = a[0];               // x will be equal to 1\n    a[0]++;                     // a[0] will become 2\n    cout &lt;&lt; x &lt;&lt; endl;          // printing 1\n    cout &lt;&lt; a[0] &lt;&lt; endl;       // printing 2\n}\n\n\n\n\n\nWe can make a loop that moves through the whole array by looping over its indices (0 to array_size - 1). Let’s say we want to find the sum of an array.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n;\n    cin &gt;&gt; n; // read the size of the array\n    \n    int a[n]; // make an array of size n\n    for(int i = 0; i &lt; n; i++) { // loop through all the indices, from 0 to n - 1\n        cin &gt;&gt; a[i]; // for each index i, read the value of a[i] from the input\n    }\n\n    int sum = 0;\n    for (int i = 0 ; i &lt; n ; i++) {\n        sum += a[i]; // for each index i, add the value a[i] to sum\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n}\n\n\n\n\nMultidimensional arrays can be described as arrays-of-arrays, that is, an array in which each element in the array is an array as well. We call each level in the array a dimension. Let’s look at the following code.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n  int a[5];\n  int b[5][4];\n}\nIn this code:\n\na: A regular array of 5 integers.\nb: A two-dimensional array, that is, an array of 5 arrays each made of 4 integers.\n\nNote that a[0] is an integer, and b[0] is an array of 4 integers.\nTo address an element in a multidimensional array we must specify the index of each dimension. To address an element in a we’ll write a[i], and for b we’ll write b[i][j].\nLet’s say that we put some numbers in the cells of b, we can visualize the two-dimensional array as follows. \nHere we can notice that b[0] is an array of 4 integers, and b[2][1] is a number 14.\nNotice that when making a multidimensional array the number of cells will be the product of all dimensions lengths. In our example, b will have \\(5*4 = 20\\) cells.\nThe number of dimension in an array can be very high. We can make an array of 7 dimensions like int c[4][6][7][54][32][2][7] and even more.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Arrays"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html#what-is-an-array",
    "href": "b0/cpp/arrays.html#what-is-an-array",
    "title": "Arrays",
    "section": "",
    "text": "An array is a series of variables of the same type and fixed size that are stored sequentially and share a common name. Variables in an array are called elements.\nTo differentiate between the elements in the array, each element is assigned a number (also called index). For an array of n elements, the elements are indexed sequentially from 0 to n - 1.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Arrays"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html#declaring-arrays",
    "href": "b0/cpp/arrays.html#declaring-arrays",
    "title": "Arrays",
    "section": "",
    "text": "To declare an array the following syntax is used:\ntype name[size];\nWhere:\n\ntype: The type of all elements in the array.\nname: The name which will be used to address the array.\nsize: The number of elements in the array.\n\nFor example:\nint a[4];\nThis defines an array named a[] with size 4. The size of the array can’t change after the initialization.\nThe size of an array doesn’t have to be an explicit integer, it can be an expression which let us choose the size of the array based on the current state of the programm.\nint n ;\ncin &gt;&gt; n;\nint a[n + 1]; // makes an array of size n + 1",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Arrays"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html#initializing",
    "href": "b0/cpp/arrays.html#initializing",
    "title": "Arrays",
    "section": "",
    "text": "If an array is defined locally we know that all elements in a[] have undetermined values. To give an array initial values, we can do the following:\nint a[4] = {2 , 4 , 5 , 0};\nThis will make an array that looks like as in the picture, where the cells are the elements of the array and the numbers below are the indices:\n\nTo decalre an array locally, and let all of its elements be 0, we can write:\nint a[2000] = {};\nThis will make 2000 integers each with inital value equal to 0.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Arrays"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html#accessing-elements",
    "href": "b0/cpp/arrays.html#accessing-elements",
    "title": "Arrays",
    "section": "",
    "text": "To call an element in the array the following syntax is used:\nname[index];\nWhere:\n\nname: The name of the array.\nindex: The index of the element that’s called.\n\nThat elements in an array act like regular variabes. The following code shows an example for this.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int a[5] = {1, 2, 3, 4, 5}; // value 1 is assigned to a[0]\n    int x = a[0];               // x will be equal to 1\n    a[0]++;                     // a[0] will become 2\n    cout &lt;&lt; x &lt;&lt; endl;          // printing 1\n    cout &lt;&lt; a[0] &lt;&lt; endl;       // printing 2\n}",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Arrays"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html#examples-of-using-arrays",
    "href": "b0/cpp/arrays.html#examples-of-using-arrays",
    "title": "Arrays",
    "section": "",
    "text": "We can make a loop that moves through the whole array by looping over its indices (0 to array_size - 1). Let’s say we want to find the sum of an array.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n;\n    cin &gt;&gt; n; // read the size of the array\n    \n    int a[n]; // make an array of size n\n    for(int i = 0; i &lt; n; i++) { // loop through all the indices, from 0 to n - 1\n        cin &gt;&gt; a[i]; // for each index i, read the value of a[i] from the input\n    }\n\n    int sum = 0;\n    for (int i = 0 ; i &lt; n ; i++) {\n        sum += a[i]; // for each index i, add the value a[i] to sum\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n}",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Arrays"
    ]
  },
  {
    "objectID": "b0/cpp/arrays.html#multidimensional-arrays",
    "href": "b0/cpp/arrays.html#multidimensional-arrays",
    "title": "Arrays",
    "section": "",
    "text": "Multidimensional arrays can be described as arrays-of-arrays, that is, an array in which each element in the array is an array as well. We call each level in the array a dimension. Let’s look at the following code.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main () {\n  int a[5];\n  int b[5][4];\n}\nIn this code:\n\na: A regular array of 5 integers.\nb: A two-dimensional array, that is, an array of 5 arrays each made of 4 integers.\n\nNote that a[0] is an integer, and b[0] is an array of 4 integers.\nTo address an element in a multidimensional array we must specify the index of each dimension. To address an element in a we’ll write a[i], and for b we’ll write b[i][j].\nLet’s say that we put some numbers in the cells of b, we can visualize the two-dimensional array as follows. \nHere we can notice that b[0] is an array of 4 integers, and b[2][1] is a number 14.\nNotice that when making a multidimensional array the number of cells will be the product of all dimensions lengths. In our example, b will have \\(5*4 = 20\\) cells.\nThe number of dimension in an array can be very high. We can make an array of 7 dimensions like int c[4][6][7][54][32][2][7] and even more.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Arrays"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html",
    "href": "b0/cpp/variables-and-types.html",
    "title": "Variables and Types",
    "section": "",
    "text": "To solve problems, we need to store and work with data like numbers, letters, or words. We store data in variables.\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int age = 15;\n    double height = 1.70;\n    char grade = 'A';\n    string name = \"Ali\";\n\n    cout &lt;&lt; name &lt;&lt; \" is \" &lt;&lt; age &lt;&lt; \" years old.\";\n    return 0;\n}\nOutput:\nAli is 15 years old.\n\n\n\n\nint → whole numbers (like 3, -7, 2025)\ndouble → numbers with decimals (like 3.14 or -0.5)\nchar → a single letter or symbol (like 'A', 'z', '?')\nstring → text or sequence of characters (like \"Hello\")\n\n\n\n\n\n\nWhen numbers get too big for an int (for example, when you count up to billions or trillions), we use long long.\nlong long population = 8000000000; // 8 billion\nWhy? Because an int can usually store values up to about 2 billion (2,147,483,647). If we need larger numbers, we must use long long.\n\n\n\nBoth store *decimal numbers, but there is a difference in precision** (how many digits they can store correctly):\n\n\n\nType\nPrecision\nExample\n\n\n\n\nfloat\nabout 6–7 digits\n3.141593\n\n\ndouble\nabout 15–16 digits\n3.141592653589793\n\n\n\n    float f = 1.61;\n    double d = 1.61;\n\n    cout &lt;&lt; setprecision(20); // show 20 decimal places\n\n    cout &lt;&lt; f &lt;&lt; endl; // prints 1.6100000143051147461\n    cout &lt;&lt; d &lt;&lt; endl; // prints 1.6100000000000000977\n\n\n\n\n\n\nCaution\n\n\n\nAs you can see in the example, most real numbers cannot be stored exactly using floats or doubles. This is something you need to keep in mind whenever you work with these types.\n\n\nMost of the time, programmers use double because it is more precise. However, double uses 8 bytes of memory, while float uses only 4. Use float only if you really need to save memory.\n\n\n\nA bool variable can take only two different values: true or false.\nbool isEven = true;\nbool isPrime = false;\nYou’ll often use it for conditions and logic in if statements:\nint x = 7;\nbool big = x &gt; 10;\ncout &lt;&lt; big; // prints 0 (false)\ntrue is represented internally as 1, and false as 0.\n\n\n\n\nint x, y;\ncin &gt;&gt; x &gt;&gt; y;\ncout &lt;&lt; x + y;\nInput:\n4 9\nOutput:\n13\nThat’s how many simple problems on platforms like Codeforces or AtCoder look!\n\n\n\n\n\n\nType\nMeaning\nExample\nMemory (approx.)\n\n\n\n\nint\nwhole number\n5, -10\n4 bytes\n\n\nlong long\nlarge whole number\n1000000000000\n8 bytes\n\n\nfloat\ndecimal (low precision)\n3.14\n4 bytes\n\n\ndouble\ndecimal (high precision)\n3.1415926535\n8 bytes\n\n\nbool\ntrue/false\ntrue\n1 byte\n\n\nchar\none character\n'A'\n1 byte\n\n\nstring\ntext\n\"Hello\"\ndepends on length\n\n\n\n\n\n\nSometimes we mix types:\nint a = 3;\ndouble b = 2.5;\ncout &lt;&lt; a + b; // 5.5\nC++ automatically converts a to a double temporarily, so the sum is also a double.\n\n\n\nauto lets the computer guess the type for you:\nauto x = 5;        // int\nauto y = 3.14;     // double\nauto word = \"Hi\";  // const char*\nYou’ll mostly use it in more advanced problems later.\n\n\n\nWhen you create variables in C++, you must choose a name for each one. This name tells the program (and humans!) what the variable represents.\nGood names make your code easier to read and understand.\n\n\nHere are the basic rules you must follow:\nYou can: - Use letters, digits, and underscores (_) - Start with a letter or an underscore - Use both uppercase and lowercase letters (C++ is case-sensitive)\nYou cannot: - Start the name with a number - Use spaces - Use special symbols like @, $, %, !, #, ?, etc. - Use C++ keywords (like int, for, return, while, etc.)\n\n\n\nCorrect names:\nint age;\ndouble total_price;\nbool isValid;\nstring firstName;\nIncorrect names:\nint 2cats;       // starts with a number\nint my variable; // spaces not allowed\nint total$;      // special character\nint int;         // keyword\n\n\n\nC++ treats uppercase and lowercase letters as different characters:\nint score = 10;\nint Score = 20;\n\ncout &lt;&lt; score; // prints 10\nHere, score and Score are two different variables.\n\n\n\nThere are different naming styles, but most C++ programmers use one of these:\n\n\n\n\n\n\n\n\nStyle\nExample\nCommon use\n\n\n\n\nsnake_case\nplayer_health\nvariables and functions in simple programs\n\n\ncamelCase\nplayerHealth\nused often in larger projects or libraries\n\n\nPascalCase\nPlayerHealth\nused for classes or structs\n\n\n\nPick one style and be consistent throughout your code.\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int playerHealth = 100;\n    int playerScore = 2500;\n    bool isAlive = true;\n\n    cout &lt;&lt; \"Health: \" &lt;&lt; playerHealth &lt;&lt; endl;\n    cout &lt;&lt; \"Score: \" &lt;&lt; playerScore &lt;&lt; endl;\n    cout &lt;&lt; \"Alive: \" &lt;&lt; isAlive &lt;&lt; endl;\n\n    return 0;\n}\nOutput:\nHealth: 100\nScore: 2500\nAlive: 1\n\n\n\n\n\n\nRule\nAllowed\nExample\n\n\n\n\nStart with letter or underscore\nYES\n_count, sum\n\n\nStart with number\nNO\n9lives\n\n\nUse space\nNO\ntotal price\n\n\nUse underscore\nYES\ntotal_price\n\n\nUse symbol ($, #, @, etc.)\nNO\ntotal$\n\n\nUse C++ keyword\nNO\nint, while\n\n\n\nGood variable names make your code cleaner and easier to debug!",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Variables and Types"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#example",
    "href": "b0/cpp/variables-and-types.html#example",
    "title": "Variables and Types",
    "section": "",
    "text": "#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int age = 15;\n    double height = 1.70;\n    char grade = 'A';\n    string name = \"Ali\";\n\n    cout &lt;&lt; name &lt;&lt; \" is \" &lt;&lt; age &lt;&lt; \" years old.\";\n    return 0;\n}\nOutput:\nAli is 15 years old.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Variables and Types"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#explanation",
    "href": "b0/cpp/variables-and-types.html#explanation",
    "title": "Variables and Types",
    "section": "",
    "text": "int → whole numbers (like 3, -7, 2025)\ndouble → numbers with decimals (like 3.14 or -0.5)\nchar → a single letter or symbol (like 'A', 'z', '?')\nstring → text or sequence of characters (like \"Hello\")",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Variables and Types"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#more-number-types",
    "href": "b0/cpp/variables-and-types.html#more-number-types",
    "title": "Variables and Types",
    "section": "",
    "text": "When numbers get too big for an int (for example, when you count up to billions or trillions), we use long long.\nlong long population = 8000000000; // 8 billion\nWhy? Because an int can usually store values up to about 2 billion (2,147,483,647). If we need larger numbers, we must use long long.\n\n\n\nBoth store *decimal numbers, but there is a difference in precision** (how many digits they can store correctly):\n\n\n\nType\nPrecision\nExample\n\n\n\n\nfloat\nabout 6–7 digits\n3.141593\n\n\ndouble\nabout 15–16 digits\n3.141592653589793\n\n\n\n    float f = 1.61;\n    double d = 1.61;\n\n    cout &lt;&lt; setprecision(20); // show 20 decimal places\n\n    cout &lt;&lt; f &lt;&lt; endl; // prints 1.6100000143051147461\n    cout &lt;&lt; d &lt;&lt; endl; // prints 1.6100000000000000977\n\n\n\n\n\n\nCaution\n\n\n\nAs you can see in the example, most real numbers cannot be stored exactly using floats or doubles. This is something you need to keep in mind whenever you work with these types.\n\n\nMost of the time, programmers use double because it is more precise. However, double uses 8 bytes of memory, while float uses only 4. Use float only if you really need to save memory.\n\n\n\nA bool variable can take only two different values: true or false.\nbool isEven = true;\nbool isPrime = false;\nYou’ll often use it for conditions and logic in if statements:\nint x = 7;\nbool big = x &gt; 10;\ncout &lt;&lt; big; // prints 0 (false)\ntrue is represented internally as 1, and false as 0.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Variables and Types"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#example-input-and-output-with-variables",
    "href": "b0/cpp/variables-and-types.html#example-input-and-output-with-variables",
    "title": "Variables and Types",
    "section": "",
    "text": "int x, y;\ncin &gt;&gt; x &gt;&gt; y;\ncout &lt;&lt; x + y;\nInput:\n4 9\nOutput:\n13\nThat’s how many simple problems on platforms like Codeforces or AtCoder look!",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Variables and Types"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#type-summary-table",
    "href": "b0/cpp/variables-and-types.html#type-summary-table",
    "title": "Variables and Types",
    "section": "",
    "text": "Type\nMeaning\nExample\nMemory (approx.)\n\n\n\n\nint\nwhole number\n5, -10\n4 bytes\n\n\nlong long\nlarge whole number\n1000000000000\n8 bytes\n\n\nfloat\ndecimal (low precision)\n3.14\n4 bytes\n\n\ndouble\ndecimal (high precision)\n3.1415926535\n8 bytes\n\n\nbool\ntrue/false\ntrue\n1 byte\n\n\nchar\none character\n'A'\n1 byte\n\n\nstring\ntext\n\"Hello\"\ndepends on length",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Variables and Types"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#type-conversion",
    "href": "b0/cpp/variables-and-types.html#type-conversion",
    "title": "Variables and Types",
    "section": "",
    "text": "Sometimes we mix types:\nint a = 3;\ndouble b = 2.5;\ncout &lt;&lt; a + b; // 5.5\nC++ automatically converts a to a double temporarily, so the sum is also a double.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Variables and Types"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#optional-auto",
    "href": "b0/cpp/variables-and-types.html#optional-auto",
    "title": "Variables and Types",
    "section": "",
    "text": "auto lets the computer guess the type for you:\nauto x = 5;        // int\nauto y = 3.14;     // double\nauto word = \"Hi\";  // const char*\nYou’ll mostly use it in more advanced problems later.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Variables and Types"
    ]
  },
  {
    "objectID": "b0/cpp/variables-and-types.html#naming-variables",
    "href": "b0/cpp/variables-and-types.html#naming-variables",
    "title": "Variables and Types",
    "section": "",
    "text": "When you create variables in C++, you must choose a name for each one. This name tells the program (and humans!) what the variable represents.\nGood names make your code easier to read and understand.\n\n\nHere are the basic rules you must follow:\nYou can: - Use letters, digits, and underscores (_) - Start with a letter or an underscore - Use both uppercase and lowercase letters (C++ is case-sensitive)\nYou cannot: - Start the name with a number - Use spaces - Use special symbols like @, $, %, !, #, ?, etc. - Use C++ keywords (like int, for, return, while, etc.)\n\n\n\nCorrect names:\nint age;\ndouble total_price;\nbool isValid;\nstring firstName;\nIncorrect names:\nint 2cats;       // starts with a number\nint my variable; // spaces not allowed\nint total$;      // special character\nint int;         // keyword\n\n\n\nC++ treats uppercase and lowercase letters as different characters:\nint score = 10;\nint Score = 20;\n\ncout &lt;&lt; score; // prints 10\nHere, score and Score are two different variables.\n\n\n\nThere are different naming styles, but most C++ programmers use one of these:\n\n\n\n\n\n\n\n\nStyle\nExample\nCommon use\n\n\n\n\nsnake_case\nplayer_health\nvariables and functions in simple programs\n\n\ncamelCase\nplayerHealth\nused often in larger projects or libraries\n\n\nPascalCase\nPlayerHealth\nused for classes or structs\n\n\n\nPick one style and be consistent throughout your code.\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int playerHealth = 100;\n    int playerScore = 2500;\n    bool isAlive = true;\n\n    cout &lt;&lt; \"Health: \" &lt;&lt; playerHealth &lt;&lt; endl;\n    cout &lt;&lt; \"Score: \" &lt;&lt; playerScore &lt;&lt; endl;\n    cout &lt;&lt; \"Alive: \" &lt;&lt; isAlive &lt;&lt; endl;\n\n    return 0;\n}\nOutput:\nHealth: 100\nScore: 2500\nAlive: 1\n\n\n\n\n\n\nRule\nAllowed\nExample\n\n\n\n\nStart with letter or underscore\nYES\n_count, sum\n\n\nStart with number\nNO\n9lives\n\n\nUse space\nNO\ntotal price\n\n\nUse underscore\nYES\ntotal_price\n\n\nUse symbol ($, #, @, etc.)\nNO\ntotal$\n\n\nUse C++ keyword\nNO\nint, while\n\n\n\nGood variable names make your code cleaner and easier to debug!",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Variables and Types"
    ]
  },
  {
    "objectID": "b0/cpp/vectors.html",
    "href": "b0/cpp/vectors.html",
    "title": "Vectors",
    "section": "",
    "text": "In C++, normal arrays have a fixed size, meaning you can’t change how many elements they hold once they’re created. This can be a problem if you don’t know in advance how many items you’ll need. To solve this, C++ provides std::vector. A vector works like an array, but it can grow or shrink when you add or remove elements.\n\n\nVectors are part of a library called &lt;vector&gt; and is defined as follows.\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;type&gt; name;\n\nname is the name of the vector.\ntype is the data type stored in the vector. It can be any valid C++ type (int, double, string, etc).\n\nAfter defining a vector, the vector is empty (like an array of size 0). To give a vector an initial size, use the following syntax.\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;type&gt; name(size, value);\n\nsize is the number of elements in the vector.\nvalue is the initial value given to all elements in the vector.\n\n\n\n\nVectors behave similarly to arrays. However, vectors have additional functionalities. Let’s say that we defined a vector named v.\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;int&gt; v;\nSince v can change in size we use v.size() to get the number of elements in v.\nThe two main functionalities that make vectors special are v.push_back(x) and v.pop_back().\n\nv.push_back(x) adds the value x to the end of the vector.\nv.pop_back() removes the last element in the vector.\n\nHere is a table of common operations that can be performed on vectors.\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nv.size()\nReturns the current number of elements in the vector.\n\n\nv.push_back(x)\nAppends element x to the end of the vector.\n\n\nv.pop_back()\nRemoves the last element from the vector.\n\n\nv.resize(n)\nChanges the number of elements in the vector to n. If n is larger than the current size of the vector, it adds elements; if it is smaller, it removes excess elements from the end.\n\n\nv.clear()\nRemoves all elements from the vector.\n\n\n\n\n\n\nLet’s take a look at a code using vectors.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    \n    vector&lt;int&gt; v(3, 5);         // defines a vector of size 3 where all elements are 5\n\n    v.pop_back();                // removes the last element so v will be {5, 5}\n\n    v.push_back(2);              // adds an element 2 to the end so v be {5, 5, 2}\n    v.push_back(1);              // adds an element 1 to the end so v be {5, 5, 2, 1}\n\n    cout &lt;&lt; v.size() &lt;&lt; endl;    // prints the number of elements in v\n\n    for (int i = 0; i &lt; v.size(); i++) {\n        cout &lt;&lt; v[i] &lt;&lt; ' ';     // prints element at index i\n    }\n}\nThis program will output\n4\n5 5 2 1\nThis demonstrates basic vector operations — adding and removing elements — and their effect on both content and size.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Vectors"
    ]
  },
  {
    "objectID": "b0/cpp/vectors.html#defining-vectors",
    "href": "b0/cpp/vectors.html#defining-vectors",
    "title": "Vectors",
    "section": "",
    "text": "Vectors are part of a library called &lt;vector&gt; and is defined as follows.\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;type&gt; name;\n\nname is the name of the vector.\ntype is the data type stored in the vector. It can be any valid C++ type (int, double, string, etc).\n\nAfter defining a vector, the vector is empty (like an array of size 0). To give a vector an initial size, use the following syntax.\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;type&gt; name(size, value);\n\nsize is the number of elements in the vector.\nvalue is the initial value given to all elements in the vector.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Vectors"
    ]
  },
  {
    "objectID": "b0/cpp/vectors.html#operations-on-vectors",
    "href": "b0/cpp/vectors.html#operations-on-vectors",
    "title": "Vectors",
    "section": "",
    "text": "Vectors behave similarly to arrays. However, vectors have additional functionalities. Let’s say that we defined a vector named v.\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;int&gt; v;\nSince v can change in size we use v.size() to get the number of elements in v.\nThe two main functionalities that make vectors special are v.push_back(x) and v.pop_back().\n\nv.push_back(x) adds the value x to the end of the vector.\nv.pop_back() removes the last element in the vector.\n\nHere is a table of common operations that can be performed on vectors.\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nv.size()\nReturns the current number of elements in the vector.\n\n\nv.push_back(x)\nAppends element x to the end of the vector.\n\n\nv.pop_back()\nRemoves the last element from the vector.\n\n\nv.resize(n)\nChanges the number of elements in the vector to n. If n is larger than the current size of the vector, it adds elements; if it is smaller, it removes excess elements from the end.\n\n\nv.clear()\nRemoves all elements from the vector.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Vectors"
    ]
  },
  {
    "objectID": "b0/cpp/vectors.html#example",
    "href": "b0/cpp/vectors.html#example",
    "title": "Vectors",
    "section": "",
    "text": "Let’s take a look at a code using vectors.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    \n    vector&lt;int&gt; v(3, 5);         // defines a vector of size 3 where all elements are 5\n\n    v.pop_back();                // removes the last element so v will be {5, 5}\n\n    v.push_back(2);              // adds an element 2 to the end so v be {5, 5, 2}\n    v.push_back(1);              // adds an element 1 to the end so v be {5, 5, 2, 1}\n\n    cout &lt;&lt; v.size() &lt;&lt; endl;    // prints the number of elements in v\n\n    for (int i = 0; i &lt; v.size(); i++) {\n        cout &lt;&lt; v[i] &lt;&lt; ' ';     // prints element at index i\n    }\n}\nThis program will output\n4\n5 5 2 1\nThis demonstrates basic vector operations — adding and removing elements — and their effect on both content and size.",
    "crumbs": [
      "Stage 1",
      "C++ Basics",
      "Vectors"
    ]
  },
  {
    "objectID": "b0/cp/contests-and-platforms.html",
    "href": "b0/cp/contests-and-platforms.html",
    "title": "Contests and Platforms",
    "section": "",
    "text": "There are various websites (often called online judges) through which you may participate in contests or just solve problems for practice. The most popular such platform is Codeforces. Codeforces hosts weekly competitions which are suitable for all levels. It also hosts a large problemset which can be used for practice.\nThere are also other platforms like USACO, which host contests every 2 months or so. It also hosts a large problemset for the more skilled competitors. CSES is a website which doesn’t host contests but has a good problemset, suitable for learning topics.\n\n\n\nHere we will discuss the step by step process of creating a Codeforces account and solving your first problem.\n\n\nOnce you open the website ‘codeforces.com’ click the ‘Register’ button on the top right corner.\n\n\n\nRegistration button\n\n\nFill in the required information and pick a good password. Select a handle which represents your identity, you will only be able to change it once every year. Note: you must register with your own email dont use a temporary email as you will need to verify the account.\n\n\n\nAfter you register you will need to open your email to verify the account. After thats complete you may login successfully.\n\n\n\nNow we can start solving our first problem. At the topbar we can see a ‘Problemset’ button which will take us to the codeforces problem library. There we can view all problems which appeared in previous contests and attempt to solve them.\n\n\n\nTopbar\n\n\nThe last two columns in the problemset table correspond to the difficulty of the task and the number of people that solved the task respectively.\n\n\n\nProblemset\n\n\nIf you click on each one of those symbols you will be able to sort the tasks by that feature. Task difficulty is represented as a number which is a multiple of \\(100\\) in the range \\([800, 3500]\\).\nAfter you sort the tasks from lowest to highest difficulty you will find the task “Watermelon”\n\n\n\nSorted Problemset\n\n\nFun fact: it is also the most solved task.\n\n\nThis section describes the problem and the requirements. At the top we can see the problem title as well as the time and memory limits.\nThe task asks you to write a program which reads an integer w from input and check if that integer can be represented as the sum of two even positive integers a and b, then output “Yes” or “No”.\n\n\n\nThis section explains how exactly the input will be given, in what order and what datatypes need to be used. Although it might not explictly mention that you need long long or double, this can be inferred from the range of possible values of the variable.\nFor example if the statement says \\(-10^9 \\le x \\le 10^9\\) we know that int is sufficient, but if it says \\(-10^{18} \\le x \\le 10^{18}\\) then we must use long long.\n\n\n\nThis section describes how to output the result. So if the task wants you to use uppercase or lowercase, separate your outputs with spaces or newlines, or even how many digits to print if your result is a floating-point value.\n\n\n\nIf we try some numbers manually we might notice a pattern, for example if the w was odd we know that its impossible for a and b to be even, because even + even = even.\nSo our first idea will be: If w is odd print “No” otherwise print “Yes”\nSadly, this idea is incorrect. The counter is w = 2, the smallest positive even integer is 2 we can’t write 2 as a sum of two positive even integers.\n\n\n\nFor any number larger than 2 we can simply let a = 2 and b = w - 2 and this will work for any even integer larger than 2, and we already showed that its impossible for odd values of w.\n\n\n\nNow that we have reached a correct solution, we must express it in code. First we must read the input, then do our logic, then print the output.\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main () {\n    int w;\n    cin &gt;&gt; w;\n\n    if (w == 2 || w % 2 == 1) cout &lt;&lt; \"No\";\n    else cout &lt;&lt; \"Yes\";\n}\n\n\n\nAt the top of the page, below the topbar, we will see the following options:\n\n\n\nProblem Topbar\n\n\nIf we click on “submit” it will take us to the following page:\n\n\n\nSubmission page\n\n\nFirst thing to ensure is the language option, since we are writing in C++ we must change the language to a valid version of C++. Note: the default is always C which causes beginners to get compilation error on the first submission.\nNow we will copy the code and paste it into the “Source code” section, and hit “Submit”.\nWe will then be redirected to the submissions page which will tell us the verdict of the submission.\n\n\n\nSubmission status\n\n\nThe possible verdicts are:\n\nAccepted - meaning the solution passed all the tests.\nWrong Answer - meaning your solution did not print the correct answer on some test.\nTime Limit Exceeded - meaning your solution took too long to print an output.\nMemory Limit Exceeded - meaning your solution used too much memory.\nRuntime Error - meaning an issue occurred during the execution of your program.\n\nUsually, you will not be able to view the test where your code failed, the test might be too large or blocked by the contest organizer, so the challenge is to figure out the issue on your own.",
    "crumbs": [
      "Stage 1",
      "Competitive Programming",
      "Contests and Platforms"
    ]
  },
  {
    "objectID": "b0/cp/contests-and-platforms.html#online-platforms",
    "href": "b0/cp/contests-and-platforms.html#online-platforms",
    "title": "Contests and Platforms",
    "section": "",
    "text": "There are various websites (often called online judges) through which you may participate in contests or just solve problems for practice. The most popular such platform is Codeforces. Codeforces hosts weekly competitions which are suitable for all levels. It also hosts a large problemset which can be used for practice.\nThere are also other platforms like USACO, which host contests every 2 months or so. It also hosts a large problemset for the more skilled competitors. CSES is a website which doesn’t host contests but has a good problemset, suitable for learning topics.",
    "crumbs": [
      "Stage 1",
      "Competitive Programming",
      "Contests and Platforms"
    ]
  },
  {
    "objectID": "b0/cp/contests-and-platforms.html#getting-started-with-codeforces",
    "href": "b0/cp/contests-and-platforms.html#getting-started-with-codeforces",
    "title": "Contests and Platforms",
    "section": "",
    "text": "Here we will discuss the step by step process of creating a Codeforces account and solving your first problem.\n\n\nOnce you open the website ‘codeforces.com’ click the ‘Register’ button on the top right corner.\n\n\n\nRegistration button\n\n\nFill in the required information and pick a good password. Select a handle which represents your identity, you will only be able to change it once every year. Note: you must register with your own email dont use a temporary email as you will need to verify the account.\n\n\n\nAfter you register you will need to open your email to verify the account. After thats complete you may login successfully.\n\n\n\nNow we can start solving our first problem. At the topbar we can see a ‘Problemset’ button which will take us to the codeforces problem library. There we can view all problems which appeared in previous contests and attempt to solve them.\n\n\n\nTopbar\n\n\nThe last two columns in the problemset table correspond to the difficulty of the task and the number of people that solved the task respectively.\n\n\n\nProblemset\n\n\nIf you click on each one of those symbols you will be able to sort the tasks by that feature. Task difficulty is represented as a number which is a multiple of \\(100\\) in the range \\([800, 3500]\\).\nAfter you sort the tasks from lowest to highest difficulty you will find the task “Watermelon”\n\n\n\nSorted Problemset\n\n\nFun fact: it is also the most solved task.\n\n\nThis section describes the problem and the requirements. At the top we can see the problem title as well as the time and memory limits.\nThe task asks you to write a program which reads an integer w from input and check if that integer can be represented as the sum of two even positive integers a and b, then output “Yes” or “No”.\n\n\n\nThis section explains how exactly the input will be given, in what order and what datatypes need to be used. Although it might not explictly mention that you need long long or double, this can be inferred from the range of possible values of the variable.\nFor example if the statement says \\(-10^9 \\le x \\le 10^9\\) we know that int is sufficient, but if it says \\(-10^{18} \\le x \\le 10^{18}\\) then we must use long long.\n\n\n\nThis section describes how to output the result. So if the task wants you to use uppercase or lowercase, separate your outputs with spaces or newlines, or even how many digits to print if your result is a floating-point value.\n\n\n\nIf we try some numbers manually we might notice a pattern, for example if the w was odd we know that its impossible for a and b to be even, because even + even = even.\nSo our first idea will be: If w is odd print “No” otherwise print “Yes”\nSadly, this idea is incorrect. The counter is w = 2, the smallest positive even integer is 2 we can’t write 2 as a sum of two positive even integers.\n\n\n\nFor any number larger than 2 we can simply let a = 2 and b = w - 2 and this will work for any even integer larger than 2, and we already showed that its impossible for odd values of w.\n\n\n\nNow that we have reached a correct solution, we must express it in code. First we must read the input, then do our logic, then print the output.\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main () {\n    int w;\n    cin &gt;&gt; w;\n\n    if (w == 2 || w % 2 == 1) cout &lt;&lt; \"No\";\n    else cout &lt;&lt; \"Yes\";\n}\n\n\n\nAt the top of the page, below the topbar, we will see the following options:\n\n\n\nProblem Topbar\n\n\nIf we click on “submit” it will take us to the following page:\n\n\n\nSubmission page\n\n\nFirst thing to ensure is the language option, since we are writing in C++ we must change the language to a valid version of C++. Note: the default is always C which causes beginners to get compilation error on the first submission.\nNow we will copy the code and paste it into the “Source code” section, and hit “Submit”.\nWe will then be redirected to the submissions page which will tell us the verdict of the submission.\n\n\n\nSubmission status\n\n\nThe possible verdicts are:\n\nAccepted - meaning the solution passed all the tests.\nWrong Answer - meaning your solution did not print the correct answer on some test.\nTime Limit Exceeded - meaning your solution took too long to print an output.\nMemory Limit Exceeded - meaning your solution used too much memory.\nRuntime Error - meaning an issue occurred during the execution of your program.\n\nUsually, you will not be able to view the test where your code failed, the test might be too large or blocked by the contest organizer, so the challenge is to figure out the issue on your own.",
    "crumbs": [
      "Stage 1",
      "Competitive Programming",
      "Contests and Platforms"
    ]
  },
  {
    "objectID": "b0/problems/min-operations.html",
    "href": "b0/problems/min-operations.html",
    "title": "",
    "section": "",
    "text": "Min Operations\n\n\nhard\n\n\n\nTwo natural numbers \\(A\\) and \\(B\\) are given, each having the same number of digits. In one move, it is allowed either to change the value of any digit of \\(A\\), or to reverse the order of digits in \\(A\\). The first operation costs \\(X\\) riyals, and the second one costs \\(Y\\) riyals. What is the minimum amount of money needed to obtain number \\(B\\) from number \\(A\\)?\nNumbers \\(A\\) and \\(B\\) are not bigger than \\(10^{18}\\), and numbers \\(X\\) and \\(Y\\) are not bigger than \\(1000\\).\nIf this seems too hard, you can try first to solve this task assuming \\(X=1\\) and \\(Y=1000\\).",
    "crumbs": [
      "Stage 1",
      "Practice Problems",
      "Min Operations"
    ]
  },
  {
    "objectID": "b0/problems/min-operations.html#min-operations",
    "href": "b0/problems/min-operations.html#min-operations",
    "title": "",
    "section": "",
    "text": "Min Operations\n\n\nhard\n\n\n\nTwo natural numbers \\(A\\) and \\(B\\) are given, each having the same number of digits. In one move, it is allowed either to change the value of any digit of \\(A\\), or to reverse the order of digits in \\(A\\). The first operation costs \\(X\\) riyals, and the second one costs \\(Y\\) riyals. What is the minimum amount of money needed to obtain number \\(B\\) from number \\(A\\)?\nNumbers \\(A\\) and \\(B\\) are not bigger than \\(10^{18}\\), and numbers \\(X\\) and \\(Y\\) are not bigger than \\(1000\\).",
    "crumbs": [
      "Stage 1",
      "Practice Problems",
      "Min Operations"
    ]
  },
  {
    "objectID": "b0/problems/holiday-of-equality.html",
    "href": "b0/problems/holiday-of-equality.html",
    "title": "",
    "section": "",
    "text": "Holiday of Equality\n\nCodeforces\neasy\n\n\n\nGiven an array \\(A\\) of \\(N\\) integers, you may increase any element by \\(1\\) any number of times. Find the minimum total number of increments required to make all elements equal.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Holiday of Equality"
    ]
  },
  {
    "objectID": "b0/problems/holiday-of-equality.html#holiday-of-equality",
    "href": "b0/problems/holiday-of-equality.html#holiday-of-equality",
    "title": "",
    "section": "",
    "text": "Holiday of Equality\n\nCodeforces\neasy\n\n\n\nGiven an array \\(A\\) of \\(N\\) integers, you may increase any element by \\(1\\) any number of times. Find the minimum total number of increments required to make all elements equal.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Holiday of Equality"
    ]
  },
  {
    "objectID": "b0/problems/sum-product.html",
    "href": "b0/problems/sum-product.html",
    "title": "",
    "section": "",
    "text": "Sum Product\n\n\neasy\n\n\n\nThree integers \\(a\\), \\(b\\), and \\(c\\) are given. Print the product of the smallest of them and the sum of the remaining two.",
    "crumbs": [
      "Stage 1",
      "Practice Problems",
      "Sum Product"
    ]
  },
  {
    "objectID": "b0/problems/sum-product.html#sum-product",
    "href": "b0/problems/sum-product.html#sum-product",
    "title": "",
    "section": "",
    "text": "Sum Product\n\n\neasy\n\n\n\nThree integers \\(a\\), \\(b\\), and \\(c\\) are given. Print the product of the smallest of them and the sum of the remaining two.",
    "crumbs": [
      "Stage 1",
      "Practice Problems",
      "Sum Product"
    ]
  },
  {
    "objectID": "b0/problems/alternate.html",
    "href": "b0/problems/alternate.html",
    "title": "",
    "section": "",
    "text": "Alternate\n\n\neasy\n\n\n\nA natural number \\(n\\) is given. Calculate the value of the expression:\n\\[1 \\cdot n + 2 \\cdot (n - 1) - 3 \\cdot (n - 2) + 4 \\cdot (n - 3) + 5 \\cdot (n - 4) - 6 \\cdot (n - 5) + \\ldots \\pm n \\cdot 1\\]\nYou can assume that \\(1 \\leq n \\leq 1000000\\).\nSolve this using loops, while math enthusiasts are invited to try it without loops.",
    "crumbs": [
      "Stage 1",
      "Practice Problems",
      "Alternate"
    ]
  },
  {
    "objectID": "b0/problems/alternate.html#alternate",
    "href": "b0/problems/alternate.html#alternate",
    "title": "",
    "section": "",
    "text": "Alternate\n\n\neasy\n\n\n\nA natural number \\(n\\) is given. Calculate the value of the expression:\n\\[1 \\cdot n + 2 \\cdot (n - 1) - 3 \\cdot (n - 2) + 4 \\cdot (n - 3) + 5 \\cdot (n - 4) - 6 \\cdot (n - 5) + \\ldots \\pm n \\cdot 1\\]\nYou can assume that \\(1 \\leq n \\leq 1000000\\).",
    "crumbs": [
      "Stage 1",
      "Practice Problems",
      "Alternate"
    ]
  },
  {
    "objectID": "b0/problems/beautiful-matrix.html",
    "href": "b0/problems/beautiful-matrix.html",
    "title": "",
    "section": "",
    "text": "Beautiful Matrix\n\nCodeforces\neasy\n\n\n\nGiven a \\(5 \\times 5\\) matrix consisting of \\(24\\) zeroes and a single \\(1\\), your task is to find the minimum number of moves required to place the \\(1\\) in the center of the matrix.\nThe allowed moves are to swap two vertically or horizonatlly adjacent cells.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Beautiful Matrix"
    ]
  },
  {
    "objectID": "b0/problems/beautiful-matrix.html#beautiful-matrix",
    "href": "b0/problems/beautiful-matrix.html#beautiful-matrix",
    "title": "",
    "section": "",
    "text": "Beautiful Matrix\n\nCodeforces\neasy\n\n\n\nGiven a \\(5 \\times 5\\) matrix consisting of \\(24\\) zeroes and a single \\(1\\), your task is to find the minimum number of moves required to place the \\(1\\) in the center of the matrix.\nThe allowed moves are to swap two vertically or horizonatlly adjacent cells.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Beautiful Matrix"
    ]
  },
  {
    "objectID": "b0/problems/bit++.html",
    "href": "b0/problems/bit++.html",
    "title": "",
    "section": "",
    "text": "Bit++\n\nCodeforces\neasy\n\n\n\nYou are given \\(n\\) statements in the Bit++ language. There is a single variable \\(x\\), initially \\(0\\).\nEach statement is exactly one of: ++X, X++, --X, X--.\nExecuting ++ increases \\(x\\) by 1; executing -- decreases \\(x\\) by 1.\nAfter executing all \\(n\\) statements, output the final value of \\(x\\).",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Bit++"
    ]
  },
  {
    "objectID": "b0/problems/bit++.html#bit++",
    "href": "b0/problems/bit++.html#bit++",
    "title": "",
    "section": "",
    "text": "Bit++\n\nCodeforces\neasy\n\n\n\nYou are given \\(n\\) statements in the Bit++ language. There is a single variable \\(x\\), initially \\(0\\).\nEach statement is exactly one of: ++X, X++, --X, X--.\nExecuting ++ increases \\(x\\) by 1; executing -- decreases \\(x\\) by 1.\nAfter executing all \\(n\\) statements, output the final value of \\(x\\).",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Bit++"
    ]
  },
  {
    "objectID": "b0/problems/next-round.html",
    "href": "b0/problems/next-round.html",
    "title": "",
    "section": "",
    "text": "Next Round\n\nCodeforces\neasy\n\n\n\nGiven the scores of \\(N\\) participants in some competition, your task is to count how many scored greater than or equal to the participant that ranked \\(K\\)-th place and have a positive score.\n\n\n\n\n\n\nCaution\n\n\n\nIts a common mistake to forget to exclude the participants that scored \\(0\\), you must follow the statement exactly and read the task again if you can’t find the mistake in your idea.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIt is given in the task that \\(A_{i-1} \\ge A_i\\). This is an essential fact we will use in the solution.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Next Round"
    ]
  },
  {
    "objectID": "b0/problems/next-round.html#next-round",
    "href": "b0/problems/next-round.html#next-round",
    "title": "",
    "section": "",
    "text": "Next Round\n\nCodeforces\neasy\n\n\n\nGiven the scores of \\(N\\) participants in some competition, your task is to count how many scored greater than or equal to the participant that ranked \\(K\\)-th place and have a positive score.\n\n\n\n\n\n\nCaution\n\n\n\nIts a common mistake to forget to exclude the participants that scored \\(0\\), you must follow the statement exactly and read the task again if you can’t find the mistake in your idea.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIt is given in the task that \\(A_{i-1} \\ge A_i\\). This is an essential fact we will use in the solution.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Next Round"
    ]
  },
  {
    "objectID": "b0/problems/team.html",
    "href": "b0/problems/team.html",
    "title": "",
    "section": "",
    "text": "Team\n\nCodeforces\neasy\n\n\n\nThere are \\(3\\) friends and \\(N\\) problems. A problem can be solved if and only if \\(2\\) or more friends know its solution.\nFor each of the \\(N\\) problems, given whether or not each friend knows its solution, your task is to count how many problems can be solved.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Team"
    ]
  },
  {
    "objectID": "b0/problems/team.html#team",
    "href": "b0/problems/team.html#team",
    "title": "",
    "section": "",
    "text": "Team\n\nCodeforces\neasy\n\n\n\nThere are \\(3\\) friends and \\(N\\) problems. A problem can be solved if and only if \\(2\\) or more friends know its solution.\nFor each of the \\(N\\) problems, given whether or not each friend knows its solution, your task is to count how many problems can be solved.",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Team"
    ]
  },
  {
    "objectID": "b0/problems/weird-algorithm.html",
    "href": "b0/problems/weird-algorithm.html",
    "title": "",
    "section": "",
    "text": "Weird Algorithm\n\nCSES\neasy\n\n\n\nGiven a positive integer \\(n\\), repeatedly apply:\n\nif \\(n\\) is even, set \\(n \\leftarrow n/2\\);\nif \\(n\\) is odd, set \\(n \\leftarrow 3n+1\\).\n\nPrint all values of \\(n\\) from the start until it reaches \\(1\\).",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Weird Algorithm"
    ]
  },
  {
    "objectID": "b0/problems/weird-algorithm.html#weird-algorithm",
    "href": "b0/problems/weird-algorithm.html#weird-algorithm",
    "title": "",
    "section": "",
    "text": "Weird Algorithm\n\nCSES\neasy\n\n\n\nGiven a positive integer \\(n\\), repeatedly apply:\n\nif \\(n\\) is even, set \\(n \\leftarrow n/2\\);\nif \\(n\\) is odd, set \\(n \\leftarrow 3n+1\\).\n\nPrint all values of \\(n\\) from the start until it reaches \\(1\\).",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Weird Algorithm"
    ]
  },
  {
    "objectID": "b0/problems/dislike-of-threes.html",
    "href": "b0/problems/dislike-of-threes.html",
    "title": "",
    "section": "",
    "text": "Dislike of Threes\n\nCodeforces\neasy\n\n\n\nThere are \\(T\\) testcases. For each test you are given a positive integer \\(K\\), consider the sequence of positive integers that are not divisible by \\(3\\) and do not end with the digit \\(3\\) (\\(1, 2, 4, 5, 7, \\dots\\)). Find the \\(K\\)-th element of this sequence. \\(K\\) can be an integer from \\(1\\) to \\(1000\\).",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Dislike of Threes"
    ]
  },
  {
    "objectID": "b0/problems/dislike-of-threes.html#dislike-of-threes",
    "href": "b0/problems/dislike-of-threes.html#dislike-of-threes",
    "title": "",
    "section": "",
    "text": "Dislike of Threes\n\nCodeforces\neasy\n\n\n\nThere are \\(T\\) testcases. For each test you are given a positive integer \\(K\\), consider the sequence of positive integers that are not divisible by \\(3\\) and do not end with the digit \\(3\\) (\\(1, 2, 4, 5, 7, \\dots\\)). Find the \\(K\\)-th element of this sequence. \\(K\\) can be an integer from \\(1\\) to \\(1000\\).",
    "crumbs": [
      "Stage 1",
      "Problems",
      "Dislike of Threes"
    ]
  },
  {
    "objectID": "b0/debugging.html",
    "href": "b0/debugging.html",
    "title": "Debugging",
    "section": "",
    "text": "It is very common when solving a task that your program does not behave exactly as expected. The process of figuring out what went wrong and fixing it is called debugging. There is no “best” way to debug a program but there are techniques which help you find the mistake faster.\n\n\nCleaner codes are less likely to produce errors. Make sure you name your variables properly so that you don’t mix them up. Also, use proper indentation and spacing to enhance the readabilty for future debugging.\nBad code:\n#include&lt;iostream&gt;\n#include&lt;cmath&gt;\n#include&lt;cassert&gt;\n#include&lt;iomanip&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint main () {\nint a,b;\ncin&gt;&gt;a&gt;&gt;b;\nint n[a];\nfor(int m=a-1;m&gt;-1;m-=1){\ncin&gt;&gt;n[m];\n}\n   cout &lt;&lt; n[b];}\nGood code:\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n, m;                       \n    cin &gt;&gt; n &gt;&gt; m;\n\n    int a[n];\n\n    for (int i = n - 1 ; i &gt;= 0 ; i--) { // inputting the array from right to left\n        cin &gt;&gt; a[i];                \n    }\n\n    cout &lt;&lt; a[m];\n}                   \n\nIncluded only the needed libraries, don’t use massive templates.\nUse n and m for sizes or counts — this is the convention in most programming tasks, making your code easier to read and understand.\nUse i, j, k for iteration variables — these are standard names used in loops.\nIndent consistently: each level of nesting should be indented by one tab (or 4 spaces).\nUnindent when closing a block — this helps you visually see where a loop or condition ends.\nLeave comments if needed to understand what you wanted to do and compare it with what you actually did.\n\n\n\n\nThe idea is to use cout to keep track of our variables. If we notice that a variable has an unexpected value it might give us a clue on what caused that to happen.\nSay we are trying to print an array in reverse:\nint a[5] = {1, 2, 3, 4, 5};\n\nfor (int i = 4 ; i &gt;= 0 ; i++) {\n    cout &lt;&lt; a[i] &lt;&lt; ' ';\n}\nAfter running the program we see something like this:\nOutput:\n5 0 -1150222592 1577706123 1165962832 32767 126...\nThat does not look right…\nLets print the value of i before each print statement to see what index is actually being printed.\nint a[5] = {1, 2, 3, 4, 5};\n\nfor (int i = 4 ; i &gt;= 0 ; i++) {\n    cout &lt;&lt; \"index 'i' is: \" &lt;&lt; i &lt;&lt; '\\n';\n    cout &lt;&lt; a[i] &lt;&lt; '\\n'; // change this to \\n to make the output more readable\n}\nOutput:\nindex 'i' is: 4\n5\nindex 'i' is: 5\n0\nindex 'i' is: 6\n1781710592\nindex 'i' is: 7\n1056066187...\nWe expect the value of i to be 4, 3, 2, 1, 0 but instead it is increasing. The expression for updating i is the increment expression in the for-loop. It should say i-- but instead it says i++ and that was the bug.\nint a[5] = {1, 2, 3, 4, 5};\n\nfor (int i = 4 ; i &gt;= 0 ; i--) {\n    cout &lt;&lt; a[i] &lt;&lt; ' ';\n}\nOutput:\n5 4 3 2 1\n\n\n\nThe function assert accepts a boolean expression as an argument and if the expression evaluates to false the program terminates. On most judges this termination produces the verdict Runtime Error. This is useful when a program has multiple branches and is producing another verdict.\nTo use this function we must include the cassert library.\nFor example, we have a task which says: Given an integer \\(N\\), evaluate \\(1 + 2 + ... + N\\).\n#include&lt;iostream&gt;\nusing namespace std;\n\nint fast (int n) {\n    return n * (n + 1) / 2;\n}\n\nint main () {\n    int n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; fast(n);\n}\nWhen we submit this program we get Wrong Answer. We might have another solution to this problem which we are more sure of but might be too slow to pass, for example looping over the values and summing them up.\nThen we can assert if slow and fast produce the same values.\n#include&lt;iostream&gt;\n#include&lt;cassert&gt; \n\nusing namespace std;\n\nint slow (int n) {\n    int ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) ans += i;\n    return ans;\n}\n\nint fast (int n) {\n    return n * (n + 1) / 2;\n}\n\nint main () {\n    int n;\n    cin &gt;&gt; n;\n\n    assert(fast(n) == slow(n));\n\n    cout &lt;&lt; fast(n);\n}\nThis has two possible outcomes, either we get Time Limit Exceeded meaning we probably pass the small tests, or we get Runtime Error meaning they produce different results.\nIf we get get Runtime Error we can look into the formula and make sure its correct, but if we get Time Limit Exceeded then we can deduce that our formula fails on large numbers which means it can be an overflow issue.\n\n\n\n\n\n\nEnsure the output format exactly matches the problem statement (no extra spaces or lines).\nRemove all debug prints before submitting.\n\n\n\n\n\nHandle all edge cases (e.g. N = 0, N = 1, empty inputs, max constraints).\nFor problems with multiple test cases, reset all variables and containers between tests.\n\nBugs often appear when a small test follows a large one.\n\n\n\n\n\n\nRe-read the problem statement carefully.\nRe-read your code — common mistakes: mixing up N/M, i/j, etc.\nWatch for shadowed, unused, or uninitialized variables.\n\n\n\n\n\nUninitialized variables\nArray/vector out-of-bounds access\n\nMissing return from non-void functions\nSigned integer overflow (use long long)\nBit-shifting by ≥ 32 bits on 32-bit integers\n\n\n\n\n\nCheck for NaNs (e.g. sqrt of negative).\nUse long double for extra precision if needed.\nMatch the required precision in output (setprecision()).\n\n\n\n\n\nPerform manual walkthroughs on simple cases.\nStress test your code: compare results of your fast solution vs. a slow brute-force version.\n\n\n\n\n\nAny undefined behavior?\nAny assertions that might fail?\nAny possible division by 0? (mod 0 for example)\nAny possible infinite recursion?\nInvalidated pointers or iterators?\nAre you using too much memory?\n\n\n\n\n\nDo you have any possible infinite loops?\nWhat is the complexity of your algorithm?\nDid you remove debug output before submitting (ex. are you printing a lot of information to standard error)?\nUnnecessary copying of data? Consider passing variables by reference.\nTry substituting arrays in place of vectors.\n\n\n\n\n\nRewrite your solution from the start.\nBe sure to save a copy of your original solution. It’s always possible that you might introduce more bugs in your new solution.",
    "crumbs": [
      "Stage 1",
      "Debugging"
    ]
  },
  {
    "objectID": "b0/debugging.html#code-style",
    "href": "b0/debugging.html#code-style",
    "title": "Debugging",
    "section": "",
    "text": "Cleaner codes are less likely to produce errors. Make sure you name your variables properly so that you don’t mix them up. Also, use proper indentation and spacing to enhance the readabilty for future debugging.\nBad code:\n#include&lt;iostream&gt;\n#include&lt;cmath&gt;\n#include&lt;cassert&gt;\n#include&lt;iomanip&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint main () {\nint a,b;\ncin&gt;&gt;a&gt;&gt;b;\nint n[a];\nfor(int m=a-1;m&gt;-1;m-=1){\ncin&gt;&gt;n[m];\n}\n   cout &lt;&lt; n[b];}\nGood code:\n#include&lt;iostream&gt;\nusing namespace std;\n\nint main () {\n    int n, m;                       \n    cin &gt;&gt; n &gt;&gt; m;\n\n    int a[n];\n\n    for (int i = n - 1 ; i &gt;= 0 ; i--) { // inputting the array from right to left\n        cin &gt;&gt; a[i];                \n    }\n\n    cout &lt;&lt; a[m];\n}                   \n\nIncluded only the needed libraries, don’t use massive templates.\nUse n and m for sizes or counts — this is the convention in most programming tasks, making your code easier to read and understand.\nUse i, j, k for iteration variables — these are standard names used in loops.\nIndent consistently: each level of nesting should be indented by one tab (or 4 spaces).\nUnindent when closing a block — this helps you visually see where a loop or condition ends.\nLeave comments if needed to understand what you wanted to do and compare it with what you actually did.",
    "crumbs": [
      "Stage 1",
      "Debugging"
    ]
  },
  {
    "objectID": "b0/debugging.html#printing",
    "href": "b0/debugging.html#printing",
    "title": "Debugging",
    "section": "",
    "text": "The idea is to use cout to keep track of our variables. If we notice that a variable has an unexpected value it might give us a clue on what caused that to happen.\nSay we are trying to print an array in reverse:\nint a[5] = {1, 2, 3, 4, 5};\n\nfor (int i = 4 ; i &gt;= 0 ; i++) {\n    cout &lt;&lt; a[i] &lt;&lt; ' ';\n}\nAfter running the program we see something like this:\nOutput:\n5 0 -1150222592 1577706123 1165962832 32767 126...\nThat does not look right…\nLets print the value of i before each print statement to see what index is actually being printed.\nint a[5] = {1, 2, 3, 4, 5};\n\nfor (int i = 4 ; i &gt;= 0 ; i++) {\n    cout &lt;&lt; \"index 'i' is: \" &lt;&lt; i &lt;&lt; '\\n';\n    cout &lt;&lt; a[i] &lt;&lt; '\\n'; // change this to \\n to make the output more readable\n}\nOutput:\nindex 'i' is: 4\n5\nindex 'i' is: 5\n0\nindex 'i' is: 6\n1781710592\nindex 'i' is: 7\n1056066187...\nWe expect the value of i to be 4, 3, 2, 1, 0 but instead it is increasing. The expression for updating i is the increment expression in the for-loop. It should say i-- but instead it says i++ and that was the bug.\nint a[5] = {1, 2, 3, 4, 5};\n\nfor (int i = 4 ; i &gt;= 0 ; i--) {\n    cout &lt;&lt; a[i] &lt;&lt; ' ';\n}\nOutput:\n5 4 3 2 1",
    "crumbs": [
      "Stage 1",
      "Debugging"
    ]
  },
  {
    "objectID": "b0/debugging.html#assert",
    "href": "b0/debugging.html#assert",
    "title": "Debugging",
    "section": "",
    "text": "The function assert accepts a boolean expression as an argument and if the expression evaluates to false the program terminates. On most judges this termination produces the verdict Runtime Error. This is useful when a program has multiple branches and is producing another verdict.\nTo use this function we must include the cassert library.\nFor example, we have a task which says: Given an integer \\(N\\), evaluate \\(1 + 2 + ... + N\\).\n#include&lt;iostream&gt;\nusing namespace std;\n\nint fast (int n) {\n    return n * (n + 1) / 2;\n}\n\nint main () {\n    int n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; fast(n);\n}\nWhen we submit this program we get Wrong Answer. We might have another solution to this problem which we are more sure of but might be too slow to pass, for example looping over the values and summing them up.\nThen we can assert if slow and fast produce the same values.\n#include&lt;iostream&gt;\n#include&lt;cassert&gt; \n\nusing namespace std;\n\nint slow (int n) {\n    int ans = 0;\n    for (int i = 1 ; i &lt;= n ; i++) ans += i;\n    return ans;\n}\n\nint fast (int n) {\n    return n * (n + 1) / 2;\n}\n\nint main () {\n    int n;\n    cin &gt;&gt; n;\n\n    assert(fast(n) == slow(n));\n\n    cout &lt;&lt; fast(n);\n}\nThis has two possible outcomes, either we get Time Limit Exceeded meaning we probably pass the small tests, or we get Runtime Error meaning they produce different results.\nIf we get get Runtime Error we can look into the formula and make sure its correct, but if we get Time Limit Exceeded then we can deduce that our formula fails on large numbers which means it can be an overflow issue.",
    "crumbs": [
      "Stage 1",
      "Debugging"
    ]
  },
  {
    "objectID": "b0/debugging.html#other-tips",
    "href": "b0/debugging.html#other-tips",
    "title": "Debugging",
    "section": "",
    "text": "Ensure the output format exactly matches the problem statement (no extra spaces or lines).\nRemove all debug prints before submitting.\n\n\n\n\n\nHandle all edge cases (e.g. N = 0, N = 1, empty inputs, max constraints).\nFor problems with multiple test cases, reset all variables and containers between tests.\n\nBugs often appear when a small test follows a large one.\n\n\n\n\n\n\nRe-read the problem statement carefully.\nRe-read your code — common mistakes: mixing up N/M, i/j, etc.\nWatch for shadowed, unused, or uninitialized variables.\n\n\n\n\n\nUninitialized variables\nArray/vector out-of-bounds access\n\nMissing return from non-void functions\nSigned integer overflow (use long long)\nBit-shifting by ≥ 32 bits on 32-bit integers\n\n\n\n\n\nCheck for NaNs (e.g. sqrt of negative).\nUse long double for extra precision if needed.\nMatch the required precision in output (setprecision()).\n\n\n\n\n\nPerform manual walkthroughs on simple cases.\nStress test your code: compare results of your fast solution vs. a slow brute-force version.\n\n\n\n\n\nAny undefined behavior?\nAny assertions that might fail?\nAny possible division by 0? (mod 0 for example)\nAny possible infinite recursion?\nInvalidated pointers or iterators?\nAre you using too much memory?\n\n\n\n\n\nDo you have any possible infinite loops?\nWhat is the complexity of your algorithm?\nDid you remove debug output before submitting (ex. are you printing a lot of information to standard error)?\nUnnecessary copying of data? Consider passing variables by reference.\nTry substituting arrays in place of vectors.\n\n\n\n\n\nRewrite your solution from the start.\nBe sure to save a copy of your original solution. It’s always possible that you might introduce more bugs in your new solution.",
    "crumbs": [
      "Stage 1",
      "Debugging"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html",
    "href": "b1/cpp/sets.html",
    "title": "Sets",
    "section": "",
    "text": "A set is container in C++ which stores values of the same type in a way that:\n\nEach value appears only once.\nThe values are kept sorted (by default, smallest to largest).\nYou can quickly check if something exists in it.\n\n#include &lt;iostream&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nint main() {\n    set&lt;int&gt; numbers = {5, 2, 9, 2, 1};\n    for (int x : numbers)\n        cout &lt;&lt; x &lt;&lt; \" \";\n}\nOutput:\n1 2 5 9\nNotice that the second 2 disappeared — because a set doesn’t allow duplicates.\n\n\nTo use a set, include the header:\n#include &lt;set&gt;\nThen you can create a set like this:\nset&lt;int&gt; mySet;              // empty set of integers\nset&lt;string&gt; names;           // set of strings\nset&lt;char&gt; letters = {'a','b','c'};\n\n\n\n\n\n\nNote\n\n\n\nYou can also initialize it with values using braces { }.\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperation\nExample\nExplanation\n\n\n\n\ninsert(x)\ns.insert(5);\nAdds 5 to the set. (If 5 already exists, nothing happens.)\n\n\nerase(x)\ns.erase(5);\nRemoves 5 if it’s there.\n\n\nfind(x)\nif (s.find(5) != s.end())\nChecks if 5 exists. Returns an iterator (like a pointer).\n\n\ncount(x)\nif (s.count(5))\nReturns 1 if found, 0 if not. Easier for beginners.\n\n\nsize()\ns.size();\nNumber of elements.\n\n\nempty()\ns.empty();\nChecks if the set has no elements.\n\n\nclear()\ns.clear();\nRemoves everything from the set.\n\n\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nint main() {\n    set&lt;int&gt; s;\n\n    s.insert(3);\n    s.insert(1);\n    s.insert(4);\n    s.insert(3); // duplicate ignored\n\n    cout &lt;&lt; \"Elements: \";\n    for (int x : s) cout &lt;&lt; x &lt;&lt; \" \";\n    cout &lt;&lt; endl;\n\n    if (s.count(3))\n        cout &lt;&lt; \"3 is in the set\" &lt;&lt; endl;\n\n    s.erase(1);\n\n    cout &lt;&lt; \"After removing 1: \";\n    for (int x : s) cout &lt;&lt; x &lt;&lt; \" \";\n}\nOutput:\nElements: 1 3 4\n3 is in the set\nAfter removing 1: 3 4\n\n\n\nYou can go through a set using a range-based for loop or an iterator.\nfor (int x : s)\n    cout &lt;&lt; x &lt;&lt; \" \";\nOr:\nfor (auto it = s.begin(); it != s.end(); it++)\n    cout &lt;&lt; *it &lt;&lt; \" \";\nSince sets are sorted, the elements will always appear in order.\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nKeeps order?\nAllows duplicates?\nSpeed (roughly)\nNotes\n\n\n\n\nset\nYes\nNo\nO(log n)\nBalanced tree inside\n\n\nmultiset\nYes\nYes\nO(log n)\nKeeps multiple copies of the same value\n\n\nunordered_set\nNo\nNo\nO(1) average\nUses hashing, faster but order is random\n\n\n\nTips: If you care about order — use set.\nIf you need to store duplicates — use multiset.\nIf you only care about speed — use unordered_set.\n\n\n\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 2, 3, 4, 3, 1};\n    set&lt;int&gt; unique;\n\n    for (int x : nums)\n        unique.insert(x);\n\n    for (int x : unique)\n        cout &lt;&lt; x &lt;&lt; \" \";\n}\nOutput:\n1 2 3 4",
    "crumbs": [
      "Stage 2",
      "C++",
      "Sets"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html#creating-a-set",
    "href": "b1/cpp/sets.html#creating-a-set",
    "title": "Sets",
    "section": "",
    "text": "To use a set, include the header:\n#include &lt;set&gt;\nThen you can create a set like this:\nset&lt;int&gt; mySet;              // empty set of integers\nset&lt;string&gt; names;           // set of strings\nset&lt;char&gt; letters = {'a','b','c'};\n\n\n\n\n\n\nNote\n\n\n\nYou can also initialize it with values using braces { }.",
    "crumbs": [
      "Stage 2",
      "C++",
      "Sets"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html#basic-operations",
    "href": "b1/cpp/sets.html#basic-operations",
    "title": "Sets",
    "section": "",
    "text": "Operation\nExample\nExplanation\n\n\n\n\ninsert(x)\ns.insert(5);\nAdds 5 to the set. (If 5 already exists, nothing happens.)\n\n\nerase(x)\ns.erase(5);\nRemoves 5 if it’s there.\n\n\nfind(x)\nif (s.find(5) != s.end())\nChecks if 5 exists. Returns an iterator (like a pointer).\n\n\ncount(x)\nif (s.count(5))\nReturns 1 if found, 0 if not. Easier for beginners.\n\n\nsize()\ns.size();\nNumber of elements.\n\n\nempty()\ns.empty();\nChecks if the set has no elements.\n\n\nclear()\ns.clear();\nRemoves everything from the set.",
    "crumbs": [
      "Stage 2",
      "C++",
      "Sets"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html#example-using-a-set",
    "href": "b1/cpp/sets.html#example-using-a-set",
    "title": "Sets",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nint main() {\n    set&lt;int&gt; s;\n\n    s.insert(3);\n    s.insert(1);\n    s.insert(4);\n    s.insert(3); // duplicate ignored\n\n    cout &lt;&lt; \"Elements: \";\n    for (int x : s) cout &lt;&lt; x &lt;&lt; \" \";\n    cout &lt;&lt; endl;\n\n    if (s.count(3))\n        cout &lt;&lt; \"3 is in the set\" &lt;&lt; endl;\n\n    s.erase(1);\n\n    cout &lt;&lt; \"After removing 1: \";\n    for (int x : s) cout &lt;&lt; x &lt;&lt; \" \";\n}\nOutput:\nElements: 1 3 4\n3 is in the set\nAfter removing 1: 3 4",
    "crumbs": [
      "Stage 2",
      "C++",
      "Sets"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html#iterating-through-a-set",
    "href": "b1/cpp/sets.html#iterating-through-a-set",
    "title": "Sets",
    "section": "",
    "text": "You can go through a set using a range-based for loop or an iterator.\nfor (int x : s)\n    cout &lt;&lt; x &lt;&lt; \" \";\nOr:\nfor (auto it = s.begin(); it != s.end(); it++)\n    cout &lt;&lt; *it &lt;&lt; \" \";\nSince sets are sorted, the elements will always appear in order.",
    "crumbs": [
      "Stage 2",
      "C++",
      "Sets"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html#kinds-of-sets",
    "href": "b1/cpp/sets.html#kinds-of-sets",
    "title": "Sets",
    "section": "",
    "text": "Type\nKeeps order?\nAllows duplicates?\nSpeed (roughly)\nNotes\n\n\n\n\nset\nYes\nNo\nO(log n)\nBalanced tree inside\n\n\nmultiset\nYes\nYes\nO(log n)\nKeeps multiple copies of the same value\n\n\nunordered_set\nNo\nNo\nO(1) average\nUses hashing, faster but order is random\n\n\n\nTips: If you care about order — use set.\nIf you need to store duplicates — use multiset.\nIf you only care about speed — use unordered_set.",
    "crumbs": [
      "Stage 2",
      "C++",
      "Sets"
    ]
  },
  {
    "objectID": "b1/cpp/sets.html#example-removing-duplicates",
    "href": "b1/cpp/sets.html#example-removing-duplicates",
    "title": "Sets",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 2, 3, 4, 3, 1};\n    set&lt;int&gt; unique;\n\n    for (int x : nums)\n        unique.insert(x);\n\n    for (int x : unique)\n        cout &lt;&lt; x &lt;&lt; \" \";\n}\nOutput:\n1 2 3 4",
    "crumbs": [
      "Stage 2",
      "C++",
      "Sets"
    ]
  },
  {
    "objectID": "b1/greedy.html",
    "href": "b1/greedy.html",
    "title": "Greedy Algorithms",
    "section": "",
    "text": "A greedy algorithm builds a solution step by step, always choosing the best option right now, without worrying about future consequences.\nIt’s like always picking the biggest cookie first — hoping it leads to the best total outcome.\n\n\n“Greedy” means locally optimal — at each step, you take the choice that looks best at that moment.\nSometimes this also gives the global optimum (the overall best answer), but not always. The trick is knowing when greediness actually works.\n\n\n\n\nYou have a goal (like minimizing cost or maximizing value).\n\nYou make a choice that seems best right now.\n\nYou repeat until the job is done.\n\nYou never go back or change previous decisions.\nExample pattern:\nwhile (problem not solved) {\n    pick the best possible option right now;\n    update the state;\n}\n\n\n\n\n\n\n\n\nCoin change\n\n\n\n\n\nYou have coins of 1, 5, 10, and 25. Find the minimum number of coins to make 63.\n\n\n\n\n\nSolution\n\nGreedy idea: always take the largest coin possible.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    int amount = 63;\n    vector&lt;int&gt; coins = {25, 10, 5, 1};\n    int count = 0;\n\n    for (int c : coins) {\n        count += amount / c;\n        amount %= c;\n    }\n    cout &lt;&lt; count; // 6 coins\n}\nIt picks: 25 + 25 + 10 + 1 + 1 + 1 = 63 → 6 coins.\nThis greedy strategy works for most real coin systems.\n\n\n\n\n\n\n\nActivity selection\n\n\n\n\n\nYou are given activities with start and end times. You can only do one at a time. What is the maximum number of activities you can complete?\n\n\n\n\n\nSolution\n\nGreedy idea: always pick the activity that finishes first.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;pair&lt;int, int&gt;&gt; act = {{1, 3}, {2, 5}, {4, 6}, {6, 8}, {5, 7}};\n    sort(act.begin(), act.end(), [](auto &a, auto &b){ return a.second &lt; b.second; });\n\n    int count = 0, end = 0;\n    for (auto &p : act) {\n        if (p.first &gt;= end) {\n            count++;\n            end = p.second;\n        }\n    }\n    cout &lt;&lt; count; // 3\n}\nWe always take the next available activity that ends earliest — leaving more time for the rest.\n\n\n\n\n\nGreedy algorithms work when local choices lead to the global best answer.\nThis happens if the problem has the greedy choice property and optimal substructure.\nYou don’t need to memorize these terms — just test if greedy logic always works for all cases.\n\n\n\nCoin change (1, 2, 5 coins) — picking largest coin first always gives fewest coins.\n\nShortest tasks first — doing small jobs early fits more into limited time.\nMaximize sum with limit — picking largest positive numbers first.\n\n\n\n\n\nCoin change with coins {1, 3, 4}, amount = 6\n\nGreedy picks 4 + 1 + 1 = 3 coins, but best is 3 + 3 = 2 coins.\n\nSo greedy fails here — picking the biggest first wasn’t globally best\n\nPacking items by size — taking the biggest item first might block space for smaller ones that would fit better together.\n\n\n\n\n\n\nSort something (by value, end time, ratio, etc.)\n\nLoop through it\n\nPick the best valid choice each time\n\nUpdate state (remaining capacity, time, etc.)\n\nsort(items.begin(), items.end(), rule);\nfor (auto &item : items) {\n    if (can_take(item)) take(item);\n}\n\n\n\n\nVery simple and fast\n\nUsually O(n log n) or better\n\nOften works surprisingly well\n\nEasy to reason about\n\n\n\n\n\nDoesn’t always give the correct (optimal) result\n\nCan fail if future choices depend on earlier ones\n\nMust prove or test correctness carefully\n\n\n\n\n\nAlways check if a greedy choice can cause future problems\n\nTry building counterexamples to test if it’s safe\n\nMany problems combine greedy + sorting\n\n\n\n\n\nGreedy = choose the best local option at each step\n\nWorks when local choices guarantee a global optimum\n\nCommon in scheduling, graphs, and resource allocation\n\nUsually very fast and simple to code",
    "crumbs": [
      "Stage 2",
      "Greedy Algorithms"
    ]
  },
  {
    "objectID": "b1/greedy.html#what-does-greedy-mean",
    "href": "b1/greedy.html#what-does-greedy-mean",
    "title": "Greedy Algorithms",
    "section": "",
    "text": "“Greedy” means locally optimal — at each step, you take the choice that looks best at that moment.\nSometimes this also gives the global optimum (the overall best answer), but not always. The trick is knowing when greediness actually works.",
    "crumbs": [
      "Stage 2",
      "Greedy Algorithms"
    ]
  },
  {
    "objectID": "b1/greedy.html#common-idea",
    "href": "b1/greedy.html#common-idea",
    "title": "Greedy Algorithms",
    "section": "",
    "text": "You have a goal (like minimizing cost or maximizing value).\n\nYou make a choice that seems best right now.\n\nYou repeat until the job is done.\n\nYou never go back or change previous decisions.\nExample pattern:\nwhile (problem not solved) {\n    pick the best possible option right now;\n    update the state;\n}",
    "crumbs": [
      "Stage 2",
      "Greedy Algorithms"
    ]
  },
  {
    "objectID": "b1/greedy.html#coin-change",
    "href": "b1/greedy.html#coin-change",
    "title": "Greedy Algorithms",
    "section": "",
    "text": "Coin change\n\n\n\n\n\nYou have coins of 1, 5, 10, and 25. Find the minimum number of coins to make 63.",
    "crumbs": [
      "Stage 2",
      "Greedy Algorithms"
    ]
  },
  {
    "objectID": "b1/greedy.html#activity-selection",
    "href": "b1/greedy.html#activity-selection",
    "title": "Greedy Algorithms",
    "section": "",
    "text": "Activity selection\n\n\n\n\n\nYou are given activities with start and end times. You can only do one at a time. What is the maximum number of activities you can complete?",
    "crumbs": [
      "Stage 2",
      "Greedy Algorithms"
    ]
  },
  {
    "objectID": "b1/greedy.html#when-greedy-works",
    "href": "b1/greedy.html#when-greedy-works",
    "title": "Greedy Algorithms",
    "section": "",
    "text": "Greedy algorithms work when local choices lead to the global best answer.\nThis happens if the problem has the greedy choice property and optimal substructure.\nYou don’t need to memorize these terms — just test if greedy logic always works for all cases.\n\n\n\nCoin change (1, 2, 5 coins) — picking largest coin first always gives fewest coins.\n\nShortest tasks first — doing small jobs early fits more into limited time.\nMaximize sum with limit — picking largest positive numbers first.\n\n\n\n\n\nCoin change with coins {1, 3, 4}, amount = 6\n\nGreedy picks 4 + 1 + 1 = 3 coins, but best is 3 + 3 = 2 coins.\n\nSo greedy fails here — picking the biggest first wasn’t globally best\n\nPacking items by size — taking the biggest item first might block space for smaller ones that would fit better together.",
    "crumbs": [
      "Stage 2",
      "Greedy Algorithms"
    ]
  },
  {
    "objectID": "b1/greedy.html#greedy-steps-checklist",
    "href": "b1/greedy.html#greedy-steps-checklist",
    "title": "Greedy Algorithms",
    "section": "",
    "text": "Sort something (by value, end time, ratio, etc.)\n\nLoop through it\n\nPick the best valid choice each time\n\nUpdate state (remaining capacity, time, etc.)\n\nsort(items.begin(), items.end(), rule);\nfor (auto &item : items) {\n    if (can_take(item)) take(item);\n}",
    "crumbs": [
      "Stage 2",
      "Greedy Algorithms"
    ]
  },
  {
    "objectID": "b1/greedy.html#advantages",
    "href": "b1/greedy.html#advantages",
    "title": "Greedy Algorithms",
    "section": "",
    "text": "Very simple and fast\n\nUsually O(n log n) or better\n\nOften works surprisingly well\n\nEasy to reason about",
    "crumbs": [
      "Stage 2",
      "Greedy Algorithms"
    ]
  },
  {
    "objectID": "b1/greedy.html#disadvantages",
    "href": "b1/greedy.html#disadvantages",
    "title": "Greedy Algorithms",
    "section": "",
    "text": "Doesn’t always give the correct (optimal) result\n\nCan fail if future choices depend on earlier ones\n\nMust prove or test correctness carefully",
    "crumbs": [
      "Stage 2",
      "Greedy Algorithms"
    ]
  },
  {
    "objectID": "b1/greedy.html#tips",
    "href": "b1/greedy.html#tips",
    "title": "Greedy Algorithms",
    "section": "",
    "text": "Always check if a greedy choice can cause future problems\n\nTry building counterexamples to test if it’s safe\n\nMany problems combine greedy + sorting",
    "crumbs": [
      "Stage 2",
      "Greedy Algorithms"
    ]
  },
  {
    "objectID": "b1/greedy.html#quick-summary",
    "href": "b1/greedy.html#quick-summary",
    "title": "Greedy Algorithms",
    "section": "",
    "text": "Greedy = choose the best local option at each step\n\nWorks when local choices guarantee a global optimum\n\nCommon in scheduling, graphs, and resource allocation\n\nUsually very fast and simple to code",
    "crumbs": [
      "Stage 2",
      "Greedy Algorithms"
    ]
  },
  {
    "objectID": "b1/simulation.html",
    "href": "b1/simulation.html",
    "title": "Simulation",
    "section": "",
    "text": "Simulation problems are about imitating real or logical processes step by step.\nYou’re asked to “simulate” what happens — just like running a small program inside your program!\n\n\nIn competitive programming, simulation means following the rules of a problem carefully and performing each step exactly as described.\nYou don’t need a fancy algorithm — just replicate what happens, usually in loops.\nHere is a simple example of a problem solved with simulation.\n\n\n\n\n\nCollatz conjecture\n\n\n\n\n\nConsider the following process.\n\nStart with some given number \\(n\\).\nIn each step:\n\nIf \\(n\\) is even, replace it with \\(n/2\\).\nIf \\(n\\) is odd, replace it with \\(3n+1\\).\n\nPrint how many steps this process took before \\(n\\) became \\(1\\).\n\n\n\n\nYou might wonder does this process even must reach \\(1\\). Well, nobody has an answer for that, as this is a famous mathematical unsolved problem! But we can try simulating it and seeing what happens.\n\n\nSolution\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    long long n;\n    cin &gt;&gt; n;\n\n    int steps = 0;\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3*n + 1;\n        }\n        steps++;\n    }\n\n    cout &lt;&lt; steps &lt;&lt; \"\\n\";\n    return 0;\n}\nIf n = 3, the program goes like this:\n\n\n\nstep\nn\n\n\n\n\n0\n3\n\n\n1\n10\n\n\n2\n5\n\n\n3\n16\n\n\n4\n8\n\n\n5\n4\n\n\n6\n2\n\n\n7\n1\n\n\n\nSo the answer is 7.\n\n\n\n\n\nSimulation is perfect when:\n\nThe problem gives you a list of detailed steps or actions.\nThere is no mathematical shortcut.\nYou can just follow the process directly.\n\nCommon examples:\n\nGames (like tic-tac-toe, snake, etc.)\nMovements on a grid (robots, cars, people walking)\nString transformations (editing text, rotations)\nManaging objects (queues, stacks, or tasks over time)\n\n\n\n\nMost simulation problems follow the same pattern:\ninitialize variables\nwhile (there are still actions left) {\n    read next action\n    update variables according to rules\n}\nprint final result\nYou’re basically “playing out” the rules one by one.\n\n\n\n\n\n\n\n\nRobot on a grid\n\n\n\n\n\nA robot starts at \\((0, 0)\\). It receives a string of moves made of N, S, E, W. Print its final coordinates.\n\n\n\n\n\nSolution\n\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string moves;\n    cin &gt;&gt; moves;\n\n    int x = 0, y = 0;\n    for (char c : moves) {\n        if (c == 'N') y++;\n        else if (c == 'S') y--;\n        else if (c == 'E') x++;\n        else if (c == 'W') x--;\n    }\n    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y;\n}\n\nIf input is NNEEWS, the robot ends up at (1, 1).\n\n\n\n\n\n\n\nGame simulation\n\n\n\n\n\nYou are given an array of health points. Each second, the smallest value decreases by 1. Stop when one of them reaches 0. Print how many seconds it took.\n\n\n\n\n\nSolution\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    int n; cin &gt;&gt; n;\n    vector&lt;int&gt; hp(n);\n    for (int &x : hp) cin &gt;&gt; x;\n\n    int seconds = 0;\n    while (true) {\n        sort(hp.begin(), hp.end());\n        hp[0]--;\n        seconds++;\n        if (hp[0] == 0) break;\n    }\n    cout &lt;&lt; seconds;\n}\n\nThis simulates the entire process exactly as described.\n\n\n\n\n\n\nFollow the rules literally. Don’t try to overthink — just do what the problem says.\nUse loops and conditionals to handle different cases.\nPrint intermediate steps while debugging to make sure your logic matches the description.\nBe careful with boundaries (e.g., going off the grid or using wrong indices).\nUse small test cases to manually verify your code.\nSimulate the program with a pen on paper to understand what really happens and code it step-by-step.\n\n\n\n\nSometimes, simulation can be too slow if the process runs billions of steps. In those cases, you need to find patterns or shortcuts.\nFor example:\n\nIf a process repeats after some number of steps, use math to skip cycles.\nIf the outcome doesn’t change after a while, stop early.\n\n\n\n\n\nVery straightforward — no fancy algorithms needed\n\nEasy to implement and understand\n\nWorks for almost any rule-based process\n\n\n\n\n\nCan be slow for large inputs\n\nEasy to make small mistakes when following many steps\n\nDebugging can take time if you don’t print intermediate results\n\n\n\n\n\nSimulation means mimicking a process step by step.\n\nPerfect for problems that describe exact rules or actions.\n\nFocus on loops, conditionals, and updating variables.\n\nAlways check small examples manually.\n\nWhen it’s too slow — look for repeating patterns!",
    "crumbs": [
      "Stage 2",
      "Simulation"
    ]
  },
  {
    "objectID": "b1/simulation.html#what-does-simulation-mean",
    "href": "b1/simulation.html#what-does-simulation-mean",
    "title": "Simulation",
    "section": "",
    "text": "In competitive programming, simulation means following the rules of a problem carefully and performing each step exactly as described.\nYou don’t need a fancy algorithm — just replicate what happens, usually in loops.\nHere is a simple example of a problem solved with simulation.",
    "crumbs": [
      "Stage 2",
      "Simulation"
    ]
  },
  {
    "objectID": "b1/simulation.html#collatz-conjecture",
    "href": "b1/simulation.html#collatz-conjecture",
    "title": "Simulation",
    "section": "",
    "text": "Collatz conjecture\n\n\n\n\n\nConsider the following process.\n\nStart with some given number \\(n\\).\nIn each step:\n\nIf \\(n\\) is even, replace it with \\(n/2\\).\nIf \\(n\\) is odd, replace it with \\(3n+1\\).\n\nPrint how many steps this process took before \\(n\\) became \\(1\\).",
    "crumbs": [
      "Stage 2",
      "Simulation"
    ]
  },
  {
    "objectID": "b1/simulation.html#when-to-use-simulation",
    "href": "b1/simulation.html#when-to-use-simulation",
    "title": "Simulation",
    "section": "",
    "text": "Simulation is perfect when:\n\nThe problem gives you a list of detailed steps or actions.\nThere is no mathematical shortcut.\nYou can just follow the process directly.\n\nCommon examples:\n\nGames (like tic-tac-toe, snake, etc.)\nMovements on a grid (robots, cars, people walking)\nString transformations (editing text, rotations)\nManaging objects (queues, stacks, or tasks over time)",
    "crumbs": [
      "Stage 2",
      "Simulation"
    ]
  },
  {
    "objectID": "b1/simulation.html#simulation-pattern",
    "href": "b1/simulation.html#simulation-pattern",
    "title": "Simulation",
    "section": "",
    "text": "Most simulation problems follow the same pattern:\ninitialize variables\nwhile (there are still actions left) {\n    read next action\n    update variables according to rules\n}\nprint final result\nYou’re basically “playing out” the rules one by one.",
    "crumbs": [
      "Stage 2",
      "Simulation"
    ]
  },
  {
    "objectID": "b1/simulation.html#robot-on-a-grid",
    "href": "b1/simulation.html#robot-on-a-grid",
    "title": "Simulation",
    "section": "",
    "text": "Robot on a grid\n\n\n\n\n\nA robot starts at \\((0, 0)\\). It receives a string of moves made of N, S, E, W. Print its final coordinates.",
    "crumbs": [
      "Stage 2",
      "Simulation"
    ]
  },
  {
    "objectID": "b1/simulation.html#game-simulation",
    "href": "b1/simulation.html#game-simulation",
    "title": "Simulation",
    "section": "",
    "text": "Game simulation\n\n\n\n\n\nYou are given an array of health points. Each second, the smallest value decreases by 1. Stop when one of them reaches 0. Print how many seconds it took.",
    "crumbs": [
      "Stage 2",
      "Simulation"
    ]
  },
  {
    "objectID": "b1/simulation.html#tips-for-simulation-problems",
    "href": "b1/simulation.html#tips-for-simulation-problems",
    "title": "Simulation",
    "section": "",
    "text": "Follow the rules literally. Don’t try to overthink — just do what the problem says.\nUse loops and conditionals to handle different cases.\nPrint intermediate steps while debugging to make sure your logic matches the description.\nBe careful with boundaries (e.g., going off the grid or using wrong indices).\nUse small test cases to manually verify your code.\nSimulate the program with a pen on paper to understand what really happens and code it step-by-step.",
    "crumbs": [
      "Stage 2",
      "Simulation"
    ]
  },
  {
    "objectID": "b1/simulation.html#performance-tip",
    "href": "b1/simulation.html#performance-tip",
    "title": "Simulation",
    "section": "",
    "text": "Sometimes, simulation can be too slow if the process runs billions of steps. In those cases, you need to find patterns or shortcuts.\nFor example:\n\nIf a process repeats after some number of steps, use math to skip cycles.\nIf the outcome doesn’t change after a while, stop early.",
    "crumbs": [
      "Stage 2",
      "Simulation"
    ]
  },
  {
    "objectID": "b1/simulation.html#advantages",
    "href": "b1/simulation.html#advantages",
    "title": "Simulation",
    "section": "",
    "text": "Very straightforward — no fancy algorithms needed\n\nEasy to implement and understand\n\nWorks for almost any rule-based process",
    "crumbs": [
      "Stage 2",
      "Simulation"
    ]
  },
  {
    "objectID": "b1/simulation.html#disadvantages",
    "href": "b1/simulation.html#disadvantages",
    "title": "Simulation",
    "section": "",
    "text": "Can be slow for large inputs\n\nEasy to make small mistakes when following many steps\n\nDebugging can take time if you don’t print intermediate results",
    "crumbs": [
      "Stage 2",
      "Simulation"
    ]
  },
  {
    "objectID": "b1/simulation.html#quick-summary",
    "href": "b1/simulation.html#quick-summary",
    "title": "Simulation",
    "section": "",
    "text": "Simulation means mimicking a process step by step.\n\nPerfect for problems that describe exact rules or actions.\n\nFocus on loops, conditionals, and updating variables.\n\nAlways check small examples manually.\n\nWhen it’s too slow — look for repeating patterns!",
    "crumbs": [
      "Stage 2",
      "Simulation"
    ]
  },
  {
    "objectID": "b1/problems/digit-queries.html",
    "href": "b1/problems/digit-queries.html",
    "title": "",
    "section": "",
    "text": "Digit Queries\n\nCSES\nmedium\n\n\n\nConsider the infinite string formed by concatenating all positive integers in order:\n[ 1234567891011121314]\nYou are given \\(q\\) queries. For each query, you are given a position \\(k\\) (1-indexed) in this infinite string. Your task is to output the digit at position \\(k\\).\nConstraints:\n\n\\(1 \\le q \\le 1000\\)\n\\(1 \\le k \\le 10^{18}\\)",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Digit Queries"
    ]
  },
  {
    "objectID": "b1/problems/digit-queries.html#digit-queries",
    "href": "b1/problems/digit-queries.html#digit-queries",
    "title": "",
    "section": "",
    "text": "Digit Queries\n\nCSES\nmedium\n\n\n\nConsider the infinite string formed by concatenating all positive integers in order:\n[ 1234567891011121314]\nYou are given \\(q\\) queries. For each query, you are given a position \\(k\\) (1-indexed) in this infinite string. Your task is to output the digit at position \\(k\\).\nConstraints:\n\n\\(1 \\le q \\le 1000\\)\n\\(1 \\le k \\le 10^{18}\\)",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Digit Queries"
    ]
  },
  {
    "objectID": "b1/problems/modular-exponentiation.html",
    "href": "b1/problems/modular-exponentiation.html",
    "title": "",
    "section": "",
    "text": "Modular Exponentiation\n\nCodeforces\neasy\n\n\n\nGiven two number \\(n\\) and \\(m\\) print \\(m \\bmod 2 ^ n\\)",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Modular Exponentiation"
    ]
  },
  {
    "objectID": "b1/problems/modular-exponentiation.html#modular-exponentiation",
    "href": "b1/problems/modular-exponentiation.html#modular-exponentiation",
    "title": "",
    "section": "",
    "text": "Modular Exponentiation\n\nCodeforces\neasy\n\n\n\nGiven two number \\(n\\) and \\(m\\) print \\(m \\bmod 2 ^ n\\)",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Modular Exponentiation"
    ]
  },
  {
    "objectID": "b1/problems/sum-of-two-values.html",
    "href": "b1/problems/sum-of-two-values.html",
    "title": "",
    "section": "",
    "text": "Sum of Two Values\n\nCSES\neasy\n\n\n\nYou are given an array of \\(n\\) integers, and your task is to find two distinct positions \\(i \\ne j\\) such that:\n\n\\(a_i + a_j = x.\\)\n\nIf there are multiple valid pairs, you may output any of them. If no such pair exists, output IMPOSSIBLE.\nConstraints:\n\n\\(1 \\le n \\le 2 \\cdot 10^5\\)\n\\(1 \\le x, a_i \\le 10^9\\)\n\nInput:\n\nFirst line: two integers \\(n\\) and \\(x\\) — the array size and the target sum.\nSecond line: \\(n\\) integers \\(a_1, a_2, \\dots, a_n\\) — the array values.\n\nOutput:\n\nEither two 1-based positions i j with \\(a_i + a_j = x\\) and \\(i \\ne j\\),\nOr IMPOSSIBLE if no such pair exists.\n\nExample:\nInput:\n4 8\n2 7 5 1\nOutput:\n2 4\n(one valid pair is \\(7 + 1 = 8\\))",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Sum Of Two Values"
    ]
  },
  {
    "objectID": "b1/problems/sum-of-two-values.html#sum-of-two-values",
    "href": "b1/problems/sum-of-two-values.html#sum-of-two-values",
    "title": "",
    "section": "",
    "text": "Sum of Two Values\n\nCSES\neasy\n\n\n\nYou are given an array of \\(n\\) integers, and your task is to find two distinct positions \\(i \\ne j\\) such that:\n\n\\(a_i + a_j = x.\\)\n\nIf there are multiple valid pairs, you may output any of them. If no such pair exists, output IMPOSSIBLE.\nConstraints:\n\n\\(1 \\le n \\le 2 \\cdot 10^5\\)\n\\(1 \\le x, a_i \\le 10^9\\)\n\nInput:\n\nFirst line: two integers \\(n\\) and \\(x\\) — the array size and the target sum.\nSecond line: \\(n\\) integers \\(a_1, a_2, \\dots, a_n\\) — the array values.\n\nOutput:\n\nEither two 1-based positions i j with \\(a_i + a_j = x\\) and \\(i \\ne j\\),\nOr IMPOSSIBLE if no such pair exists.\n\nExample:\nInput:\n4 8\n2 7 5 1\nOutput:\n2 4\n(one valid pair is \\(7 + 1 = 8\\))",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Sum Of Two Values"
    ]
  },
  {
    "objectID": "b1/problems/vanya-and-lanterns.html",
    "href": "b1/problems/vanya-and-lanterns.html",
    "title": "",
    "section": "",
    "text": "Vanya and Lanterns\n\nCodeforces\nmedium\n\n\n\nYou are given a line of length \\(l\\) and \\(n\\) points on it at positions \\(a_1, a_2, \\dots, a_n\\). Each point can “cover” a distance \\(d\\) to the left and \\(d\\) to the right. Find the smallest \\(d\\) so that every point on the line from \\(0\\) to \\(l\\) is covered by at least one of these points.",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Vanya and Lanterns"
    ]
  },
  {
    "objectID": "b1/problems/vanya-and-lanterns.html#vanya-and-lanterns",
    "href": "b1/problems/vanya-and-lanterns.html#vanya-and-lanterns",
    "title": "",
    "section": "",
    "text": "Vanya and Lanterns\n\nCodeforces\nmedium\n\n\n\nYou are given a line of length \\(l\\) and \\(n\\) points on it at positions \\(a_1, a_2, \\dots, a_n\\). Each point can “cover” a distance \\(d\\) to the left and \\(d\\) to the right. Find the smallest \\(d\\) so that every point on the line from \\(0\\) to \\(l\\) is covered by at least one of these points.",
    "crumbs": [
      "Stage 2",
      "Problems",
      "Vanya and Lanterns"
    ]
  },
  {
    "objectID": "b1/binary-search.html",
    "href": "b1/binary-search.html",
    "title": "Binary Search",
    "section": "",
    "text": "Binary search is a fast way to find something in a sorted list or range.\nBut before we get to that, let’s start with something simpler — linear search.\n\n\nImagine you have a list of numbers and you want to check if a number is there.\nThe most natural thing to do is to look through the list one by one.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {4, 8, 15, 16, 23, 42};\n    int target = 15;\n\n    for (int i = 0; i &lt; arr.size(); i++) {\n        if (arr[i] == target) {\n            cout &lt;&lt; \"Found at index \" &lt;&lt; i;\n            return 0;\n        }\n    }\n    cout &lt;&lt; \"Not found\";\n}\nThis is called linear search because you move linearly through the list.\nIt always works, but if the list is long, it can be slow — you might need to check every element.\nIf there are a million numbers, that’s a million checks.\n\n\n\nNow imagine you’re looking for a name in a printed phone book.\nYou wouldn’t start from the first page and read one by one.\nYou’d open somewhere in the middle, see if you’re too early or too late alphabetically, and then skip half the pages.\nThat’s binary search.\n\n\n\nBinary search is like playing the ‘guess the number’ game.\nEach time, you pick the middle value and ask:\n\nIs this too small?\nToo big?\nOr exactly right?\n\nThen you cut the search space in half.\nThis makes it much faster than linear search, but it only works if the data is sorted.\n\n\n\nLet’s find number 7 in this sorted array:\n[1, 3, 5, 7, 9, 11]\nWe start with the full range, then repeatedly narrow it down.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {1, 3, 5, 7, 9, 11};\n    int target = 7;\n    int left = 0, right = arr.size() - 1;\n\n    while (left &lt;= right) {\n        int mid = (left + right) / 2;\n        if (arr[mid] == target) {\n            cout &lt;&lt; \"Found at index \" &lt;&lt; mid;\n            return 0;\n        }\n        else if (arr[mid] &lt; target) left = mid + 1;\n        else right = mid - 1;\n    }\n\n    cout &lt;&lt; \"Not found\";\n}\nOutput:\nFound at index 3\nEach step cuts the range in half.\nIf there are n elements, binary search only needs about \\(\\log_2(n)\\) steps.\nThat’s around 20 checks even if there are a million numbers.\n\n\n\nBinary search can do more than find a number.\nYou can use it to find positions or boundaries.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {2, 4, 6, 8, 10};\n    int x = 7;\n\n    int left = 0, right = arr.size() - 1;\n    int ans = -1;\n\n    while (left &lt;= right) {\n        int mid = (left + right) / 2;\n        if (arr[mid] &gt;= x) {\n            ans = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    if (ans == -1) cout &lt;&lt; \"No element found\";\n    else cout &lt;&lt; \"First element &gt;= \" &lt;&lt; x &lt;&lt; \" is at index \" &lt;&lt; ans;\n}\nOutput:\nFirst element &gt;= 7 is at index 3\nThat means arr[3] = 8 is the first element greater than or equal to 7.\n\n\n\n\nStart with two pointers, left and right.\nFind the middle index mid.\nIf the middle value is the answer, stop.\nIf it’s too small, move left to mid + 1.\nIf it’s too big, move right to mid - 1.\nRepeat until left &gt; right.\n\n\n\n\nImagine a game where you must guess a number between 1 and 100.\nAfter each guess, you’re told if it’s too high or too low.\nYou can find the number in only about 7 tries.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int secret = 73; // pretend this is hidden\n    int left = 1, right = 100;\n    int guesses = 0;\n\n    while (left &lt;= right) {\n        int mid = (left + right) / 2;\n        guesses++;\n        if (mid == secret) {\n            cout &lt;&lt; \"Found in \" &lt;&lt; guesses &lt;&lt; \" guesses\";\n            break;\n        } else if (mid &lt; secret) left = mid + 1;\n        else right = mid - 1;\n    }\n}\nOutput:\nFound in 7 guesses",
    "crumbs": [
      "Stage 2",
      "Binary Search"
    ]
  },
  {
    "objectID": "b1/binary-search.html#starting-with-linear-search",
    "href": "b1/binary-search.html#starting-with-linear-search",
    "title": "Binary Search",
    "section": "",
    "text": "Imagine you have a list of numbers and you want to check if a number is there.\nThe most natural thing to do is to look through the list one by one.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {4, 8, 15, 16, 23, 42};\n    int target = 15;\n\n    for (int i = 0; i &lt; arr.size(); i++) {\n        if (arr[i] == target) {\n            cout &lt;&lt; \"Found at index \" &lt;&lt; i;\n            return 0;\n        }\n    }\n    cout &lt;&lt; \"Not found\";\n}\nThis is called linear search because you move linearly through the list.\nIt always works, but if the list is long, it can be slow — you might need to check every element.\nIf there are a million numbers, that’s a million checks.",
    "crumbs": [
      "Stage 2",
      "Binary Search"
    ]
  },
  {
    "objectID": "b1/binary-search.html#a-real-life-idea",
    "href": "b1/binary-search.html#a-real-life-idea",
    "title": "Binary Search",
    "section": "",
    "text": "Now imagine you’re looking for a name in a printed phone book.\nYou wouldn’t start from the first page and read one by one.\nYou’d open somewhere in the middle, see if you’re too early or too late alphabetically, and then skip half the pages.\nThat’s binary search.",
    "crumbs": [
      "Stage 2",
      "Binary Search"
    ]
  },
  {
    "objectID": "b1/binary-search.html#the-idea-of-binary-search",
    "href": "b1/binary-search.html#the-idea-of-binary-search",
    "title": "Binary Search",
    "section": "",
    "text": "Binary search is like playing the ‘guess the number’ game.\nEach time, you pick the middle value and ask:\n\nIs this too small?\nToo big?\nOr exactly right?\n\nThen you cut the search space in half.\nThis makes it much faster than linear search, but it only works if the data is sorted.",
    "crumbs": [
      "Stage 2",
      "Binary Search"
    ]
  },
  {
    "objectID": "b1/binary-search.html#example-1-classic-binary-search",
    "href": "b1/binary-search.html#example-1-classic-binary-search",
    "title": "Binary Search",
    "section": "",
    "text": "Let’s find number 7 in this sorted array:\n[1, 3, 5, 7, 9, 11]\nWe start with the full range, then repeatedly narrow it down.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {1, 3, 5, 7, 9, 11};\n    int target = 7;\n    int left = 0, right = arr.size() - 1;\n\n    while (left &lt;= right) {\n        int mid = (left + right) / 2;\n        if (arr[mid] == target) {\n            cout &lt;&lt; \"Found at index \" &lt;&lt; mid;\n            return 0;\n        }\n        else if (arr[mid] &lt; target) left = mid + 1;\n        else right = mid - 1;\n    }\n\n    cout &lt;&lt; \"Not found\";\n}\nOutput:\nFound at index 3\nEach step cuts the range in half.\nIf there are n elements, binary search only needs about \\(\\log_2(n)\\) steps.\nThat’s around 20 checks even if there are a million numbers.",
    "crumbs": [
      "Stage 2",
      "Binary Search"
    ]
  },
  {
    "objectID": "b1/binary-search.html#example-2-finding-first-element-greater-than-or-equal-to-x",
    "href": "b1/binary-search.html#example-2-finding-first-element-greater-than-or-equal-to-x",
    "title": "Binary Search",
    "section": "",
    "text": "Binary search can do more than find a number.\nYou can use it to find positions or boundaries.\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; arr = {2, 4, 6, 8, 10};\n    int x = 7;\n\n    int left = 0, right = arr.size() - 1;\n    int ans = -1;\n\n    while (left &lt;= right) {\n        int mid = (left + right) / 2;\n        if (arr[mid] &gt;= x) {\n            ans = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    if (ans == -1) cout &lt;&lt; \"No element found\";\n    else cout &lt;&lt; \"First element &gt;= \" &lt;&lt; x &lt;&lt; \" is at index \" &lt;&lt; ans;\n}\nOutput:\nFirst element &gt;= 7 is at index 3\nThat means arr[3] = 8 is the first element greater than or equal to 7.",
    "crumbs": [
      "Stage 2",
      "Binary Search"
    ]
  },
  {
    "objectID": "b1/binary-search.html#how-binary-search-works",
    "href": "b1/binary-search.html#how-binary-search-works",
    "title": "Binary Search",
    "section": "",
    "text": "Start with two pointers, left and right.\nFind the middle index mid.\nIf the middle value is the answer, stop.\nIf it’s too small, move left to mid + 1.\nIf it’s too big, move right to mid - 1.\nRepeat until left &gt; right.",
    "crumbs": [
      "Stage 2",
      "Binary Search"
    ]
  },
  {
    "objectID": "b1/binary-search.html#example-3-guessing-a-hidden-number",
    "href": "b1/binary-search.html#example-3-guessing-a-hidden-number",
    "title": "Binary Search",
    "section": "",
    "text": "Imagine a game where you must guess a number between 1 and 100.\nAfter each guess, you’re told if it’s too high or too low.\nYou can find the number in only about 7 tries.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int secret = 73; // pretend this is hidden\n    int left = 1, right = 100;\n    int guesses = 0;\n\n    while (left &lt;= right) {\n        int mid = (left + right) / 2;\n        guesses++;\n        if (mid == secret) {\n            cout &lt;&lt; \"Found in \" &lt;&lt; guesses &lt;&lt; \" guesses\";\n            break;\n        } else if (mid &lt; secret) left = mid + 1;\n        else right = mid - 1;\n    }\n}\nOutput:\nFound in 7 guesses",
    "crumbs": [
      "Stage 2",
      "Binary Search"
    ]
  },
  {
    "objectID": "b1/time-complexity.html",
    "href": "b1/time-complexity.html",
    "title": "Time Complexity",
    "section": "",
    "text": "When we write programs, some solutions run faster than others.\nTime complexity is a way to measure how fast an algorithm grows as the input gets larger.\nYou don’t measure it in seconds. You measure it in how the number of steps increases when the input size increases.\nTime complexity helps you compare algorithms without actually running them.\n\n\nLet’s say we have this code:\nfor (int i = 0; i &lt; n; i++)\n    cout &lt;&lt; i &lt;&lt; \" \";\nIf \\(n = 10\\), it prints \\(10\\) numbers.\nIf \\(n = 1000\\), it prints \\(1000\\) numbers.\nIf \\(n\\) doubles, the number of steps also doubles.\nWe say this code runs in \\(O(n)\\) time.\nThat means the time grows linearly with the size of the input.\n\n\n\nBig \\(O\\) notation (read as “big oh”) shows how the number of steps grows as \\(n\\) grows.\nWe only care about the main growth, not constants or small details.\n\n\n\n\n\n\n\n\nName\nExample\nDescription\n\n\n\n\n\\(O(1)\\)\nx = a + b;\nConstant time – runs instantly no matter how big n is\n\n\n\\(O(\\log n)\\)\nset::insert\nEach step cuts the problem in half\n\n\n\\(O(n)\\)\nLoop over array\nTime grows linearly\n\n\n\\(O(n \\log n)\\)\nSorting\nSlightly slower than \\(O(n)\\), but much faster than \\(O(n^2)\\)\n\n\n\\(O(n^2)\\)\nNested loops\nTime grows very fast as n increases\n\n\n\\(O(2^n)\\)\nTrying all combinations\nExponential – gets huge very quickly\n\n\n\nThe smaller the complexity, the faster it scales.\n\n\n\nint a = arr[0] + 10;\nNo matter how big arr is, this takes one step.\n\\(O(1)\\) means instant — independent of input size.\n\n\n\nfor (int i = 0; i &lt; n; i++)\n    sum += arr[i];\nThe loop runs once per element.\nIf the array doubles in size, time doubles too.\n\n\n\nfor (int i = 0; i &lt; n; i++)\n    for (int j = 0; j &lt; n; j++)\n        cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl;\nThere are \\(n \\cdot n\\) pairs.\nIf \\(n = 10\\), it does 100 steps. If \\(n = 1000\\), it does a million steps.\nThat’s why \\(O(n^2)\\) algorithms can get very slow fast.\n\n\n\nLet’s see how fast they grow as n increases:\n\n\n\n\\(n\\)\n\\(O(1)\\)\n\\(O(\\log n)\\)\n\\(O(n)\\)\n\\(O(n^2)\\)\n\n\n\n\n10\n1\n3\n10\n100\n\n\n100\n1\n7\n100\n10,000\n\n\n1000\n1\n10\n1000\n1,000,000\n\n\n\nEven though the differences seem small for small \\(n\\), they explode for big \\(n\\).\n\n\n\n\n\n\n\\(n\\)\nSafe maximum complexity\n\n\n\n\n\\(\\leq 10\\)\n\\(O(n!)\\)\n\n\n\\(\\leq 20\\)\n\\(O(2^n)\\) usually fine\n\n\n\\(\\leq 1000\\)\n\\(O(n^2)\\) usually fine\n\n\n\\(\\leq 10^5\\)\n\\(O(n \\log n)\\) or better\n\n\n\\(\\leq 10^7\\)\n\\(O(n)\\) or better\n\n\n\\(\\geq 10^9\\)\nOnly \\(O(1)\\) or \\(O(\\log n)\\)\n\n\n\nThis helps you guess what kind of solution is acceptable for a given input size.\n\n\n\nSometimes we also care about how much memory the program uses.\nThat’s called space complexity.\nThe idea is the same: how memory usage grows as input size grows.\nExample:\nint arr[n];  // O(n) space\nint x;       // O(1) space\n\n\n\nIf you have 10 papers to sort, you can look at each one by hand — that’s \\(O(n)\\).\nIf you have a million, you’ll need a smarter way — like sorting them in halves — that’s closer to \\(O(n \\log n)\\).",
    "crumbs": [
      "Stage 2",
      "Time Complexity"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#a-simple-example",
    "href": "b1/time-complexity.html#a-simple-example",
    "title": "Time Complexity",
    "section": "",
    "text": "Let’s say we have this code:\nfor (int i = 0; i &lt; n; i++)\n    cout &lt;&lt; i &lt;&lt; \" \";\nIf \\(n = 10\\), it prints \\(10\\) numbers.\nIf \\(n = 1000\\), it prints \\(1000\\) numbers.\nIf \\(n\\) doubles, the number of steps also doubles.\nWe say this code runs in \\(O(n)\\) time.\nThat means the time grows linearly with the size of the input.",
    "crumbs": [
      "Stage 2",
      "Time Complexity"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#what-oldots-means",
    "href": "b1/time-complexity.html#what-oldots-means",
    "title": "Time Complexity",
    "section": "",
    "text": "Big \\(O\\) notation (read as “big oh”) shows how the number of steps grows as \\(n\\) grows.\nWe only care about the main growth, not constants or small details.\n\n\n\n\n\n\n\n\nName\nExample\nDescription\n\n\n\n\n\\(O(1)\\)\nx = a + b;\nConstant time – runs instantly no matter how big n is\n\n\n\\(O(\\log n)\\)\nset::insert\nEach step cuts the problem in half\n\n\n\\(O(n)\\)\nLoop over array\nTime grows linearly\n\n\n\\(O(n \\log n)\\)\nSorting\nSlightly slower than \\(O(n)\\), but much faster than \\(O(n^2)\\)\n\n\n\\(O(n^2)\\)\nNested loops\nTime grows very fast as n increases\n\n\n\\(O(2^n)\\)\nTrying all combinations\nExponential – gets huge very quickly\n\n\n\nThe smaller the complexity, the faster it scales.",
    "crumbs": [
      "Stage 2",
      "Time Complexity"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#example-1-constant-time-o1",
    "href": "b1/time-complexity.html#example-1-constant-time-o1",
    "title": "Time Complexity",
    "section": "",
    "text": "int a = arr[0] + 10;\nNo matter how big arr is, this takes one step.\n\\(O(1)\\) means instant — independent of input size.",
    "crumbs": [
      "Stage 2",
      "Time Complexity"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#example-2-linear-time-on",
    "href": "b1/time-complexity.html#example-2-linear-time-on",
    "title": "Time Complexity",
    "section": "",
    "text": "for (int i = 0; i &lt; n; i++)\n    sum += arr[i];\nThe loop runs once per element.\nIf the array doubles in size, time doubles too.",
    "crumbs": [
      "Stage 2",
      "Time Complexity"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#example-3-quadratic-time-on2",
    "href": "b1/time-complexity.html#example-3-quadratic-time-on2",
    "title": "Time Complexity",
    "section": "",
    "text": "for (int i = 0; i &lt; n; i++)\n    for (int j = 0; j &lt; n; j++)\n        cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl;\nThere are \\(n \\cdot n\\) pairs.\nIf \\(n = 10\\), it does 100 steps. If \\(n = 1000\\), it does a million steps.\nThat’s why \\(O(n^2)\\) algorithms can get very slow fast.",
    "crumbs": [
      "Stage 2",
      "Time Complexity"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#comparing-growth-rates",
    "href": "b1/time-complexity.html#comparing-growth-rates",
    "title": "Time Complexity",
    "section": "",
    "text": "Let’s see how fast they grow as n increases:\n\n\n\n\\(n\\)\n\\(O(1)\\)\n\\(O(\\log n)\\)\n\\(O(n)\\)\n\\(O(n^2)\\)\n\n\n\n\n10\n1\n3\n10\n100\n\n\n100\n1\n7\n100\n10,000\n\n\n1000\n1\n10\n1000\n1,000,000\n\n\n\nEven though the differences seem small for small \\(n\\), they explode for big \\(n\\).",
    "crumbs": [
      "Stage 2",
      "Time Complexity"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#a-quick-rule-of-thumb",
    "href": "b1/time-complexity.html#a-quick-rule-of-thumb",
    "title": "Time Complexity",
    "section": "",
    "text": "\\(n\\)\nSafe maximum complexity\n\n\n\n\n\\(\\leq 10\\)\n\\(O(n!)\\)\n\n\n\\(\\leq 20\\)\n\\(O(2^n)\\) usually fine\n\n\n\\(\\leq 1000\\)\n\\(O(n^2)\\) usually fine\n\n\n\\(\\leq 10^5\\)\n\\(O(n \\log n)\\) or better\n\n\n\\(\\leq 10^7\\)\n\\(O(n)\\) or better\n\n\n\\(\\geq 10^9\\)\nOnly \\(O(1)\\) or \\(O(\\log n)\\)\n\n\n\nThis helps you guess what kind of solution is acceptable for a given input size.",
    "crumbs": [
      "Stage 2",
      "Time Complexity"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#space-complexity",
    "href": "b1/time-complexity.html#space-complexity",
    "title": "Time Complexity",
    "section": "",
    "text": "Sometimes we also care about how much memory the program uses.\nThat’s called space complexity.\nThe idea is the same: how memory usage grows as input size grows.\nExample:\nint arr[n];  // O(n) space\nint x;       // O(1) space",
    "crumbs": [
      "Stage 2",
      "Time Complexity"
    ]
  },
  {
    "objectID": "b1/time-complexity.html#real-life-analogy",
    "href": "b1/time-complexity.html#real-life-analogy",
    "title": "Time Complexity",
    "section": "",
    "text": "If you have 10 papers to sort, you can look at each one by hand — that’s \\(O(n)\\).\nIf you have a million, you’ll need a smarter way — like sorting them in halves — that’s closer to \\(O(n \\log n)\\).",
    "crumbs": [
      "Stage 2",
      "Time Complexity"
    ]
  },
  {
    "objectID": "b2/cpp/structs.html",
    "href": "b2/cpp/structs.html",
    "title": "Data Structures with struct",
    "section": "",
    "text": "In C++, a structure (struct) lets you group different pieces of data together under one name. You can think of it like a custom data type that you design yourself.\n\n\n\nA struct groups related variables (called members) of possibly different types.\n\n\nstruct TypeName {\n    member_type1 member_name1;\n    member_type2 member_name2;\n    // ...\n};\n\nTypeName → the name of your new type\nInside { } → the members (variables) that belong to this type\n\n\n\n\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct product {\n    int weight;\n    double price;\n};\n\nint main() {\n    product apple;\n    product banana, melon;\n\n    apple.weight = 150;      // grams\n    apple.price  = 1.99;     // riyals\n\n    banana.weight = 120;\n    banana.price  = 0.99;\n\n    cout &lt;&lt; \"Apple: \"  &lt;&lt; apple.weight  &lt;&lt; \"g, $\" &lt;&lt; apple.price  &lt;&lt; endl;\n    cout &lt;&lt; \"Banana: \" &lt;&lt; banana.weight &lt;&lt; \"g, $\" &lt;&lt; banana.price &lt;&lt; endl;\n}\n\n\nUse the dot operator .:\n\napple.weight → int\napple.price → double\n\nYou can read/write them just like normal variables.\n\n\n\n\n\nYou can declare variables at the end of the struct definition:\nstruct product {\n    int weight;\n    double price;\n} apple, banana, melon;\nHere:\n\nproduct is the type name\napple, banana, melon are variables (objects) of that type\n\n\n\n\n\nJust like int* can point to an int, a product* can point to a product.\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nstruct product {\n    int weight;\n    double price;\n};\n\nint main() {\n    product aproduct;\n    product* pproduct = &aproduct;   // pointer to aproduct\n\n    string temp;\n\n    cout &lt;&lt; \"Enter weight: \";\n    getline(cin, temp);\n    pproduct-&gt;weight = stoi(temp);\n\n    cout &lt;&lt; \"Enter price: \";\n    getline(cin, temp);\n    pmovie-&gt;price = stod(temp);\n\n    cout &lt;&lt; \"\\nYou have entered:\\n\";\n    cout &lt;&lt; pproduct-&gt;weight &lt;&lt; \" (\" &lt;&lt; pmovie-&gt;price &lt;&lt; \")\\n\";\n}\n\n\n\n\n\nExpression\nMeaning\n\n\n\n\nobj.member\nMember of the object obj\n\n\nptr-&gt;member\nMember of the object pointed to by ptr\n\n\n(*ptr).member\nSame as ptr-&gt;member\n\n\n\n\n\n\n\n\nA member of a structure can itself be another structure.\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nstruct movies_t {\n    string title;\n    int year;\n};\n\nstruct friends_t {\n    string name;\n    string email;\n    movies_t favorite_movie;\n};\n\nint main() {\n    friends_t charlie;\n\n    charlie.name = \"Charlie\";\n    charlie.email = \"charlie@example.com\";\n    charlie.favorite_movie.title = \"The Matrix\";\n    charlie.favorite_movie.year  = 1999;\n\n    cout &lt;&lt; charlie.name &lt;&lt; \"'s favorite movie is \"\n         &lt;&lt; charlie.favorite_movie.title\n         &lt;&lt; \" (\" &lt;&lt; charlie.favorite_movie.year &lt;&lt; \")\\n\";\n}\nYou can also use a pointer to friends_t:\nfriends_t charlie;\nfriends_t* pfriends = &charlie;\n\npfriends-&gt;favorite_movie.title = \"Inception\";\npfriends-&gt;favorite_movie.year  = 2010;\nHere:\n\npfriends-&gt;favorite_movie is a movies_t\npfriends-&gt;favorite_movie.title is a string\nYou can chain . and -&gt; depending on what you have (object vs pointer).",
    "crumbs": [
      "Stage 3",
      "C++",
      "**Data Structures with `struct`**"
    ]
  },
  {
    "objectID": "b2/cpp/structs.html#what-is-a-struct",
    "href": "b2/cpp/structs.html#what-is-a-struct",
    "title": "Data Structures with struct",
    "section": "",
    "text": "A struct groups related variables (called members) of possibly different types.\n\n\nstruct TypeName {\n    member_type1 member_name1;\n    member_type2 member_name2;\n    // ...\n};\n\nTypeName → the name of your new type\nInside { } → the members (variables) that belong to this type",
    "crumbs": [
      "Stage 3",
      "C++",
      "**Data Structures with `struct`**"
    ]
  },
  {
    "objectID": "b2/cpp/structs.html#example-a-product-structure",
    "href": "b2/cpp/structs.html#example-a-product-structure",
    "title": "Data Structures with struct",
    "section": "",
    "text": "#include &lt;iostream&gt;\nusing namespace std;\n\nstruct product {\n    int weight;\n    double price;\n};\n\nint main() {\n    product apple;\n    product banana, melon;\n\n    apple.weight = 150;      // grams\n    apple.price  = 1.99;     // riyals\n\n    banana.weight = 120;\n    banana.price  = 0.99;\n\n    cout &lt;&lt; \"Apple: \"  &lt;&lt; apple.weight  &lt;&lt; \"g, $\" &lt;&lt; apple.price  &lt;&lt; endl;\n    cout &lt;&lt; \"Banana: \" &lt;&lt; banana.weight &lt;&lt; \"g, $\" &lt;&lt; banana.price &lt;&lt; endl;\n}\n\n\nUse the dot operator .:\n\napple.weight → int\napple.price → double\n\nYou can read/write them just like normal variables.",
    "crumbs": [
      "Stage 3",
      "C++",
      "**Data Structures with `struct`**"
    ]
  },
  {
    "objectID": "b2/cpp/structs.html#declaring-objects-right-after-the-struct",
    "href": "b2/cpp/structs.html#declaring-objects-right-after-the-struct",
    "title": "Data Structures with struct",
    "section": "",
    "text": "You can declare variables at the end of the struct definition:\nstruct product {\n    int weight;\n    double price;\n} apple, banana, melon;\nHere:\n\nproduct is the type name\napple, banana, melon are variables (objects) of that type",
    "crumbs": [
      "Stage 3",
      "C++",
      "**Data Structures with `struct`**"
    ]
  },
  {
    "objectID": "b2/cpp/structs.html#pointers-to-structures-and-the---operator",
    "href": "b2/cpp/structs.html#pointers-to-structures-and-the---operator",
    "title": "Data Structures with struct",
    "section": "",
    "text": "Just like int* can point to an int, a product* can point to a product.\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nstruct product {\n    int weight;\n    double price;\n};\n\nint main() {\n    product aproduct;\n    product* pproduct = &aproduct;   // pointer to aproduct\n\n    string temp;\n\n    cout &lt;&lt; \"Enter weight: \";\n    getline(cin, temp);\n    pproduct-&gt;weight = stoi(temp);\n\n    cout &lt;&lt; \"Enter price: \";\n    getline(cin, temp);\n    pmovie-&gt;price = stod(temp);\n\n    cout &lt;&lt; \"\\nYou have entered:\\n\";\n    cout &lt;&lt; pproduct-&gt;weight &lt;&lt; \" (\" &lt;&lt; pmovie-&gt;price &lt;&lt; \")\\n\";\n}\n\n\n\n\n\nExpression\nMeaning\n\n\n\n\nobj.member\nMember of the object obj\n\n\nptr-&gt;member\nMember of the object pointed to by ptr\n\n\n(*ptr).member\nSame as ptr-&gt;member",
    "crumbs": [
      "Stage 3",
      "C++",
      "**Data Structures with `struct`**"
    ]
  },
  {
    "objectID": "b2/cpp/structs.html#nested-structures",
    "href": "b2/cpp/structs.html#nested-structures",
    "title": "Data Structures with struct",
    "section": "",
    "text": "A member of a structure can itself be another structure.\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nstruct movies_t {\n    string title;\n    int year;\n};\n\nstruct friends_t {\n    string name;\n    string email;\n    movies_t favorite_movie;\n};\n\nint main() {\n    friends_t charlie;\n\n    charlie.name = \"Charlie\";\n    charlie.email = \"charlie@example.com\";\n    charlie.favorite_movie.title = \"The Matrix\";\n    charlie.favorite_movie.year  = 1999;\n\n    cout &lt;&lt; charlie.name &lt;&lt; \"'s favorite movie is \"\n         &lt;&lt; charlie.favorite_movie.title\n         &lt;&lt; \" (\" &lt;&lt; charlie.favorite_movie.year &lt;&lt; \")\\n\";\n}\nYou can also use a pointer to friends_t:\nfriends_t charlie;\nfriends_t* pfriends = &charlie;\n\npfriends-&gt;favorite_movie.title = \"Inception\";\npfriends-&gt;favorite_movie.year  = 2010;\nHere:\n\npfriends-&gt;favorite_movie is a movies_t\npfriends-&gt;favorite_movie.title is a string\nYou can chain . and -&gt; depending on what you have (object vs pointer).",
    "crumbs": [
      "Stage 3",
      "C++",
      "**Data Structures with `struct`**"
    ]
  },
  {
    "objectID": "b2/problems/dice-combinations.html",
    "href": "b2/problems/dice-combinations.html",
    "title": "",
    "section": "",
    "text": "Dice Combinations\n\nCSES\neasy\n\n\n\nYou are given an integer \\(n\\). You repeatedly throw a fair 6-sided die (values \\(1..6\\)) and sum up the results.\nYour task is to count the number of ways to obtain total sum exactly \\(n\\) by throwing the die one or more times.\nOrder matters: For example, for \\(n = 3\\), the valid sequences are:\n\n\\(1 + 1 + 1\\)\n\\(1 + 2\\)\n\\(2 + 1\\)\n\\(3\\)\n\nSo the answer is \\(4\\).\nInput:\n\nA single integer \\(n\\).\n\nOutput:\n\nPrint the number of ways (modulo \\(10^9 + 7\\)).\n\nConstraints:\n\n\\(1 \\le n \\le 10^6\\)\n\nExample:\nInput:\n3\nOutput:\n4",
    "crumbs": [
      "Stage 3",
      "Problems",
      "Dice Combinations"
    ]
  },
  {
    "objectID": "b2/problems/dice-combinations.html#dice-combinations",
    "href": "b2/problems/dice-combinations.html#dice-combinations",
    "title": "",
    "section": "",
    "text": "Dice Combinations\n\nCSES\neasy\n\n\n\nYou are given an integer \\(n\\). You repeatedly throw a fair 6-sided die (values \\(1..6\\)) and sum up the results.\nYour task is to count the number of ways to obtain total sum exactly \\(n\\) by throwing the die one or more times.\nOrder matters: For example, for \\(n = 3\\), the valid sequences are:\n\n\\(1 + 1 + 1\\)\n\\(1 + 2\\)\n\\(2 + 1\\)\n\\(3\\)\n\nSo the answer is \\(4\\).\nInput:\n\nA single integer \\(n\\).\n\nOutput:\n\nPrint the number of ways (modulo \\(10^9 + 7\\)).\n\nConstraints:\n\n\\(1 \\le n \\le 10^6\\)\n\nExample:\nInput:\n3\nOutput:\n4",
    "crumbs": [
      "Stage 3",
      "Problems",
      "Dice Combinations"
    ]
  },
  {
    "objectID": "b2/problems/bit-strings.html",
    "href": "b2/problems/bit-strings.html",
    "title": "",
    "section": "",
    "text": "Bit Strings\n\nCSES\neasy\n\n\n\nYour task is to calculate the number of bit strings of length \\(n\\).\nA bit string is a sequence of \\(n\\) characters, each of which is either 0 or 1.\nFor example, if \\(n = 3\\), the bit strings are: [ 000, 001, 010, 011, 100, 101, 110, 111] so there are \\(8\\) such strings.\nInput:\n\nA single integer \\(n\\).\n\nOutput:\n\nPrint the total number of bit strings of length \\(n\\), modulo \\(10^9 + 7\\).\n\nConstraints:\n\n\\(1 \\le n \\le 10^6\\)\n\nExample:\nInput:\n3\nOutput:\n8",
    "crumbs": [
      "Stage 3",
      "Problems",
      "Bit Strings"
    ]
  },
  {
    "objectID": "b2/problems/bit-strings.html#bit-strings",
    "href": "b2/problems/bit-strings.html#bit-strings",
    "title": "",
    "section": "",
    "text": "Bit Strings\n\nCSES\neasy\n\n\n\nYour task is to calculate the number of bit strings of length \\(n\\).\nA bit string is a sequence of \\(n\\) characters, each of which is either 0 or 1.\nFor example, if \\(n = 3\\), the bit strings are: [ 000, 001, 010, 011, 100, 101, 110, 111] so there are \\(8\\) such strings.\nInput:\n\nA single integer \\(n\\).\n\nOutput:\n\nPrint the total number of bit strings of length \\(n\\), modulo \\(10^9 + 7\\).\n\nConstraints:\n\n\\(1 \\le n \\le 10^6\\)\n\nExample:\nInput:\n3\nOutput:\n8",
    "crumbs": [
      "Stage 3",
      "Problems",
      "Bit Strings"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html",
    "href": "b2/bit-manipulation.html",
    "title": "Common Bit Manipulation Tricks",
    "section": "",
    "text": "We’ll assume:\nint x;       // some non-negative integer\nint k;       // 0-based bit index (0 = least significant bit)\nand use masks like 1 &lt;&lt; k which has only bit k = 1.\n\n\n\n\n\nbool isSet = (x & (1 &lt;&lt; k)) != 0;\n\n1 &lt;&lt; k → binary number with only bit k = 1.\nx & (1 &lt;&lt; k) → keeps bit k, zeroes everything else.\nIf result is non-zero → bit k was 1.\n\n\n\n\n\nExample: Check if bit 1 of x is set.\n\nint x = 10;     // 10 = 1010 (in binary)\nint k = 1;\n\nbool isSet = (x & (1 &lt;&lt; k)) != 0; // (1010 & 0010) = 0010 != 0 → true\nSo bit 1 is set.\n\n\n\n\nProblem: Given n and k, determine if the k-th bit of n is set.\n\nIdea: Directly use the trick above.\nbool kthBitIsSet(int n, int k) {\n    return (n & (1 &lt;&lt; k)) != 0;\n}\nNo loops, constant time.\n\n\n\n\n\n\n\nx |= (1 &lt;&lt; k);\n\n| sets bits where either side has 1.\nSo we force bit k to 1, leave others unchanged.\n\n\n\n\nint x = 4; // 0100\nx |= (1 &lt;&lt; 0);  // 0100 | 0001 = 0101 (5)\n\n\n\n\n\n\n\nx &= ~(1 &lt;&lt; k);\n\n1 &lt;&lt; k → mask with bit k = 1.\n~(1 &lt;&lt; k) → mask with bit k = 0, all others = 1.\n& with that mask clears bit k.\n\n\n\n\nint x = 13; // 1101\nx &= ~(1 &lt;&lt; 2);     // ~(0100) = ...1011\n                    // 1101 & 1011 = 1001 = 9\nNow bit 2 is 0.\n\n\n\n\n\n\n\nx ^= (1 &lt;&lt; k);\n\n^ (XOR) flips a bit if the mask has 1:\n\n0 ^ 1 = 1\n1 ^ 1 = 0\n\n\n\n\n\nint x = 5; // 0101\nx ^= (1 &lt;&lt; 2); // 0101 ^ 0100 = 0001 (1)\nBit 2 was 1 → now 0.\n\n\n\n\n\nThis is a very famous trick.\n\n\nx = x & (x - 1);\nThis clears the lowest (rightmost) 1-bit in x.\n\n\n\nx      = 12 = 1100\nx - 1  = 11 = 1011\nx&(x-1)=  8 = 1000\nSo we removed the lowest 1-bit (bit 2).\n\n\n\n\n\nUses the previous trick.\n\n\nbool isPowerOfTwo = (x &gt; 0) && ((x & (x - 1)) == 0);\nWhy this works:\n\nA power of two in binary: 1, 10, 100, 1000, ...\n\nExactly one bit is set.\n\nIf you do x & (x - 1):\n\nIt removes the lowest set bit.\n\nIf there was exactly one set bit → result becomes 0.\n\nSo:\n\nx & (x - 1) is 0 ⇔ x has exactly one set bit.\n\n\n\n\n\nx = 8 (1000) → x & (x-1) = 1000 & 0111 = 0000 → power of two.\nx = 12 (1100) → x & (x-1) = 1100 & 1011 = 1000 → not zero → not a power of two.\n\n\n\n\n\n\n\n\nint lowest = x & -x;\nHere -x is the two’s-complement negative of x.\nPattern:\n\nx & -x isolates the rightmost 1-bit and zeroes everything else.\n\n\n\n\nx                     = 12 = 1100\n-x (two's complement) = 0100 (in low bits)\nx & -x                = 0100 = 4\nSo the lowest set bit corresponds to value 4 (bit 2).\n\n\n\n\n\n\nCheck bit k: isSet = (x & (1 &lt;&lt; k)) != 0;\nSet bit k: x |= (1 &lt;&lt; k);\nClear bit k: x &= ~(1 &lt;&lt; k);\nToggle bit k: x ^= (1 &lt;&lt; k);\nRemove lowest set bit: x &= (x - 1);\nCheck power of two: x &gt; 0 && (x & (x - 1)) == 0\nGet lowest set bit: lowest = x & -x;\n\nThese are the the most important bit manipulation tricks.",
    "crumbs": [
      "Stage 3",
      "Common Bit Manipulation Tricks"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#checking-if-a-bit-is-set",
    "href": "b2/bit-manipulation.html#checking-if-a-bit-is-set",
    "title": "Common Bit Manipulation Tricks",
    "section": "",
    "text": "bool isSet = (x & (1 &lt;&lt; k)) != 0;\n\n1 &lt;&lt; k → binary number with only bit k = 1.\nx & (1 &lt;&lt; k) → keeps bit k, zeroes everything else.\nIf result is non-zero → bit k was 1.\n\n\n\n\n\nExample: Check if bit 1 of x is set.\n\nint x = 10;     // 10 = 1010 (in binary)\nint k = 1;\n\nbool isSet = (x & (1 &lt;&lt; k)) != 0; // (1010 & 0010) = 0010 != 0 → true\nSo bit 1 is set.\n\n\n\n\nProblem: Given n and k, determine if the k-th bit of n is set.\n\nIdea: Directly use the trick above.\nbool kthBitIsSet(int n, int k) {\n    return (n & (1 &lt;&lt; k)) != 0;\n}\nNo loops, constant time.",
    "crumbs": [
      "Stage 3",
      "Common Bit Manipulation Tricks"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#setting-the-k-th-bit-to-1",
    "href": "b2/bit-manipulation.html#setting-the-k-th-bit-to-1",
    "title": "Common Bit Manipulation Tricks",
    "section": "",
    "text": "x |= (1 &lt;&lt; k);\n\n| sets bits where either side has 1.\nSo we force bit k to 1, leave others unchanged.\n\n\n\n\nint x = 4; // 0100\nx |= (1 &lt;&lt; 0);  // 0100 | 0001 = 0101 (5)",
    "crumbs": [
      "Stage 3",
      "Common Bit Manipulation Tricks"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#clearing-the-k-th-bit-set-it-to-0",
    "href": "b2/bit-manipulation.html#clearing-the-k-th-bit-set-it-to-0",
    "title": "Common Bit Manipulation Tricks",
    "section": "",
    "text": "x &= ~(1 &lt;&lt; k);\n\n1 &lt;&lt; k → mask with bit k = 1.\n~(1 &lt;&lt; k) → mask with bit k = 0, all others = 1.\n& with that mask clears bit k.\n\n\n\n\nint x = 13; // 1101\nx &= ~(1 &lt;&lt; 2);     // ~(0100) = ...1011\n                    // 1101 & 1011 = 1001 = 9\nNow bit 2 is 0.",
    "crumbs": [
      "Stage 3",
      "Common Bit Manipulation Tricks"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#toggling-flipping-the-k-th-bit",
    "href": "b2/bit-manipulation.html#toggling-flipping-the-k-th-bit",
    "title": "Common Bit Manipulation Tricks",
    "section": "",
    "text": "x ^= (1 &lt;&lt; k);\n\n^ (XOR) flips a bit if the mask has 1:\n\n0 ^ 1 = 1\n1 ^ 1 = 0\n\n\n\n\n\nint x = 5; // 0101\nx ^= (1 &lt;&lt; 2); // 0101 ^ 0100 = 0001 (1)\nBit 2 was 1 → now 0.",
    "crumbs": [
      "Stage 3",
      "Common Bit Manipulation Tricks"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#remove-the-lowest-set-bit",
    "href": "b2/bit-manipulation.html#remove-the-lowest-set-bit",
    "title": "Common Bit Manipulation Tricks",
    "section": "",
    "text": "This is a very famous trick.\n\n\nx = x & (x - 1);\nThis clears the lowest (rightmost) 1-bit in x.\n\n\n\nx      = 12 = 1100\nx - 1  = 11 = 1011\nx&(x-1)=  8 = 1000\nSo we removed the lowest 1-bit (bit 2).",
    "crumbs": [
      "Stage 3",
      "Common Bit Manipulation Tricks"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#check-if-x-is-a-power-of-two",
    "href": "b2/bit-manipulation.html#check-if-x-is-a-power-of-two",
    "title": "Common Bit Manipulation Tricks",
    "section": "",
    "text": "Uses the previous trick.\n\n\nbool isPowerOfTwo = (x &gt; 0) && ((x & (x - 1)) == 0);\nWhy this works:\n\nA power of two in binary: 1, 10, 100, 1000, ...\n\nExactly one bit is set.\n\nIf you do x & (x - 1):\n\nIt removes the lowest set bit.\n\nIf there was exactly one set bit → result becomes 0.\n\nSo:\n\nx & (x - 1) is 0 ⇔ x has exactly one set bit.\n\n\n\n\n\nx = 8 (1000) → x & (x-1) = 1000 & 0111 = 0000 → power of two.\nx = 12 (1100) → x & (x-1) = 1100 & 1011 = 1000 → not zero → not a power of two.",
    "crumbs": [
      "Stage 3",
      "Common Bit Manipulation Tricks"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#get-the-lowest-set-bit-only",
    "href": "b2/bit-manipulation.html#get-the-lowest-set-bit-only",
    "title": "Common Bit Manipulation Tricks",
    "section": "",
    "text": "int lowest = x & -x;\nHere -x is the two’s-complement negative of x.\nPattern:\n\nx & -x isolates the rightmost 1-bit and zeroes everything else.\n\n\n\n\nx                     = 12 = 1100\n-x (two's complement) = 0100 (in low bits)\nx & -x                = 0100 = 4\nSo the lowest set bit corresponds to value 4 (bit 2).",
    "crumbs": [
      "Stage 3",
      "Common Bit Manipulation Tricks"
    ]
  },
  {
    "objectID": "b2/bit-manipulation.html#quick-summary",
    "href": "b2/bit-manipulation.html#quick-summary",
    "title": "Common Bit Manipulation Tricks",
    "section": "",
    "text": "Check bit k: isSet = (x & (1 &lt;&lt; k)) != 0;\nSet bit k: x |= (1 &lt;&lt; k);\nClear bit k: x &= ~(1 &lt;&lt; k);\nToggle bit k: x ^= (1 &lt;&lt; k);\nRemove lowest set bit: x &= (x - 1);\nCheck power of two: x &gt; 0 && (x & (x - 1)) == 0\nGet lowest set bit: lowest = x & -x;\n\nThese are the the most important bit manipulation tricks.",
    "crumbs": [
      "Stage 3",
      "Common Bit Manipulation Tricks"
    ]
  },
  {
    "objectID": "b2/generating-subsets-using-bitmasks.html",
    "href": "b2/generating-subsets-using-bitmasks.html",
    "title": "Generating Subsets Using Bitmasks",
    "section": "",
    "text": "A subset of an sequence is a set constructed from some elements of the sequence (maybe none). for an sequence {1, 3, 5, 6, 7} sets like {1, 3}, {3, 5, 7}, and {1, 3, 5, 6, 7} are subsets of the sequence, while sets like {1, 4}, {2, 7} are not subsets of the sequence\n\n\nFor a sequence of length \\(n\\), we can represent each of its subsets using an \\(n\\)-bit binary number. In this representation, a bit is set to \\(1\\) if the corresponding element is included in the subset, and \\(0\\) if it is not.\nFor example, consider the sequence {5, 3, 1}. The binary encodings of its subsets are:\n\n\n\nSubset of {5, 3, 1}\nEncoding (Binary)\nEncoding (Decimal)\n\n\n\n\n{}\n000\n0\n\n\n{5}\n001\n1\n\n\n{3}\n010\n2\n\n\n{5, 3}\n011\n3\n\n\n{1}\n100\n4\n\n\n{5, 1}\n101\n5\n\n\n{3, 1}\n110\n6\n\n\n{5, 3, 1}\n111\n7\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nFor an sequence of length \\(n\\) the number of different subsets is \\(2^n\\).\n\n\n\n\n\nWe can observe that for a sequence of length \\(n\\), all subsets can be numbered from \\(0\\) to \\(2^n - 1\\). Using this numbering, we can loop over all integers from \\(0\\) to \\(2^n - 1\\) and generate each subset by checking which bits are set.\nFor example, suppose we want to write code that prints all subsets of a sequence a, each on a separate line.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  int n = 3;\n  int a[3] = {5, 3, 1};\n\n  for(int i = 0; i &lt; (1 &lt;&lt; n); i++) {   // loops over all subsets from 0 to 2^n - 1.\n    cout &lt;&lt; i &lt;&lt; \": \";\n\n    for(int j = 0; j &lt; n; j++) {        // loops over all bits\n      bool set = (i & (1 &lt;&lt; j)) != 0;   // checks if the j-th bit is set in i. \n      if(set) {\n        cout &lt;&lt; a[j] &lt;&lt; ' ';\n      }\n    }\n\n    cout &lt;&lt; endl;\n  }\n}\nThe output will be:\n0: \n1: 5 \n2: 3 \n3: 5 3 \n4: 1 \n5: 5 1 \n6: 3 1 \n7: 5 3 1",
    "crumbs": [
      "Stage 3",
      "Generating Subsets Using Bitmasks"
    ]
  },
  {
    "objectID": "b2/generating-subsets-using-bitmasks.html#encoding-subsets-as-binary-numbers",
    "href": "b2/generating-subsets-using-bitmasks.html#encoding-subsets-as-binary-numbers",
    "title": "Generating Subsets Using Bitmasks",
    "section": "",
    "text": "For a sequence of length \\(n\\), we can represent each of its subsets using an \\(n\\)-bit binary number. In this representation, a bit is set to \\(1\\) if the corresponding element is included in the subset, and \\(0\\) if it is not.\nFor example, consider the sequence {5, 3, 1}. The binary encodings of its subsets are:\n\n\n\nSubset of {5, 3, 1}\nEncoding (Binary)\nEncoding (Decimal)\n\n\n\n\n{}\n000\n0\n\n\n{5}\n001\n1\n\n\n{3}\n010\n2\n\n\n{5, 3}\n011\n3\n\n\n{1}\n100\n4\n\n\n{5, 1}\n101\n5\n\n\n{3, 1}\n110\n6\n\n\n{5, 3, 1}\n111\n7\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nFor an sequence of length \\(n\\) the number of different subsets is \\(2^n\\).",
    "crumbs": [
      "Stage 3",
      "Generating Subsets Using Bitmasks"
    ]
  },
  {
    "objectID": "b2/generating-subsets-using-bitmasks.html#generating-subsets",
    "href": "b2/generating-subsets-using-bitmasks.html#generating-subsets",
    "title": "Generating Subsets Using Bitmasks",
    "section": "",
    "text": "We can observe that for a sequence of length \\(n\\), all subsets can be numbered from \\(0\\) to \\(2^n - 1\\). Using this numbering, we can loop over all integers from \\(0\\) to \\(2^n - 1\\) and generate each subset by checking which bits are set.\nFor example, suppose we want to write code that prints all subsets of a sequence a, each on a separate line.\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n  int n = 3;\n  int a[3] = {5, 3, 1};\n\n  for(int i = 0; i &lt; (1 &lt;&lt; n); i++) {   // loops over all subsets from 0 to 2^n - 1.\n    cout &lt;&lt; i &lt;&lt; \": \";\n\n    for(int j = 0; j &lt; n; j++) {        // loops over all bits\n      bool set = (i & (1 &lt;&lt; j)) != 0;   // checks if the j-th bit is set in i. \n      if(set) {\n        cout &lt;&lt; a[j] &lt;&lt; ' ';\n      }\n    }\n\n    cout &lt;&lt; endl;\n  }\n}\nThe output will be:\n0: \n1: 5 \n2: 3 \n3: 5 3 \n4: 1 \n5: 5 1 \n6: 3 1 \n7: 5 3 1",
    "crumbs": [
      "Stage 3",
      "Generating Subsets Using Bitmasks"
    ]
  },
  {
    "objectID": "b2/forg1.html",
    "href": "b2/forg1.html",
    "title": "",
    "section": "",
    "text": "Frog 1\n\nAtcoder\neasy\n\n\n\nYou are given an array \\(h\\) with \\(N\\) elements. You start at the first element and must reach the last element using these moves:\n\nMove from index \\(i\\) to \\(i + 1\\) with a cost of \\(|h_i - h_{i + 1}|\\).\nMove from index \\(i\\) to \\(i + 2\\) with a cost of \\(|h_i - h_{i + 2}|\\).\n\nFind the minimum total cost required to move from the first element to the last."
  },
  {
    "objectID": "b2/forg1.html#frog-1",
    "href": "b2/forg1.html#frog-1",
    "title": "",
    "section": "",
    "text": "Frog 1\n\nAtcoder\neasy\n\n\n\nYou are given an array \\(h\\) with \\(N\\) elements. You start at the first element and must reach the last element using these moves:\n\nMove from index \\(i\\) to \\(i + 1\\) with a cost of \\(|h_i - h_{i + 1}|\\).\nMove from index \\(i\\) to \\(i + 2\\) with a cost of \\(|h_i - h_{i + 2}|\\).\n\nFind the minimum total cost required to move from the first element to the last."
  },
  {
    "objectID": "b2/vacation.html",
    "href": "b2/vacation.html",
    "title": "",
    "section": "",
    "text": "Vacation\n\nAtcoder\neasy\n\n\n\nGiven three arrays \\(a\\), \\(b\\), and \\(c\\) of integers, each of length \\(N\\), you need to select one element from each index \\(i\\) (where \\(0 \\le i &lt; N\\)) from either \\(a_i\\), \\(b_i\\), or \\(c_i\\).\nConstraint: For every index \\(i\\) (where \\(0 \\le i &lt; N - 1\\)), the elements chosen at indices \\(i\\) and \\(i + 1\\) must come from different arrays.\nDetermine and print the maximum possible sum achievable under this constraint.",
    "crumbs": [
      "Stage 3",
      "vacation.html"
    ]
  },
  {
    "objectID": "b2/vacation.html#vacation",
    "href": "b2/vacation.html#vacation",
    "title": "",
    "section": "",
    "text": "Vacation\n\nAtcoder\neasy\n\n\n\nGiven three arrays \\(a\\), \\(b\\), and \\(c\\) of integers, each of length \\(N\\), you need to select one element from each index \\(i\\) (where \\(0 \\le i &lt; N\\)) from either \\(a_i\\), \\(b_i\\), or \\(c_i\\).\nConstraint: For every index \\(i\\) (where \\(0 \\le i &lt; N - 1\\)), the elements chosen at indices \\(i\\) and \\(i + 1\\) must come from different arrays.\nDetermine and print the maximum possible sum achievable under this constraint.",
    "crumbs": [
      "Stage 3",
      "vacation.html"
    ]
  }
]